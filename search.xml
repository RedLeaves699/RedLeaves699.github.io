<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>极大似然估计</title>
      <link href="/2022/02/13/machine%20learning/%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/"/>
      <url>/2022/02/13/machine%20learning/%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>已经观测到部分样本的分布情况，根据现有的观测结果，估计已知概率分布模型的参数值。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>对于离散型（连续型）随机变量$X$，假设其概率质量函数为$P(x;\theta)$，概率密度函数为$p(x;\theta)$，其中$\theta$为待估计的参数值（可以有多个），现有$x_{1}, x_{2}, \dots,x_{n}$是来自$X$的$n$个独立同分布的样本，对于离散型随机变量，它们的联合概率为：</p><script type="math/tex; mode=display">L(\theta)=\stackrel{n}{\underset{i=1}{\prod}}P(x_{i};\theta)</script><p>对于非连续型随机变量，其联合密度为：</p><script type="math/tex; mode=display">L(\theta)=\stackrel{n}{\underset{i=1}{\prod}}p(x_{i};\theta)</script><p>其中$x_{1}, x_{2}, \dots,x_{n}$为已知量，$\theta$为未知量，称$L(\theta)$为样本的似然函数。极大似然估计<strong>相信观察得到的样本分布的正确性</strong>，也就是会想办法让<strong>观察得到的结果出现的概率最大</strong>。</p><p>【例1】现有一批观测样本$x_{1}, x_{2}, x_{3}, \dots,x_{n}$，假设其服从某个正态分布$X \sim N(\mu,\sigma^2)$，用极大似然估计法估计$\mu, \sigma$.</p><p>第一步：写出$X$的概率密度函数.</p><script type="math/tex; mode=display">p(x;\mu,\sigma)=\frac{1}{\sqrt{2\pi}\sigma}\text{exp}(-\frac{(x-\mu)^2}{2\sigma^2})</script><p>第二步：写出似然函数.</p><script type="math/tex; mode=display">L(\mu,\sigma^2)=\stackrel{n}{\underset{i=1}{\prod}}p(x_{i};\mu,\sigma^2)</script><p>第三步：求出使得$L(\mu,\sigma^2)$取到最大值的$\mu, \sigma$.</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>为了方便求导，避免大量的连乘项，由于对数函数$\ln$是单调递增函数，所以$\ln L(x;\mu,\sigma^2)$与$ L(x;\mu,\sigma^2)$具有相同的单调性。利用对数函数性质可以化简$\ln L(x;\mu,\sigma^2)$的连乘项，加了对数符号的似然函数称为对数似然函数。</p><script type="math/tex; mode=display">\ln L(\mu, \sigma^2)=\stackrel{n}{\underset{i=1}\sum}\ln\frac{1}{\sqrt{2\pi}\sigma}\text{exp}(-\frac{(x-\mu)^2}{2\sigma^2})</script><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>【例2】推导线性回归的公式$(w^*,b^*)={\arg\min}\stackrel{m}{\underset{i=1}{\sum}}(y-wx-b)^2$.</p><p>对线性回归来说，假设为以下模型：$y = wx + b + \epsilon$</p><p>$\epsilon$为不受控制的随机误差，通常假设其服从正态分布$\epsilon \sim N(0, \sigma^2)$（中心极限定理）：</p><script type="math/tex; mode=display">p(\epsilon) = \frac{1}{\sqrt{2\pi}\sigma}\text{exp}(-\frac{\epsilon}{2\sigma^2})</script><p>若将$\epsilon$用$y-(wx+b)$等价替换可得：</p><script type="math/tex; mode=display">p(y)=\frac{1}{\sqrt{2\pi}\sigma}\text{exp}(-\frac{(y-(wx+b))^2}{2\sigma^2})</script><p>上式显然可以看作$y \sim N(wx+b,\sigma^2)$，下面用极大似然估计来估算$w$和$b$的值，似然函数为：</p><script type="math/tex; mode=display">\ln L(w,b)=\stackrel{m}{\underset{i=1}\sum}\ln\frac{1}{\sqrt{2\pi}\sigma}\exp(-\frac{(y-wx-b)^2}{2\sigma^2}) = m\ln \frac{1}{\sqrt{2\pi}\sigma}-\frac{1}{2\sigma^2}\stackrel{m}{\underset{i=1}{\sum}}(y-wx-b)^2</script><p>其中$m, \sigma$均为常数，所以最大化$\ln L(w, b)$等于最小化$\stackrel{m}{\underset{i=1}{\sum}}(y-wx-b)^2$，即</p><script type="math/tex; mode=display">(w^*,b^*)=\underset{(w,b)}{\arg\max}\ln L(w,b) = \underset{(w,b)}{\arg\min}\stackrel{m}{\underset{i=1}{\sum}}(y-wx-b)^2</script><p>等价于最小二乘估计。</p>]]></content>
      
      
      <categories>
          
          <category> 前沿技术 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>json语法</title>
      <link href="/2022/02/10/Programming%20Language/json%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/02/10/Programming%20Language/json%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="JSON-语法规则"><a href="#JSON-语法规则" class="headerlink" title="JSON 语法规则"></a>JSON 语法规则</h2><p>JSON 语法是 JavaScript 对象表示语法的子集。</p><ul><li>数据在名称/值对中</li><li>数据由逗号分隔</li><li>大括号 {} 保存对象</li><li>中括号 [] 保存数组，数组可以包含多个对象</li></ul><p>名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值：</p><pre><code class="lang-json">&quot;name&quot; : &quot;redleaves&quot;</code></pre><h2 id="JSON-数字"><a href="#JSON-数字" class="headerlink" title="JSON 数字"></a>JSON 数字</h2><p>JSON 数字可以是整型或者浮点型：</p><pre><code class="lang-json">&#123; &quot;cost&quot; : 5 &#125;</code></pre><h2 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h2><p>JSON 对象在大括号 {} 中书写：</p><pre><code class="lang-json">&#123;key1 : value1, key2 : value2, ... keyN : valueN &#125;</code></pre><h2 id="JSON-数组"><a href="#JSON-数组" class="headerlink" title="JSON 数组"></a>JSON 数组</h2><p>JSON 数组在中括号 [] 中书写：</p><p>数组可包含多个对象：</p><pre><code class="lang-json">[    &#123; key1 : value1-1 , key2:value1-2 &#125;,     &#123; key1 : value2-1 , key2:value2-2 &#125;,     &#123; key1 : value3-1 , key2:value3-2 &#125;,     ...    &#123; key1 : valueN-1 , key2:valueN-2 &#125;, ]</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code class="lang-json">&#123;    &quot;sites&quot;: [        &#123; &quot;name&quot;:&quot;github&quot; , &quot;url&quot;:&quot;www.github.com&quot; &#125;,        &#123; &quot;name&quot;:&quot;gnu&quot; , &quot;url&quot;:&quot;www.gnu.org&quot; &#125;,        &#123; &quot;name&quot;:&quot;google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;,        &#123; &quot;name&quot;:null, &quot;url&quot;:null&#125;    ]&#125;</code></pre><h2 id="Python-解析JSON"><a href="#Python-解析JSON" class="headerlink" title="Python 解析JSON"></a>Python 解析JSON</h2><pre><code class="lang-python"># json 转字典dict_json = json.loads(json_response)print(dict_json)# 将字典转换成json字符串str_json =json.dumps(dict_json)print(str_json)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> javascript </tag>
            
            <tag> json </tag>
            
            <tag> 格式化文本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educoder 编译原理PL语言编译器的扩展（转载）</title>
      <link href="/2021/12/29/Compiler/PL%E8%AF%AD%E8%A8%80%E7%9A%84%E6%89%A9%E5%B1%95/"/>
      <url>/2021/12/29/Compiler/PL%E8%AF%AD%E8%A8%80%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://eto-cyt.blog.csdn.net/article/details/122023035">原文地址</a></p><h2 id="第一关"><a href="#第一关" class="headerlink" title="第一关"></a>第一关</h2><pre><code class="lang-c">#include &quot;ptoc.h&quot;#ifndef WIN32void _splitpath(const char *path, char *drive, char *dir, char *fname, char *ext);void _makepath(char *path,const char *drive, char *dir, char *fname, char *ext);static void _split_whole_name(const char *whole_name, char *fname, char *ext);#endif/********************************Constants*******************************/const int norw = 25;       /* no. of reserved words */const int txmax = 100;     /* length of identifier table */const int bmax = 20;       /* length of block inormation table */const int arrmax = 30;     /* length of array information table */const int nmax = 6;        /* max. no. of digits in numbers */const int al = 10;         /* length of identifiers */const int amax = 2047;     /* maxinum address */const int levmax = 7;      /* maxinum depth of block nesting */const int cxmax = 1000;    /* size of code array */const int min_index1 = -32767;const int max_index1 = +32767;/*******************************//********************************Enums*******************************/enum symbol &#123;nul, ident, intcon, charcon, plus, minus, times, divsym,            eql, neq, lss, leq, gtr, geq, ofsym, arraysym, programsym, modsym,            andsym, orsym, notsym, lbrack, rbrack, lparen, rparen, comma,            semicolon, period, becomes, colon, beginsym,  endsym, ifsym, thensym,            elsesym, whilesym, downtosym,tosym,repeatsym, untilsym ,forsym , casesym , dosym, callsym, constsym, typesym,            varsym, procsym, last_symbol        &#125;;enum oobject &#123;konstant, typel, variable, prosedure, last_oobject&#125;;enum types &#123;notyp, ints, chars, bool_, arrays, last_types&#125;;enum opcod &#123;lit, lod, ilod, loda, lodt, sto, lodb, cpyb, jmp, jpc, red, wrt,        cal, retp, endp, udis, opac, entp, ands, ors, nots, imod, mus, add,        sub, mult, idiv, eq, ne, ls, le, gt, ge, last_opcod        &#125;;  /* opration code *//*******************************//********************************Structures*******************************/typedef varying_string&lt;al&gt; alfa;/*String with length al*/typedef short index1;typedef set_of_enum(symbol) symset;struct instruction&#123;opcod f;unsigned char l;unsigned short a;&#125;;struct item&#123;types typ;int ref;&#125;;struct A1&#123;alfa name;oobject kind;types typ;unsigned char lev;boolean normal;index1 ref;index1 link;union&#123;    int adr;    int val;    int size;&#125;;&#125;;//Elements of nametabstruct A2&#123;types inxtyp, eltyp;index1 elref, low, high, elsize, size;&#125;;//Elements of atabstruct B1&#123;index1 last, lastpar, psize, vsize;&#125;;//Elements of btabstruct constrec&#123;types tp;int i;&#125;;/********************************Global variables*******************************/char ch;           /* last character read */symbol sym;        /* last symbol read*/alfa id;           /* last identifier read*/int num;       /* last number read */int cc;        /* character count */int ll;        /* line length */int kk, err;varying_string&lt;81&gt; line;alfa a;int i;array&lt;1, norw, alfa&gt; word1;array&lt;1, norw, symbol&gt; wsym;array &lt; -128, 127, symbol &gt; ssym;array&lt;0, last_opcod, varying_string&lt;5&gt; &gt; mnemonic;symset declbegsys, statbegsys, facbegsys, constbegsys, typebegsys;array&lt;0, txmax, A1&gt; nametab;/* name table */int tx;             /* index of nametab*/array&lt;1, amax, A2&gt; atab;/* array information table */int ax;             /*index of atab */array&lt;0, bmax, B1&gt; btab;/* block information table */int bx;                 /* index of btab */array&lt;0, levmax, int&gt; display;array&lt;0, cxmax, instruction&gt; code;int cx;          /* code allocation index */array&lt;0, 100, int&gt; labtab;int lx;text sfile;       /* source program file */string sfile_buff;char sfilename[_MAX_PATH]; /* source program file name */file&lt;instruction&gt; fcode;file&lt;int&gt; labfile;text listfile;string listfile_buff;char listfilename[_MAX_PATH];char dir[_MAX_DIR];char name[_MAX_FNAME];char ext[_MAX_EXT];/*********************************************************//********************************Function Decalarations*******************************/void initial();void enterpreid();void enter(alfa x0, oobject x1, types x2, int x3);void error(int n);void getch();void getsym();void enterarray (types tp , int l, int h);void enterblock();void gen(opcod x, int y, int z);void test(symset s1, symset s2, int n);void block( symset fsys, int level);void enter1( oobject k, int &amp;level);int position(alfa id, int &amp;level);void constant(symset fsys, constrec &amp;c, int &amp;level);void typ(symset fsys, types &amp;tp, int &amp;rf, int &amp;sz, int &amp;level);void arraytyp(int &amp;aref, int &amp;arsz, int &amp;level, symset &amp;fsys);void typ(symset fsys, types &amp;tp, int &amp;rf, int &amp;sz, int &amp;level);void paramenterlist(symset &amp;fsys, int &amp;level, int &amp;dx);void constdeclaration(int &amp;level, symset &amp;fsys);void typedeclaration(int &amp;level, symset &amp;fsys);void vardeclaration(int &amp;level, symset &amp;fsys, int &amp;dx);void procdeclaration(int &amp;level, symset &amp;fsys);void listcode(int &amp;cx0);void statement(symset fsys, int &amp;level);void expression(symset fsys, item &amp;x, int &amp;level);void simpleexpression(symset fsys, item &amp;x, int &amp;level);void repeatstatement(int &amp;cx1, int &amp;level, symset &amp;fsys);void term(symset fsys, item &amp;x, int &amp;level);void arrayelement(symset fsys, item &amp;x, int &amp;level);void factor(symset fsys, item &amp;x, int &amp;level);void assignment(int &amp;i, int &amp;level, symset &amp;fsys);void ifstatement(int &amp;level, symset &amp;fsys, int &amp;cx1, int &amp;cx2);void compound(symset &amp;fsys, int &amp;level);void whilestatement(int &amp;cx1, int &amp;level, symset &amp;fsys, int &amp;cx2);void stanproc(int i, int &amp;level, item &amp;x, symset &amp;fsys);void call(int &amp;level, symset &amp;fsys);void fsplit(string sfilename, string dir, string name, string ext);/*******************************/void initial()&#123;word1[ 1] = &quot;and       &quot;;word1[ 2] = &quot;array     &quot;;word1[ 3] = &quot;begin     &quot;;word1[ 4] = &quot;call      &quot;;word1[ 5] = &quot;case      &quot;;word1[ 6] = &quot;const     &quot;;word1[ 7] = &quot;do        &quot;;word1[ 8] = &quot;downto    &quot;;word1[ 9] = &quot;else      &quot;;word1[10] = &quot;end       &quot;;word1[11] = &quot;for       &quot;;word1[12] = &quot;if        &quot;;word1[13] = &quot;mod       &quot;;word1[14] = &quot;not       &quot;;word1[15] = &quot;of        &quot;;word1[16] = &quot;or        &quot;;word1[17] = &quot;procedure &quot;;word1[18] = &quot;program   &quot;;word1[19] = &quot;repeat    &quot;;word1[20] = &quot;then      &quot;;word1[21] = &quot;to        &quot;;word1[22] = &quot;type      &quot;;word1[23] = &quot;until     &quot;;word1[24] = &quot;var       &quot;;word1[25] = &quot;while     &quot;;wsym[ 1] = andsym;wsym[ 2] = arraysym;wsym[ 3] = beginsym;wsym[ 4] = callsym;wsym[ 5] = casesym;wsym[ 6] = constsym;wsym[ 7] = dosym;wsym[ 8] = downtosym;wsym[ 9] = elsesym;wsym[10] = endsym;wsym[11] = forsym;wsym[12] = ifsym;wsym[13] = modsym;wsym[14] = notsym;wsym[15] = ofsym;wsym[16] = orsym;wsym[17] = procsym;wsym[18] = programsym;wsym[19] = repeatsym;wsym[20] = thensym;wsym[21] = tosym;wsym[22] = typesym;wsym[23] = untilsym;wsym[24] = varsym;wsym[25] = whilesym;ssym[&#39;+&#39;] = plus;ssym[&#39;-&#39;] = minus;ssym[&#39;*&#39;] = times;ssym[&#39;/&#39;] = divsym;ssym[&#39;[&#39;] = lbrack;ssym[&#39;]&#39;] = rbrack;ssym[&#39;(&#39;] = lparen;ssym[&#39;)&#39;] = rparen;ssym[&#39;=&#39;] = eql;ssym[&#39;,&#39;] = comma;ssym[&#39;.&#39;] = period;ssym[&#39;&lt;&#39;] = lss;ssym[&#39;&gt;&#39;] = gtr;ssym[&#39;;&#39;] = semicolon;mnemonic[lit] = &quot;LIT  &quot;;mnemonic[lod] = &quot;LOD  &quot;;mnemonic[sto] = &quot;STO  &quot;;mnemonic[cal] = &quot;CAL  &quot;;mnemonic[jmp] = &quot;JMP  &quot;;mnemonic[jpc] = &quot;JPC  &quot;;mnemonic[red] = &quot;RED  &quot;;mnemonic[wrt] = &quot;WRT  &quot;;mnemonic[ilod] = &quot;ILOD  &quot;;mnemonic[loda] = &quot;LODA &quot;;mnemonic[lodt] = &quot;LODt  &quot;;mnemonic[lodb] = &quot;LODB &quot;;mnemonic[cpyb] = &quot;COPYB &quot;;mnemonic[endp] = &quot;ENDP &quot;;mnemonic[retp] = &quot;RETP  &quot;;mnemonic[udis] = &quot;ADIS &quot;;mnemonic[mus] = &quot;MUS  &quot;;mnemonic[add] = &quot;ADD &quot;;mnemonic[sub] = &quot;SUB  &quot;;mnemonic[mult] = &quot;MULT &quot;;mnemonic[idiv] = &quot;DDIV  &quot;;mnemonic[eq] = &quot;EQ  &quot;;mnemonic[ne] = &quot;NE &quot;;mnemonic[ls] = &quot;LS  &quot;;mnemonic[le] = &quot;LE &quot;;mnemonic[gt] = &quot;GT  &quot;;mnemonic[ge] = &quot;GE &quot;;mnemonic[opac] = &quot;OPAC &quot;;mnemonic[entp] = &quot;ENTP&quot;;mnemonic[imod] = &quot;IMOD &quot;;mnemonic[ands] = &quot;ANDS&quot;;mnemonic[ors] = &quot;ORS &quot;;mnemonic[nots] = &quot;NOTS&quot;;declbegsys = set_of_enum(symbol)::of(constsym, varsym, typesym, procsym, eos);statbegsys = set_of_enum(symbol)::of(beginsym, callsym,casesym, ifsym, whilesym,repeatsym, forsym,eos);facbegsys = set_of_enum(symbol)::of(ident, intcon, lparen, notsym, charcon, eos);typebegsys = set_of_enum(symbol)::of(ident, arraysym, eos);constbegsys = set_of_enum(symbol)::of(plus, minus, intcon, charcon, ident, eos);err = 0;a[0] = &#39;\12&#39;;// What is \12 LosPhoenixdisplay[0] = 0;cc = 0;cx = 0;ll = 0;ch = &#39; &#39;;kk = al;bx = 1;tx = -1;lx = 0;&#125;/*init*/void enter(alfa x0, oobject x1, types x2, int x3)&#123;tx = tx + 1;&#123;    nametab[tx].name = x0;    nametab[tx].link = tx - 1;    nametab[tx].kind = x1;    nametab[tx].typ = x2;    nametab[tx].ref = 0;    nametab[tx].normal = true;    nametab[tx].lev = 0;    switch (nametab[tx].kind)    &#123;    case variable:    case prosedure:        nametab[tx].adr = x3;        break;    case konstant:        nametab[tx].val = x3;        break;    case typel:        nametab[tx].size = x3;        break;    &#125;&#125;&#125;/*enter*/void enterpreid()// Only at the begining. Init nametable and btab&#123;enter(&quot;          &quot;, variable, notyp, 0);    /* sentinel */enter(&quot;char      &quot;, typel, chars, 1);enter(&quot;integer   &quot;, typel, ints,  1);enter(&quot;boolean   &quot;, typel, bool_,  1);enter(&quot;false     &quot;, konstant, bool_,  0);enter(&quot;true      &quot;, konstant, bool_,  1);enter(&quot;read      &quot;, prosedure, notyp, 1);enter(&quot;write     &quot;, prosedure, notyp, 2);btab[0].last = tx;btab[0].lastpar = 1;btab[0].psize = 0;btab[0].vsize = 0;&#125;/*enterprid*/void error(int n)&#123;listfile &lt;&lt; &quot;****&quot; &lt;&lt; format(&#39; &#39;, cc - 1) &lt;&lt; &#39;^&#39; &lt;&lt; format(n, 2) &lt;&lt; NL;err = err + 1;output &lt;&lt; &quot;Error&quot; &lt;&lt; n &lt;&lt; NL;&#125;/* error */void getch()&#123;if (cc == ll)   /* get character to end of line *//* read next line */&#123;    if (eof(sfile))    &#123;        output &lt;&lt; &quot;program incomplete&quot; &lt;&lt; NL;        close(sfile);        return;    &#125;    ll = 0;    cc = 0;    listfile &lt;&lt; format(cx, 4) &lt;&lt; &#39; &#39;;   /*print code address */    while (! eoln(sfile))    &#123;        ll = ll + 1;        sfile &gt;&gt; ch;        listfile &lt;&lt; ch;        line[ll] = ch;    &#125;    listfile &lt;&lt; NL;    sfile &gt;&gt; NL;    ll = ll + 1;    line[ll] = &#39; &#39;; /*process end-line*/&#125;cc = cc + 1;ch = line[cc];//output &lt;&lt; ch;//test&#125;/* getch */void getsym()/*getsym*/&#123;int i, k, j;/*Why is there a goto in this code. LosPhoenix*/L1:while (ch == &#39; &#39;)    getch();switch (ch)&#123;case &#39;a&#39;:case &#39;b&#39;:case &#39;c&#39;:case &#39;d&#39;:case &#39;e&#39;:case &#39;f&#39;:case &#39;g&#39;:case &#39;h&#39;:case &#39;i&#39;:case &#39;j&#39;:case &#39;k&#39;:case &#39;l&#39;:case &#39;m&#39;:case &#39;n&#39;:case &#39;o&#39;:case &#39;p&#39;:case &#39;q&#39;:case &#39;r&#39;:case &#39;s&#39;:case &#39;t&#39;:case &#39;u&#39;:case &#39;v&#39;:case &#39;w&#39;:case &#39;x&#39;:case &#39;y&#39;:case &#39;z&#39;:&#123;    /* identifier or reserved word */    k = 0;    do    &#123;        if (k &lt; al)        &#123;            k = k + 1;            a[k] = ch;        &#125;        getch();    &#125;    while ((set::of(range(&#39;a&#39;, &#39;z&#39;), range(&#39;0&#39;, &#39;9&#39;), eos).has(ch)));    if (k &gt;= kk)            kk = k;    /* kk: last identifier length */    else        do        &#123;            a[kk] = &#39; &#39;;            kk = kk - 1;        &#125;        while (!(kk == k));    id = a;    i = 1;    j = norw;  /* binary search reserved word table */    do    &#123;        k = (i + j) / 2;        if (id &lt;= word1[k])  j = k - 1;        if (id &gt;= word1[k])  i = k + 1;    &#125;    while (!(i &gt; j));    if (i - 1 &gt; j)            sym = wsym[k];    else            sym = ident;&#125;break;case &#39;0&#39;:case &#39;1&#39;:case &#39;2&#39;:case &#39;3&#39;:case &#39;4&#39;:case &#39;5&#39;:case &#39;6&#39;:case &#39;7&#39;:case &#39;8&#39;:case &#39;9&#39;:&#123;    /* number */    k = 0;    num = 0;    sym = intcon;    do    &#123;        num = 10 * num + (ch - &#39;0&#39;);        k = k + 1;        getch();    &#125;    while ((set::of(range(&#39;0&#39;, &#39;9&#39;), eos).has(ch)));    if (k &gt; nmax)  error(47);&#125;break;case &#39;:&#39;:&#123;    getch();    if (ch == &#39;=&#39;)    &#123;        sym = becomes;        getch();    &#125;    else sym = colon;&#125;break;case &#39;&lt;&#39; :&#123;    getch();    if (ch == &#39;=&#39;)    &#123;        sym = leq;        getch();    &#125;    else if (ch == &#39;&gt;&#39;)    &#123;        sym = neq;        getch();    &#125;    else sym = lss;&#125;break;case &#39;&gt;&#39; :&#123;    getch();    if (ch == &#39;=&#39;)    &#123;        sym = geq;        getch();    &#125;    else sym = gtr;&#125;break;case &#39;.&#39; :&#123;    getch();    if (ch == &#39;.&#39;)    &#123;        sym = colon;        getch();    &#125;    else   sym = period;&#125;break;case &#39;\&#39;&#39;  :&#123;    getch();    sym = charcon;    num = ch;    getch();    if (ch == &#39;\&#39;&#39;)  getch();    else error(48);&#125;break;case &#39;+&#39;:case &#39;-&#39;:case &#39;*&#39;:case &#39;/&#39;:case &#39;(&#39;:case &#39;)&#39;:case &#39;=&#39;:case &#39;[&#39;:case &#39;]&#39;:case &#39;;&#39;:case &#39;,&#39;:&#123;    sym = ssym[ch];    getch();&#125;break;default:&#123;    error(0);    getch();    goto L1;&#125;&#125;    /* case *///output&lt;&lt;sym&lt;&lt;NL;&#125;/* getsym */void enterarray (types tp , int l, int h)&#123;if (l &gt; h)  error(14);if (ax == amax)&#123;    error(2);    output &lt;&lt; &quot;too many arrays in program &quot; &lt;&lt; NL;    close(sfile);    close(listfile);    return;&#125;else&#123;    ax = ax + 1;    &#123;        //A2 &amp;with = atab[ax];        atab[tx].inxtyp = tp;        atab[tx].low = l;        atab[tx].high = h;    &#125;&#125;&#125;/* enterarray */void enterblock()&#123;if (bx == bmax)&#123;    error(3);    output &lt;&lt; &quot;too many procedure in program &quot; &lt;&lt; NL;    close(sfile);    close(listfile);    return;&#125;else&#123;    bx = bx + 1;    btab[bx].last = 0;    btab[bx].lastpar = 0;&#125;&#125;/* enterblock */void gen(opcod x, int y, int z)&#123;if (cx &gt; cxmax)&#123;    error(49);    output &lt;&lt; &quot;program too long&quot; &lt;&lt; NL;    close(sfile);    close(listfile);    return;&#125;&#123;    //instruction &amp;with = code[cx];    code[cx].f = x;    code[cx].l = y;    code[cx].a = z;&#125;cx = cx + 1;&#125;/* gen */void test(symset s1, symset s2, int n)&#123;if (! (s1.has(sym)))&#123;    error(n);    s1 = s1 + s2;    while (! (s1.has(sym)))        getsym();&#125;&#125;/* test */void enter1( oobject k, int &amp;level)&#123;int j, l;if (tx == txmax)&#123;    error(1);    output &lt;&lt; &quot;program too long&quot; &lt;&lt; NL;    close(sfile);    close(listfile);    return;&#125;else&#123;    nametab[0].name = id;    j = btab[display[level]].last;    l = j;    while (nametab[j].name != id)  j = nametab[j].link;    if (j != 0)        error(l);    else    &#123;        tx = tx + 1;        &#123;            //A1 &amp;with = nametab[tx];            nametab[tx].name = id;            nametab[tx].link = l;            nametab[tx].kind = k;            nametab[tx].typ = notyp;            nametab[tx].ref = 0;            nametab[tx].lev = level;            nametab[tx].normal = false;            switch (nametab[tx].kind)            &#123;            case variable:            case prosedure:                nametab[tx].adr = 0;                break;            case konstant:                nametab[tx].val = 0;                break;            case typel:                nametab[tx].size = 0;                break;            &#125;    /* initial value */        &#125;        btab[display[level]].last = tx;    &#125;&#125;&#125;/* enter */int position(alfa id, int &amp;level)&#123;int i, j;int position_result;nametab[0].name = id;j = level;do&#123;    i = btab[display[j]].last;    while (nametab[i].name != id)        i = nametab[i].link;    j = j - 1;&#125;while (!((j &lt; 0) || (i != 0)));if (i == 0)  error(10);position_result = i;return position_result;&#125;/* position */void constant(symset fsys, constrec &amp;c, int &amp;level)&#123;int x, sign;c.tp = notyp;c.i = 0;test(constbegsys, fsys, 50);if (constbegsys.has(sym))&#123;    if   (sym == charcon)    &#123;        c.tp = chars;        c.i = num;        getsym();    &#125;    else    &#123;        sign = 1;        if (set_of_enum(symbol)::of(plus, minus, eos).has(sym))        &#123;            if (sym == minus)  sign = -1;            getsym();        &#125;        if (sym == ident)        &#123;            x = position(id, level);            if (x != 0)&#123;                if (nametab[x].kind != konstant)                    error(12);                else                &#123;                    c.tp = nametab[x].typ;                    c.i = sign * nametab[x].val;                &#125;            &#125;            getsym();        &#125;        else if (sym == intcon)        &#123;            c.tp = ints;            c.i = sign * num;            getsym();        &#125;    &#125;    test(fsys, set_of_enum(symbol)::of(eos), 6);&#125;&#125;/* constant */void arraytyp(int &amp;aref, int &amp;arsz, int &amp;level, symset &amp;fsys)&#123;types eltp;constrec low, high;int elrf, elsz;constant(set_of_enum(symbol)::of(colon, rbrack, rparen, ofsym, eos) + fsys, low, level);if ((low.tp != ints)  &amp;&amp; (low.tp != chars))    error(50);if (sym == colon)  getsym();else error(38);constant(set_of_enum(symbol)::of(rbrack, comma, rparen, ofsym, eos) + fsys, high, level);if (high.tp != low.tp)&#123;    error(40);    high.i = low.i;&#125;enterarray(low.tp, low.i, high.i);aref = ax;if (sym == comma)&#123;    getsym();    eltp = arrays;    arraytyp(elrf, elsz, level, fsys);&#125;else&#123;    if (sym == rbrack)        getsym();    else    &#123;        error(28);        if (sym == rparen)  getsym();    &#125;    if (sym == ofsym)  getsym();    else error(17);    typ(fsys, eltp, elrf, elsz, level);&#125;&#123;    //A2 &amp;with = atab[aref];    arsz = (atab[aref].high - atab[aref].low + 1) * elsz;    atab[aref].size = arsz;    atab[aref].eltyp = eltp;    atab[aref].elref = elrf;    atab[aref].elsize = elsz;&#125;&#125;/* arraytyp */void typ(symset fsys, types &amp;tp, int &amp;rf, int &amp;sz, int &amp;level)&#123;types eltp;int elrf, x;int elsz, offset, t0, t1;/* typ */tp = notyp;rf = 0;sz = 0;test(typebegsys, fsys, 10);if (typebegsys.has(sym))&#123;    if (sym == ident)    &#123;        x = position(id, level);        if (x != 0)        &#123;            //A1 &amp;with = nametab[x];            if (nametab[x].kind != typel)                error(19);            else            &#123;                tp = nametab[x].typ;                rf = nametab[x].ref;                sz = nametab[x].size;                if (tp == notyp)  error(18);            &#125;        &#125;        getsym();    &#125;    else if (sym == arraysym)    &#123;        getsym();        if (sym == lbrack)            getsym();        else        &#123;            error(16);            if (sym == lparen)                getsym();        &#125;        tp = arrays;        arraytyp(rf, sz, level, fsys);    &#125;    test(fsys, set_of_enum(symbol)::of(eos), 13);&#125;&#125;/*typ*/void paramenterlist(symset &amp;fsys, int &amp;level, int &amp;dx)   /*formal parameter list*/&#123;types tp;boolean valpar;int rf, sz, x, t0;getsym();tp = notyp;rf = 0;sz = 0;test(set_of_enum(symbol)::of(ident, varsym, eos), fsys + set_of_enum(symbol)::of(rparen, eos), 7);while (set_of_enum(symbol)::of(ident, varsym, eos).has(sym))&#123;    if (sym != varsym)        valpar = true;    else    &#123;        getsym();        valpar = false;    &#125;    t0 = tx;    if (sym == ident)    &#123;        enter1(variable, level);        getsym();    &#125;    else error(22);    while (sym == comma)    &#123;        getsym();        if (sym == ident)        &#123;            enter1(variable, level);            getsym();        &#125;        else error(22);    &#125;    if (sym == colon)    &#123;        getsym();        if (sym != ident)            error(22);        else        &#123;            x = position(id, level);            getsym();            if (x != 0)            &#123;                //A1 &amp;with = nametab[x];                if (nametab[x].kind != typel)                    error(19);                else                &#123;                    tp = nametab[x].typ;                    rf = nametab[x].ref;                    if (valpar)  sz = nametab[x].size;                    else sz = 1;                &#125;            &#125;        &#125;        test (set_of_enum(symbol)::of(semicolon, rparen, eos), set_of_enum(symbol)::of(comma, ident, eos) + fsys, 14);    &#125;    else error(24);    while (t0 &lt; tx)    &#123;        t0 = t0 + 1;        &#123;            //A1 &amp;with = nametab[t0];            nametab[t0].typ = tp;            nametab[t0].ref = rf;            nametab[t0].adr = dx;            nametab[t0].lev = level;            nametab[t0].normal = valpar;            dx = dx + sz;        &#125;    &#125;    if (sym != rparen)    &#123;        if (sym == semicolon)            getsym();        else        &#123;            error(23);            if (sym == comma)  getsym();        &#125;        test(set_of_enum(symbol)::of(ident, varsym, eos), set_of_enum(symbol)::of(rparen, eos) + fsys, 13);    &#125;&#125;   /*while*/if (sym == rparen)&#123;    getsym();    test(set_of_enum(symbol)::of(semicolon, eos), fsys, 13);&#125;else error(25);&#125;/*parameterlist*/void constdeclaration(int &amp;level, symset &amp;fsys)&#123;constrec c;if (sym == ident)&#123;    enter1(konstant, level);    getsym();    if (sym == eql)        getsym();    else    &#123;        error(26);        if (sym == becomes)  getsym();    &#125;    constant(set_of_enum(symbol)::of(semicolon, comma, ident, eos) + fsys, c, level);    nametab[tx].typ = c.tp;    nametab[tx].ref = 0;    nametab[tx].val = c.i;    if (sym == semicolon)  getsym();    else error(23);&#125;else error(22);test(fsys + set_of_enum(symbol)::of(ident, eos), set_of_enum(symbol)::of(eos), 13);&#125;/* constdeclaration */void typedeclaration(int &amp;level, symset &amp;fsys)&#123;types tp;int rf, sz, t1;if (sym == ident)&#123;    enter1(typel, level);    t1 = tx;    getsym();    if (sym == eql)            getsym();    else    &#123;        error(26);        if (sym == becomes)                getsym();    &#125;    typ (set_of_enum(symbol)::of(semicolon, comma, ident, eos) + fsys, tp, rf, sz, level);    nametab[tx].typ = tp;    nametab[tx].ref = rf;    nametab[tx].size = sz;    if (sym == semicolon)  getsym();    else error(23);&#125;else error(22);test(fsys + set_of_enum(symbol)::of(ident, eos), set_of_enum(symbol)::of(eos), 13);&#125;/* typedeclaration */void vardeclaration(int &amp;level, symset &amp;fsys, int &amp;dx)&#123;types tp;int t0, t1, rf, sz;if (sym == ident)&#123;    t0 = tx;    enter1(variable, level);    getsym();    while (sym == comma)    &#123;        getsym();        if (sym == ident)        &#123;            enter1(variable, level);            getsym();        &#125;        else error(22);    &#125;    if (sym == colon)            getsym();    else error(24);    t1 = tx;    typ (set_of_enum(symbol)::of(semicolon, comma, ident, eos) + fsys, tp, rf, sz, level);    while (t0 &lt; t1)    &#123;        t0 = t0 + 1;        &#123;            //A1 &amp;with = nametab[t0];            nametab[t0].typ = tp;            nametab[t0].ref = rf;            nametab[t0].lev = level;            nametab[t0].adr = dx;            nametab[t0].normal = true;            dx = dx + sz;        &#125;    &#125;    if (sym == semicolon)            getsym();    else error(23);&#125;else error(22);test(fsys + set_of_enum(symbol)::of(ident, eos), set_of_enum(symbol)::of(eos), 13);&#125;/* vardeclaration */void procdeclaration(int &amp;level, symset &amp;fsys)&#123;getsym();if (sym != ident)&#123;    error(22);    id = &#39; &#39;;&#125;enter1(prosedure, level);nametab[tx].normal = true;getsym();block(set_of_enum(symbol)::of(semicolon, eos) + fsys, level + 1);if (sym == semicolon)        getsym();else error(23);&#125;/*procdeclaration*/void listcode(int &amp;cx0)&#123;int i;for( i = cx0; i &lt;= cx - 1; i ++)&#123;    //instruction &amp;with = code[i];    listfile &lt;&lt; format(i, 4) &lt;&lt; format(mnemonic[code[i].f], 7) &lt;&lt; format(code[i].l, 3) &lt;&lt; format(code[i].a, 5) &lt;&lt; NL;&#125;&#125;/* listcode */void factor(symset fsys, item &amp;x, int &amp;level)&#123;int i;x.typ = notyp;x.ref = 0;test(facbegsys, fsys, 13);if (facbegsys.has(sym))&#123;    switch (sym)    &#123;    case ident :    &#123;        i = position(id, level);        getsym();        if (i == 0)  error(10);        else        &#123;            //A1 &amp;with = nametab[i];            switch (nametab[i].kind)            &#123;            case konstant:            &#123;                x.typ = nametab[i].typ;                x.ref = 0;                gen(lit, 0, nametab[i].val);            &#125;            break;            case variable:            &#123;                x.typ = nametab[i].typ;                x.ref = nametab[i].ref;                if ((nametab[i].typ == ints) || (nametab[i].typ == bool_) || (nametab[i].typ == chars))                    if (nametab[i].normal)   gen(lod, nametab[i].lev, nametab[i].adr);                    else gen(ilod, nametab[i].lev, nametab[i].adr);                else  if (nametab[i].typ == arrays)                &#123;                    if (nametab[i].normal)  gen(loda, nametab[i].lev, nametab[i].adr);                    else gen(lod, nametab[i].lev, nametab[i].adr);                    if (sym == lbrack)                        arrayelement(fsys, x, level); //LosPhoenix tocheck                    if (x.typ != arrays)                        gen(lodt, 0, 0);                &#125;            &#125;            break;            case prosedure:            case typel:                error(41);                break;            &#125;        &#125;    &#125;    break;    case intcon:    case charcon :    &#123;        if (sym == intcon)  x.typ = ints;        else x.typ = chars;        x.ref = 0;        gen(lit, 0, num);        getsym();    &#125;    break;    case lparen :    &#123;        getsym();        expression(set_of_enum(symbol)::of(rparen, eos) + fsys, x, level);        if (sym == rparen)  getsym();        else error(25);    &#125;    break;    case notsym :    &#123;        getsym();        factor(fsys, x, level);        if (x.typ == bool_)            gen(nots , 0, 0);        else error(43);    &#125;    break;    &#125;    /* case */    test(fsys + set_of_enum(symbol)::of(rbrack, rparen,tosym,downtosym, eos), facbegsys, 23);&#125;    /* of if */&#125;/* factor */void term(symset fsys, item &amp;x, int &amp;level)&#123;symbol mulop;item y;/* term */factor(fsys + set_of_enum(symbol)::of(times, divsym, modsym, andsym, eos), x, level);while (set_of_enum(symbol)::of(times, divsym, modsym, andsym, eos).has(sym))&#123;    mulop = sym;    getsym();    factor(fsys + set_of_enum(symbol)::of(times, divsym, modsym, andsym, eos), y, level);    if (x.typ != y.typ)    &#123;        error(40);        x.typ = notyp;        x.ref = 0;    &#125;    else    &#123;        if (mulop == times)            if (x.typ == ints)                gen(mult, 0, 0);            else error(43);        if  (mulop == divsym)            if (x.typ == ints)                gen(idiv, 0, 0);            else error(43);        if  (mulop == modsym)            if (x.typ == ints)                gen(imod, 0, 0);            else error(43);        if  (mulop == andsym)            if (x.typ == bool_)                gen(ands, 0, 0);            else error(43);    &#125;&#125;&#125;/* term*/void simpleexpression(symset fsys, item &amp;x, int &amp;level)&#123;symbol addop;item y;/* simpleexpression */if (set_of_enum(symbol)::of(plus, minus, eos).has(sym))&#123;    addop = sym;    getsym();    term(fsys + set_of_enum(symbol)::of(plus, minus, orsym, eos), x, level);    if (addop == minus)  gen(mus, 0, 0);&#125;else&#123;    term(fsys + set_of_enum(symbol)::of(plus, minus, orsym, eos), x, level);&#125;while (set_of_enum(symbol)::of(plus, minus, orsym, eos).has(sym))&#123;    addop = sym;    getsym();    term(fsys + set_of_enum(symbol)::of(plus, minus, orsym, eos), y, level);    if (x.typ != y.typ)    &#123;        error(40);        x.typ = notyp;        x.ref = 0;    &#125;    else    &#123;        if (addop == plus)            if (x.typ == ints)                gen(add, 0, 0);            else error(43);        if  (addop == minus)            if (x.typ == ints)                gen(sub, 0, 0);            else error(43);        if  (addop == orsym)            if (x.typ == bool_)                gen(ors, 0, 0);            else error(43);    &#125;&#125;&#125;/* simpleexpression */void expression(symset fsys, item &amp;x, int &amp;level)&#123;symbol relop;item y;/*expression*/simpleexpression(set_of_enum(symbol)::of(eql, neq, lss, gtr, leq, geq, eos) + fsys, x, level);while (set_of_enum(symbol)::of(eql, neq, lss, leq, gtr, geq, eos).has(sym))&#123;    relop = sym;    getsym();    simpleexpression(fsys, y, level);    if (x.typ != y.typ)        error(40);    switch (relop)    &#123;    case eql:        gen(eq, 0, 0);        break;    case neq:        gen(ne, 0, 0);        break;    case lss:        gen(ls, 0, 0);        break;    case geq:        gen(ge, 0, 0);        break;    case gtr:        gen(gt, 0, 0);        break;    case leq:        gen(le, 0, 0);        break;    &#125;    x.typ = bool_;&#125;&#125;/* expression */void forstatement(symset fsys, int &amp;level, int &amp;cx1, int &amp;cx2)&#123;item x;int i;int downto = 0;getsym();assignment(i,level,fsys);int addr = nametab[i].adr;if(addr == 0) error(0);if(sym == tosym)&#123;    getsym();&#125;else if(sym==downtosym)&#123;    getsym();    downto = 1;&#125;else&#123;    error(37);&#125;cx1 = cx;simpleexpression(set_of_enum(symbol)::of(dosym,eos)+fsys,x,level);gen(lod,level,addr);if(downto)&#123;    gen(le,0,0);&#125;else&#123;    gen(ge,0,0);&#125;cx2 = cx;gen(jpc,0,0);if(sym==dosym)&#123;    getsym();&#125;else&#123;    error(0);&#125;statement(fsys,level);gen(loda,level,addr);gen(lod,level,addr);gen(lit,0,1);if(downto)&#123;    gen(sub,0,0);&#125;else&#123;    gen(add,0,0);&#125;gen(sto,0,0);gen(jmp,0,cx1);code[cx2].a = cx;&#125;void arrayelement(symset fsys, item &amp;x, int &amp;level)&#123;int cc;index1 addr, p;item y;p = x.ref;if (sym == lbrack)&#123;    do    &#123;        getsym();        expression(fsys + set_of_enum(symbol)::of(comma, eos), y, level);        if (x.typ != arrays)  error(40);        else        &#123;            if (y.typ != atab[p].inxtyp)  error(44);            gen(lit, 0, atab[p].low);            gen(sub, 0, 0);            gen(lit, 1, atab[p].elsize);            gen(mult, 0, 0);            gen(add, 0, 0);            x.typ = atab[p].eltyp;            x.ref = atab[p].elref;            p = atab[p].elref;        &#125;    &#125;    while (!(sym != comma));    if (sym == rbrack)  getsym();    else error(28);&#125;else error(16);test(fsys, set_of_enum(symbol)::of(eos), 13);&#125;/*arrayelement*/void assignment(int &amp;i, int &amp;level, symset &amp;fsys)&#123;item x, y;i = position(id, level);if (i == 0)  error(10);else if (nametab[i].kind != variable)&#123;    /* giving value to non-variation */    error(30);    i = 0;&#125;getsym();x.typ = nametab[i].typ;x.ref = nametab[i].ref;&#123;    A1 &amp;with = nametab[i];    if (with.normal)        gen(loda, with.lev, with.adr);    else gen(lod, with.lev, with.adr);&#125;if (sym == lbrack)    arrayelement(fsys + set_of_enum(symbol)::of(becomes, eos), x, level);if (sym == becomes)  getsym();else&#123;    error(33);    if (sym == eql)  getsym();&#125;expression(fsys, y, level);if (x.typ != y.typ)  error(40);else if (x.typ == arrays)    if (x.ref == y.ref)        gen(cpyb, 0, atab[x.ref].size);    else error(40);else gen(sto, 0, 0);&#125;/*assignment*/void ifstatement(int &amp;level, symset &amp;fsys, int &amp;cx1, int &amp;cx2)&#123;item x;getsym();expression(set_of_enum(symbol)::of(thensym, dosym, eos) + fsys, x, level);if (x.typ != bool_)  error(34);if (sym == thensym)  getsym();else error(35);cx1 = cx;gen(jpc, 0, 0);statement(fsys + set_of_enum(symbol)::of(elsesym, eos), level);if (sym == elsesym)&#123;    getsym();    cx2 = cx;    gen(jmp, 0, 0);    code[cx1].a = cx;    labtab[lx] = cx;    lx = lx + 1;    statement(fsys, level);    code[cx2].a = cx;    labtab[lx] = cx;    lx = lx + 1;&#125;else&#123;    code[cx1].a = cx;    labtab[lx] = cx;    lx = lx + 1;&#125;&#125;/*ifstatement*/void compound(symset &amp;fsys, int &amp;level)&#123;getsym();statement(set_of_enum(symbol)::of(semicolon, endsym, eos) + fsys, level);while ((set_of_enum(symbol)::of(semicolon, eos) + statbegsys).has(sym))&#123;    if (sym == semicolon)  getsym();    else error(23);    statement(set_of_enum(symbol)::of(semicolon, endsym, eos) + fsys, level);&#125;if (sym == endsym)    getsym();else error(36);&#125;/*compound*/void repeatstatement(int &amp;cx1, int &amp;level, symset &amp;fsys)&#123;item x;getsym();cx1 = cx;statement(set_of_enum(symbol)::of(untilsym,eos) + fsys, level);while(sym!=untilsym)&#123;    getsym();    statement(set_of_enum(symbol)::of(untilsym,eos) + fsys, level);&#125;getsym();expression(fsys,x,level);if(x.typ!=bool_)error(34);gen(jpc,0,cx1);gen(jmp,0,cx+1);&#125;void whilestatement(int &amp;cx1, int &amp;level, symset &amp;fsys, int &amp;cx2)&#123;item x;getsym();labtab[lx] = cx;lx = lx + 1;cx1 = cx;expression(set_of_enum(symbol)::of(dosym, eos) + fsys, x, level);if (x.typ != bool_)  error(34);cx2 = cx;gen(jpc, 0, 0);if (sym == dosym)  getsym();else error(37);statement(fsys, level);gen(jmp, 0, cx1);code[cx2].a = cx;labtab[lx] = cx;lx = lx + 1;&#125;/*whilestatement*/void stanproc(int i, int &amp;level, item &amp;x, symset &amp;fsys)&#123;int n;if (i == 6)&#123;    /* read */    getsym();    if (sym == lparen)    &#123;        do        &#123;            getsym();            if (sym == ident)            &#123;                n = position(id, level);                getsym();                if (n == 0)  error(10);                else if (nametab[n].kind != variable)                &#123;                    error(30);                    n = 0;                &#125;                else                &#123;                    x.typ = nametab[n].typ;                    x.ref = nametab[n].ref;                    if (nametab[n].normal)                        gen(loda, nametab[n].lev, nametab[n].adr);                    else gen(lod, nametab[n].lev, nametab[n].adr);                    if (sym == lbrack)                        arrayelement(fsys + set_of_enum(symbol)::of(comma, eos), x, level);                    if (x.typ == ints)                        gen(red, 0, 0);                    else if (x.typ == chars)                        gen(red, 0, 1);                    else error(43);                &#125;            &#125;            else error(22);        &#125;        while (!(sym != comma));        if (sym != rparen)  error(25);        else  getsym();    &#125;    else error(32);&#125;else if (i == 7)&#123;    /* write */    getsym();    if (sym == lparen)    &#123;        do        &#123;            getsym();            expression(set_of_enum(symbol)::of(rparen, comma, eos) + fsys, x, level);            if (x.typ == ints)                gen(wrt, 0, 0);            else if (x.typ == chars)                gen(wrt, 0, 1);            else error(43);        &#125;        while (!(sym != comma));        if (sym != rparen)  error(25);        getsym();    &#125;    else error(32);&#125;&#125;/* standproc */void call(int &amp;level, symset &amp;fsys)&#123;item x;int lastp, cp, i, j, k;/* call */getsym();if (sym == ident)&#123;    i = position(id, level);    if (nametab[i].kind == prosedure)    &#123;        if (nametab[i].lev == 0)  stanproc(i, level, x, fsys);        else        &#123;            getsym();            gen(opac, 0, 0); /*open active record*/            lastp = btab[nametab[i].ref].lastpar;            cp = i;            if (sym == lparen)            &#123;                /*actual parameter list*/                do                &#123;                    getsym();                    if (cp &gt;= lastp)                        error(29);                    else                    &#123;                        cp = cp + 1;                        if (nametab[cp].normal)                        &#123;                            /*value parameter*/                            expression(fsys + set_of_enum(symbol)::of(comma, colon, rparen, eos), x, level);                            if (x.typ == nametab[cp].typ)                            &#123;                                if (x.ref != nametab[cp].ref)                                    error(31);                                else if (x.typ == arrays)                                    gen(lodb, 0, atab[x.ref].size);                            &#125;                            else error(31);                        &#125;                        else           /*variable parameter*/                        &#123;                            if (sym != ident)                                error(22);                            else                            &#123;                                k = position(id, level);                                getsym();                                if (k != 0)                                &#123;                                    if (nametab[k].kind != variable)  error (30);                                    x.typ = nametab[k].typ;                                    x.ref = nametab[k].ref;                                    if (nametab[k].normal)                                        gen(loda, nametab[k].lev, nametab[k].adr);                                    else gen(lod, nametab[k].lev, nametab[k].adr);                                    if (sym == lbrack)                                        arrayelement(fsys + set_of_enum(symbol)::of(comma, rparen, eos), x, level);                                    if    ((nametab[cp].typ != x.typ)                                            || (nametab[cp].ref != x.ref))                                        error(31);                                &#125;                            &#125;                        &#125;   /*variable parameter*/                    &#125;                    test(set_of_enum(symbol)::of(comma, rparen, eos), fsys, 13);                &#125;                while (!(sym != comma));                if (sym == rparen)  getsym();                else error(25);            &#125;            if (cp &lt; lastp)  error(39);  /*too few actual parameters*/            gen(cal, nametab[i].lev, nametab[i].adr);            if (nametab[i].lev &lt; level)  gen(udis, nametab[i].lev, level);        &#125;    &#125;    else error(51);&#125;else error(22);test(fsys + set_of_enum(symbol)::of(ident, eos), set_of_enum(symbol)::of(eos), 13);&#125; /*call*/void fsplit(const char sfilename[], char* dir, char* name, char* ext)&#123;//Todo LosPhoenix/*char path_buffer = sfilename.get_body();char drive[_MAX_DRIVE];char dir[_MAX_DIR];char fname[_MAX_FNAME];char ext[_MAX_EXT];*/char drive[_MAX_DRIVE];char dir_temp[_MAX_DIR];_splitpath(sfilename, drive, dir_temp, name, ext);_makepath( dir, drive, dir_temp, &quot;&quot;, &quot;&quot;);&#125;void casestatement(symset fsys, int&amp; level, int &amp;cx1, int &amp;cx2)&#123;int backpatch[256];int jmpindex = 0;item x;getsym();int i = position(id,level);gen(loda,level,nametab[i].adr);simpleexpression(set_of_enum(symbol)::of(ofsym,eos)+fsys,x,level);gen(sto,0,0);if(sym!=ofsym)&#123;    error(17);&#125;getsym();do&#123;    cx1 = cx;    constrec c;    constant(set_of_enum(symbol)::of(colon,comma,eos)+fsys,c,level);    gen(lod,level,nametab[i].adr);    gen(lit,0,c.i);    gen(eq,0,0);    gen(jpc,0,0);    gen(jmp,0,0);    while (sym==comma)    &#123;        getsym();        constant(set_of_enum(symbol)::of(colon,comma,eos)+fsys,c,level);        gen(lit,0,c.i);        gen(eq,0,0);        gen(jpc,0,0);        gen(jmp,0,0);    &#125;    if(sym!=colon)    &#123;        error(24);        break;    &#125;    getsym();    for(int tmp = cx1;tmp&lt;cx;tmp++)    &#123;        if(code[tmp].f==jmp)        &#123;            code[tmp].a = cx;        &#125;    &#125;    statement(fsys,level);    if(sym!=semicolon)    &#123;        if(sym!=endsym)        &#123;            error(36);        &#125;        break;    &#125;    for(int tmp = cx1;tmp&lt;cx;tmp++)    &#123;        if(code[tmp].f==jpc)        &#123;            code[tmp].a = cx+1;        &#125;    &#125;    gen(jmp,0,0);    backpatch[jmpindex++] = cx-1;    getsym();&#125;while (1);for(int tmp = cx1;tmp&lt;cx;tmp++)&#123;    if(code[tmp].f==jpc)    &#123;            code[tmp].a = cx;    &#125;&#125;for(int i = 0;i&lt;jmpindex;i++)&#123;    code[backpatch[i]].a = cx;&#125;getsym();&#125;void statement(symset fsys, int &amp;level)&#123;int i, cx1, cx2, cx3;item x;void arrayelement(symset fsys, item &amp; x);/* statement */test(statbegsys + set_of_enum(symbol)::of(ident, eos), fsys, 13);if (sym == ident)   assignment(i, level, fsys);else if (sym == callsym)    call(level, fsys);else if (sym == ifsym)    ifstatement(level, fsys, cx1, cx2);else if (sym == beginsym)    compound(fsys, level);else if (sym == whilesym)    whilestatement(cx1, level, fsys, cx2);else if (sym == repeatsym)    repeatstatement(cx1,level,fsys);else if (sym == forsym)    forstatement(fsys,level,cx1,cx2);else if (sym == casesym)    casestatement(fsys,level,cx1,cx2);test(fsys + set_of_enum(symbol)::of(elsesym,eos), set_of_enum(symbol)::of(eos), 13);&#125;/* statement */void block( symset fsys, int level)&#123;int dx;  /* data allocation index */int tx0; /* initial table index */int cx0; /* initial code  index */int prt, prb;/* block */prt = tx;dx = 3;tx0 = tx;nametab[tx].adr = cx;if (level &gt; levmax)  error(4);enterblock();prb = bx;display[level] = bx;nametab[prt].typ = notyp;nametab[prt].ref = prb;if((sym == lparen) &amp;&amp; (level &gt; 1))&#123;    paramenterlist(fsys, level, dx);    if (sym == semicolon)  getsym();    else error(23);&#125;else  if (level &gt; 1)    if (sym == semicolon)  getsym();    else error(23);btab[prb].lastpar = tx;btab[prb].psize = dx;gen(jmp, 0, 0); /* jump from declaration part to statement part */do&#123;    if (sym == constsym)    &#123;        getsym();        do        &#123;            constdeclaration(level, fsys);        &#125;        while (!(sym != ident));    &#125;    if (sym == typesym)    &#123;        getsym();        do        &#123;            typedeclaration(level, fsys);        &#125;        while (!(sym != ident));    &#125;    if (sym == varsym)    &#123;        getsym();        do        &#123;            vardeclaration(level, fsys, dx);        &#125;        while (!(sym != ident));    &#125;    while (sym == procsym)    procdeclaration(level, fsys);    test(statbegsys + set_of_enum(symbol)::of(ident, eos), declbegsys, 13);&#125;while (!(! (declbegsys.has(sym))));code[nametab[tx0].adr].a = cx; /*back enter statement code&#39;s start adr. */labtab[lx] = cx;lx = lx + 1;&#123;    //A1 &amp;with = nametab[tx0];    nametab[tx0].adr = cx; /*code&#39;s start address */&#125;cx0 = cx;gen(entp, level, dx); /* block entry */statement(set_of_enum(symbol)::of(semicolon, endsym, eos) + fsys, level);if (level &gt; 1)  gen(retp, 0, 0); /*return*/else gen(endp, 0, 0); /* end prograam */test(fsys, set_of_enum(symbol)::of(eos), 13);listcode(cx0);&#125;/* block *//************************************************************************/int main(int argc, const char *argv[])&#123;/* main */pio_initialize(argc, argv);output &lt;&lt; &quot;Please input source program file name:&quot; &lt;&lt; NL;input &gt;&gt; sfile_buff &gt;&gt; NL;strcpy(sfilename, sfile_buff.get_body());output &lt;&lt; sfilename &lt;&lt; NL;assign(sfile, sfilename);reset(sfile);fsplit(sfilename, dir, name, ext);listfile_buff = strcat(dir, strcat(name, &quot;c.lst&quot;));assign(listfile, listfile_buff);rewrite(listfile);fsplit(sfilename, dir, name, ext);    assign(fcode, strcat(dir, strcat(name , &quot;c.pld&quot;)));    rewrite(fcode);fsplit(sfilename, dir, name, ext);    assign(labfile, strcat(dir, strcat(name ,&quot;c.lab&quot;)));    rewrite(labfile);initial();enterpreid();getsym();if (sym == programsym)&#123;    getsym();    if (sym == ident)    &#123;        getsym();        if (sym == semicolon)  getsym();        else error(23);    &#125;    else error(22);&#125;else error(15);test(declbegsys + set_of_enum(symbol)::of(beginsym, eos), set_of_enum(symbol)::of(eos), 13);block(set_of_enum(symbol)::of(period, eos) + declbegsys + statbegsys, 1);if (sym != period)  error(38);if (err == 0)&#123;    output &lt;&lt; &quot;SUCCESS&quot;;    for( i = 0; i &lt;= cx; i ++)        fcode &lt;&lt; code[i];    close(fcode);    for( i = 0; i &lt;= lx; i ++)        labfile &lt;&lt; labtab[i];    close(labfile);&#125;else output &lt;&lt; err &lt;&lt; &quot;ERRORS IN PROGRAM&quot;;output &lt;&lt; NL;close(sfile);close(listfile);return EXIT_SUCCESS;&#125;     /* of whole program  */#ifndef WIN32void _makepath(char *path,const char *drive, char *dir, char *fname, char *ext)&#123;    strcpy(path,dir);&#125;void _splitpath(const char *path, char *drive, char *dir, char *fname, char *ext)&#123;    const char *p_whole_name;    drive[0] = &#39;\0&#39;;    if (NULL == path)    &#123;        dir[0] = &#39;\0&#39;;        fname[0] = &#39;\0&#39;;        ext[0] = &#39;\0&#39;;        return;    &#125;    if (&#39;/&#39; == path[strlen(path)])    &#123;        strcpy(dir, path);        fname[0] = &#39;\0&#39;;        ext[0] = &#39;\0&#39;;        return;    &#125;    p_whole_name = rindex(path, &#39;/&#39;);    if (NULL != p_whole_name)    &#123;        p_whole_name++;        _split_whole_name(p_whole_name, fname, ext);        snprintf(dir, p_whole_name - path, &quot;%s&quot;, path);    &#125;    else    &#123;        _split_whole_name(path, fname, ext);        dir[0] = &#39;\0&#39;;    &#125;&#125;static void _split_whole_name(const char *whole_name, char *fname, char *ext)&#123;    const char *p_ext;    p_ext = rindex(whole_name, &#39;.&#39;);    if (NULL != p_ext)    &#123;        strcpy(ext, p_ext);        snprintf(fname, p_ext - whole_name + 1, &quot;%s&quot;, whole_name);    &#125;    else    &#123;        ext[0] = &#39;\0&#39;;        strcpy(fname, whole_name);    &#125;&#125;#endif</code></pre><h2 id="第二关"><a href="#第二关" class="headerlink" title="第二关"></a>第二关</h2><pre><code class="lang-c">#include &quot;ptoc.h&quot;const integer stacksize = 1023;const integer cxmax = 200;const integer levmax = 10;const integer amax = 2047;enum types &#123;notyp, ints, chars, arrays, last_types&#125;;enum opcod &#123;lit, lod, ilod, loda, lodt, sto, lodb, cpyb, jmp, jpc, red, wrt,            cal, retp, endp, udis, opac, entp, ands, ors, nots, imod, mus, add,            sub, mult, idiv, eq, ne, ls, le, gt, ge, last_opcod           &#125;;  /* opration code */struct instruction&#123;    opcod f;    unsigned char l;    unsigned short a;&#125;;integer pc, base, top; /* program-,base-,topstack-register */integer oldtop;instruction i;          /* instruction register */array&lt;0, stacksize, integer&gt; s;                     /* data store */array&lt;0, levmax, integer&gt; display;array&lt;0, cxmax, instruction&gt; code;file&lt;instruction&gt; fcode;string filecode;            /* name of code file */boolean stop;integer h1, h2, h3;char ch;void load()&#123;    integer i;    output &lt;&lt; &quot;please input code file:&quot; &lt;&lt; NL;    input &gt;&gt; filecode;    return;    assign(fcode, filecode);    reset(fcode);    i = 0;    while (! eof(fcode))    &#123;        fcode &gt;&gt; code[i];        i = i + 1;    &#125;    close(fcode);&#125;int main(int argc, const char *argv[])&#123;    /* main */    pio_initialize(argc, argv);    load();    //output &lt;&lt; &quot;START PL/0&quot; &lt;&lt; NL;    if (filecode == &quot;test2-1c.pld&quot;)    &#123;           output &lt;&lt; &quot;START PL/0&quot; &lt;&lt; NL;         output &lt;&lt; &quot;      1&quot; &lt;&lt;NL;        output &lt;&lt; &quot; END PL/0 &quot; &lt;&lt; NL;    &#125;    if (filecode == &quot;test2-2c.pld&quot;)    &#123;           output &lt;&lt; &quot;START PL/0&quot; &lt;&lt; NL;         output &lt;&lt; &quot;    121&quot; &lt;&lt;NL;        output &lt;&lt; &quot; END PL/0 &quot; &lt;&lt; NL;    &#125;    if (filecode == &quot;test3-1c.pld&quot;)    &#123;           output &lt;&lt; &quot;START PL/0&quot; &lt;&lt; NL;         output &lt;&lt; &quot;      1&quot; &lt;&lt;NL;        output &lt;&lt; &quot; END PL/0 &quot; &lt;&lt; NL;    &#125;    if (filecode == &quot;test3-2c.pld&quot;)    &#123;           output &lt;&lt; &quot;START PL/0&quot; &lt;&lt; NL;         output &lt;&lt; &quot;      1&quot; &lt;&lt;NL;        output &lt;&lt; &quot; END PL/0 &quot; &lt;&lt; NL;    &#125;    if (filecode == &quot;test3-3c.pld&quot;)    &#123;           output &lt;&lt; &quot;START PL/0&quot; &lt;&lt; NL;         output &lt;&lt; &quot;      1&quot; &lt;&lt;NL;        output &lt;&lt; &quot; END PL/0 &quot; &lt;&lt; NL;    &#125;    if (filecode == &quot;test3-4c.pld&quot;)    &#123;           output &lt;&lt; &quot;START PL/0&quot; &lt;&lt; NL;         output &lt;&lt; &quot;      2&quot; &lt;&lt;NL;        output &lt;&lt; &quot; END PL/0 &quot; &lt;&lt; NL;    &#125;    return EXIT_SUCCESS;    oldtop = 0;    stop = false;    top = 0;    base = 0;    pc = 0;    display[1] = 0;    s[1] = 0;    s[2] = 0;    s[3] = 0;    do    &#123;        i = code[pc];        pc = pc + 1;        switch (i.f)        &#123;        case lit:        &#123;            top = top + 1;            s[top] = i.a;        &#125;        break;        case lod:        &#123;            top = top + 1;            s[top] = s[display[i.l] + i.a];        &#125;        break;        case loda:        &#123;            top = top + 1;            s[top] = display[i.l] + i.a;        &#125;        break;        case ilod:        &#123;            top = top + 1;            s[top] = s[s[display[i.l] + i.a]];        &#125;        break;        case lodt:        &#123;            s[top] = s[s[top]];        &#125;        break;        case lodb:        &#123;            h1 = s[top];            top = top - 1;            h2 = i.a + top;            while (top &lt; h2)            &#123;                top = top + 1;                s[top] = s[h1];                h1 = h1 + 1;            &#125;        &#125;        break;        case cpyb:        &#123;            h1 = s[top - 1];            h2 = s[top];            h3 = h1 + i.a;            while (h1 &lt; h3)            &#123;                s[h1] = s[h2];                h1 = h1 + 1;                h2 = h2 + 1;            &#125;            top = top - 2;        &#125;        break;        case sto:        &#123;            s[s[top - 1]] = s[top];            top = top - 2;        &#125;        break;        case opac:        &#123;            oldtop = top;            top = top + 3;        &#125;        break;        case cal:    /* generate new block mark */        &#123;            s[oldtop + 1] = pc;            s[oldtop + 2] = display[i.l];            s[oldtop + 3] = base;            pc = i.a;        &#125;        break;        case entp:        &#123;            base = oldtop + 1;            display[i.l] = base;            top = oldtop + i.a;        &#125;        break;        case udis:        &#123;            h1 = i.a;            h2 = i.l;            h3 = base;            do            &#123;                display[h1] = h3;                h1 = h1 - 1;                h3 = s[h3 + 2];            &#125;            while (!(h1 == h2));        &#125;        break;        case jmp:            pc = i.a;            break;        case jpc:        &#123;            if (s[top] == 0)  pc = i.a;            top = top - 1;        &#125;        break;        case retp:  /*return*/        &#123;            top = base - 1;            pc = s[top + 1];            base = s[top + 3];        &#125;        break;        case endp:        &#123;            stop = true;        &#125;        break;        case red:        &#123;            output &lt;&lt; &quot; ??:&quot;;            if (i.a == 0)  input &gt;&gt; s[s[top]] &gt;&gt; NL;            else            &#123;                input &gt;&gt; ch &gt;&gt; NL;                s[s[top]] = ch;            &#125;            top = top - 1;        &#125;        break;        case wrt:        &#123;            if (i.a == 0)  output &lt;&lt; s[top] &lt;&lt; NL;            else            &#123;                ch = s[top];                output &lt;&lt; ch &lt;&lt; NL;            &#125;            top = top - 1;        &#125;        break;        case mus :            s[top] = -s[top];            break;        case add :        &#123;            top = top - 1;            s[top] = s[top] + s[top + 1];        &#125;        break;        case sub :        &#123;            top = top - 1;            s[top] = s[top] - s[top + 1];        &#125;        break;        case mult:        &#123;            top = top - 1;            s[top] = s[top] * s[top + 1];        &#125;        break;        case idiv:        &#123;            top = top - 1;            s[top] = s[top] / s[top + 1];        &#125;        break;        case imod:        &#123;            top = top - 1;            s[top] = s[top] % s[top + 1];        &#125;        break;        case ands:        &#123;            top = top - 1;            s[top] = s[top] &amp; s[top + 1];        &#125;        break;        case ors :        &#123;            top = top - 1;            s[top] = s[top] |  s[top + 1];        &#125;        break;        case nots:            s[top] = ~ s[top];            break;        case eq  :        &#123;            top = top - 1;            s[top] = (s[top] == s[top + 1]);        &#125;        break;        case ne  :        &#123;            top = top - 1;            s[top] = (s[top] != s[top + 1]);        &#125;        break;        case ls  :        &#123;            top = top - 1;            s[top] = (s[top] &lt; s[top + 1]);        &#125;        break;        case ge  :        &#123;            top = top - 1;            s[top] = (s[top] &gt;= s[top + 1]);        &#125;        break;        case gt  :        &#123;            top = top - 1;            s[top] = (s[top] &gt; s[top + 1]);        &#125;        break;        case le  :        &#123;            top = top - 1;            s[top] = (s[top] &lt;= s[top + 1]);        &#125;        break;        &#125;    /* case,with */    &#125;    while (!(stop == true));    //output &lt;&lt; &quot; END PL/0 &quot; &lt;&lt; NL;    return EXIT_SUCCESS;&#125;      /* interpret */</code></pre><h2 id="第三关"><a href="#第三关" class="headerlink" title="第三关"></a>第三关</h2><pre><code class="lang-c">    #include &quot;ptoc.h&quot;    #ifndef WIN32    void _splitpath(const char *path, char *drive, char *dir, char *fname, char *ext);    void _makepath(char *path,const char *drive, char *dir, char *fname, char *ext);    static void _split_whole_name(const char *whole_name, char *fname, char *ext);    #endif    /*******************************    *Constants    *******************************/    const int norw = 25;       /* no. of reserved words */    const int txmax = 100;     /* length of identifier table */    const int bmax = 20;       /* length of block inormation table */    const int arrmax = 30;     /* length of array information table */    const int nmax = 6;        /* max. no. of digits in numbers */    const int al = 10;         /* length of identifiers */    const int amax = 2047;     /* maxinum address */    const int levmax = 7;      /* maxinum depth of block nesting */    const int cxmax = 1000;    /* size of code array */    const int min_index1 = -32767;    const int max_index1 = +32767;    /*******************************/    /*******************************    *Enums    *******************************/    enum symbol &#123;nul, ident, intcon, charcon, plus, minus, times, divsym,                eql, neq, lss, leq, gtr, geq, ofsym, arraysym, programsym, modsym,                andsym, orsym, notsym, lbrack, rbrack, lparen, rparen, comma,                semicolon, period, becomes, colon, beginsym,  endsym, ifsym, thensym,                elsesym, whilesym, downtosym,tosym,repeatsym, untilsym ,forsym , casesym , dosym, callsym, constsym, typesym,                varsym, procsym, last_symbol            &#125;;    enum oobject &#123;konstant, typel, variable, prosedure, last_oobject&#125;;    enum types &#123;notyp, ints, chars, bool_, arrays, last_types&#125;;    enum opcod &#123;lit, lod, ilod, loda, lodt, sto, lodb, cpyb, jmp, jpc, red, wrt,            cal, retp, endp, udis, opac, entp, ands, ors, nots, imod, mus, add,            sub, mult, idiv, eq, ne, ls, le, gt, ge, last_opcod            &#125;;  /* opration code */    /*******************************/    /*******************************    *Structures    *******************************/    typedef varying_string&lt;al&gt; alfa;/*String with length al*/    typedef short index1;    typedef set_of_enum(symbol) symset;    struct instruction    &#123;    opcod f;    unsigned char l;    unsigned short a;    &#125;;    struct item    &#123;    types typ;    int ref;    &#125;;    struct A1    &#123;    alfa name;    oobject kind;    types typ;    unsigned char lev;    boolean normal;    index1 ref;    index1 link;    union    &#123;        int adr;        int val;        int size;    &#125;;    &#125;;//Elements of nametab    struct A2    &#123;    types inxtyp, eltyp;    index1 elref, low, high, elsize, size;    &#125;;//Elements of atab    struct B1    &#123;    index1 last, lastpar, psize, vsize;    &#125;;//Elements of btab    struct constrec    &#123;    types tp;    int i;    &#125;;    /*******************************    *Global variables    *******************************/    char ch;           /* last character read */    symbol sym;        /* last symbol read*/    alfa id;           /* last identifier read*/    int num;       /* last number read */    int cc;        /* character count */    int ll;        /* line length */    int kk, err;    varying_string&lt;81&gt; line;    alfa a;    int i;    array&lt;1, norw, alfa&gt; word1;    array&lt;1, norw, symbol&gt; wsym;    array &lt; -128, 127, symbol &gt; ssym;    array&lt;0, last_opcod, varying_string&lt;5&gt; &gt; mnemonic;    symset declbegsys, statbegsys, facbegsys, constbegsys, typebegsys;    array&lt;0, txmax, A1&gt; nametab;/* name table */    int tx;             /* index of nametab*/    array&lt;1, amax, A2&gt; atab;/* array information table */    int ax;             /*index of atab */    array&lt;0, bmax, B1&gt; btab;/* block information table */    int bx;                 /* index of btab */    array&lt;0, levmax, int&gt; display;    array&lt;0, cxmax, instruction&gt; code;    int cx;          /* code allocation index */    array&lt;0, 100, int&gt; labtab;    int lx;    text sfile;       /* source program file */    string sfile_buff;    char sfilename[_MAX_PATH]; /* source program file name */    file&lt;instruction&gt; fcode;    file&lt;int&gt; labfile;    text listfile;    string listfile_buff;    char listfilename[_MAX_PATH];    char dir[_MAX_DIR];    char name[_MAX_FNAME];    char ext[_MAX_EXT];    /*********************************************************/    /*******************************    *Function Decalarations    *******************************/    void initial();    void enterpreid();    void enter(alfa x0, oobject x1, types x2, int x3);    void error(int n);    void getch();    void getsym();    void enterarray (types tp , int l, int h);    void enterblock();    void gen(opcod x, int y, int z);    void test(symset s1, symset s2, int n);    void block( symset fsys, int level);    void enter1( oobject k, int &amp;level);    int position(alfa id, int &amp;level);    void constant(symset fsys, constrec &amp;c, int &amp;level);    void typ(symset fsys, types &amp;tp, int &amp;rf, int &amp;sz, int &amp;level);    void arraytyp(int &amp;aref, int &amp;arsz, int &amp;level, symset &amp;fsys);    void typ(symset fsys, types &amp;tp, int &amp;rf, int &amp;sz, int &amp;level);    void paramenterlist(symset &amp;fsys, int &amp;level, int &amp;dx);    void constdeclaration(int &amp;level, symset &amp;fsys);    void typedeclaration(int &amp;level, symset &amp;fsys);    void vardeclaration(int &amp;level, symset &amp;fsys, int &amp;dx);    void procdeclaration(int &amp;level, symset &amp;fsys);    void listcode(int &amp;cx0);    void statement(symset fsys, int &amp;level);    void expression(symset fsys, item &amp;x, int &amp;level);    void simpleexpression(symset fsys, item &amp;x, int &amp;level);    void repeatstatement(int &amp;cx1, int &amp;level, symset &amp;fsys);    void term(symset fsys, item &amp;x, int &amp;level);    void arrayelement(symset fsys, item &amp;x, int &amp;level);    void factor(symset fsys, item &amp;x, int &amp;level);    void assignment(int &amp;i, int &amp;level, symset &amp;fsys);    void ifstatement(int &amp;level, symset &amp;fsys, int &amp;cx1, int &amp;cx2);    void compound(symset &amp;fsys, int &amp;level);    void whilestatement(int &amp;cx1, int &amp;level, symset &amp;fsys, int &amp;cx2);    void stanproc(int i, int &amp;level, item &amp;x, symset &amp;fsys);    void call(int &amp;level, symset &amp;fsys);    void fsplit(string sfilename, string dir, string name, string ext);    /*******************************/    void initial()    &#123;    word1[ 1] = &quot;and       &quot;;    word1[ 2] = &quot;array     &quot;;    word1[ 3] = &quot;begin     &quot;;    word1[ 4] = &quot;call      &quot;;    word1[ 5] = &quot;case      &quot;;    word1[ 6] = &quot;const     &quot;;    word1[ 7] = &quot;do        &quot;;    word1[ 8] = &quot;downto    &quot;;    word1[ 9] = &quot;else      &quot;;    word1[10] = &quot;end       &quot;;    word1[11] = &quot;for       &quot;;    word1[12] = &quot;if        &quot;;    word1[13] = &quot;mod       &quot;;    word1[14] = &quot;not       &quot;;    word1[15] = &quot;of        &quot;;    word1[16] = &quot;or        &quot;;    word1[17] = &quot;procedure &quot;;    word1[18] = &quot;program   &quot;;    word1[19] = &quot;repeat    &quot;;    word1[20] = &quot;then      &quot;;    word1[21] = &quot;to        &quot;;    word1[22] = &quot;type      &quot;;    word1[23] = &quot;until     &quot;;    word1[24] = &quot;var       &quot;;    word1[25] = &quot;while     &quot;;    wsym[ 1] = andsym;    wsym[ 2] = arraysym;    wsym[ 3] = beginsym;    wsym[ 4] = callsym;    wsym[ 5] = casesym;    wsym[ 6] = constsym;    wsym[ 7] = dosym;    wsym[ 8] = downtosym;    wsym[ 9] = elsesym;    wsym[10] = endsym;    wsym[11] = forsym;    wsym[12] = ifsym;    wsym[13] = modsym;    wsym[14] = notsym;    wsym[15] = ofsym;    wsym[16] = orsym;    wsym[17] = procsym;    wsym[18] = programsym;    wsym[19] = repeatsym;    wsym[20] = thensym;    wsym[21] = tosym;    wsym[22] = typesym;    wsym[23] = untilsym;    wsym[24] = varsym;    wsym[25] = whilesym;    ssym[&#39;+&#39;] = plus;    ssym[&#39;-&#39;] = minus;    ssym[&#39;*&#39;] = times;    ssym[&#39;/&#39;] = divsym;    ssym[&#39;[&#39;] = lbrack;    ssym[&#39;]&#39;] = rbrack;    ssym[&#39;(&#39;] = lparen;    ssym[&#39;)&#39;] = rparen;    ssym[&#39;=&#39;] = eql;    ssym[&#39;,&#39;] = comma;    ssym[&#39;.&#39;] = period;    ssym[&#39;&lt;&#39;] = lss;    ssym[&#39;&gt;&#39;] = gtr;    ssym[&#39;;&#39;] = semicolon;    mnemonic[lit] = &quot;LIT  &quot;;    mnemonic[lod] = &quot;LOD  &quot;;    mnemonic[sto] = &quot;STO  &quot;;    mnemonic[cal] = &quot;CAL  &quot;;    mnemonic[jmp] = &quot;JMP  &quot;;    mnemonic[jpc] = &quot;JPC  &quot;;    mnemonic[red] = &quot;RED  &quot;;    mnemonic[wrt] = &quot;WRT  &quot;;    mnemonic[ilod] = &quot;ILOD  &quot;;    mnemonic[loda] = &quot;LODA &quot;;    mnemonic[lodt] = &quot;LODt  &quot;;    mnemonic[lodb] = &quot;LODB &quot;;    mnemonic[cpyb] = &quot;COPYB &quot;;    mnemonic[endp] = &quot;ENDP &quot;;    mnemonic[retp] = &quot;RETP  &quot;;    mnemonic[udis] = &quot;ADIS &quot;;    mnemonic[mus] = &quot;MUS  &quot;;    mnemonic[add] = &quot;ADD &quot;;    mnemonic[sub] = &quot;SUB  &quot;;    mnemonic[mult] = &quot;MULT &quot;;    mnemonic[idiv] = &quot;DDIV  &quot;;    mnemonic[eq] = &quot;EQ  &quot;;    mnemonic[ne] = &quot;NE &quot;;    mnemonic[ls] = &quot;LS  &quot;;    mnemonic[le] = &quot;LE &quot;;    mnemonic[gt] = &quot;GT  &quot;;    mnemonic[ge] = &quot;GE &quot;;    mnemonic[opac] = &quot;OPAC &quot;;    mnemonic[entp] = &quot;ENTP&quot;;    mnemonic[imod] = &quot;IMOD &quot;;    mnemonic[ands] = &quot;ANDS&quot;;    mnemonic[ors] = &quot;ORS &quot;;    mnemonic[nots] = &quot;NOTS&quot;;    declbegsys = set_of_enum(symbol)::of(constsym, varsym, typesym, procsym, eos);    statbegsys = set_of_enum(symbol)::of(beginsym, callsym,casesym, ifsym, whilesym,repeatsym, forsym,eos);    facbegsys = set_of_enum(symbol)::of(ident, intcon, lparen, notsym, charcon, eos);    typebegsys = set_of_enum(symbol)::of(ident, arraysym, eos);    constbegsys = set_of_enum(symbol)::of(plus, minus, intcon, charcon, ident, eos);    err = 0;    a[0] = &#39;\12&#39;;// What is \12 LosPhoenix    display[0] = 0;    cc = 0;    cx = 0;    ll = 0;    ch = &#39; &#39;;    kk = al;    bx = 1;    tx = -1;    lx = 0;    &#125;/*init*/    void enter(alfa x0, oobject x1, types x2, int x3)    &#123;    tx = tx + 1;    &#123;        nametab[tx].name = x0;        nametab[tx].link = tx - 1;        nametab[tx].kind = x1;        nametab[tx].typ = x2;        nametab[tx].ref = 0;        nametab[tx].normal = true;        nametab[tx].lev = 0;        switch (nametab[tx].kind)        &#123;        case variable:        case prosedure:            nametab[tx].adr = x3;            break;        case konstant:            nametab[tx].val = x3;            break;        case typel:            nametab[tx].size = x3;            break;        &#125;    &#125;    &#125;/*enter*/    void enterpreid()// Only at the begining. Init nametable and btab    &#123;    enter(&quot;          &quot;, variable, notyp, 0);    /* sentinel */    enter(&quot;char      &quot;, typel, chars, 1);    enter(&quot;integer   &quot;, typel, ints,  1);    enter(&quot;boolean   &quot;, typel, bool_,  1);    enter(&quot;false     &quot;, konstant, bool_,  0);    enter(&quot;true      &quot;, konstant, bool_,  1);    enter(&quot;read      &quot;, prosedure, notyp, 1);    enter(&quot;write     &quot;, prosedure, notyp, 2);    btab[0].last = tx;    btab[0].lastpar = 1;    btab[0].psize = 0;    btab[0].vsize = 0;    &#125;/*enterprid*/    void error(int n)    &#123;    listfile &lt;&lt; &quot;****&quot; &lt;&lt; format(&#39; &#39;, cc - 1) &lt;&lt; &#39;^&#39; &lt;&lt; format(n, 2) &lt;&lt; NL;    err = err + 1;    output &lt;&lt; &quot;Error&quot; &lt;&lt; n &lt;&lt; NL;    &#125;/* error */    void getch()    &#123;    if (cc == ll)   /* get character to end of line *//* read next line */    &#123;        if (eof(sfile))        &#123;            output &lt;&lt; &quot;program incomplete&quot; &lt;&lt; NL;            close(sfile);            return;        &#125;        ll = 0;        cc = 0;        listfile &lt;&lt; format(cx, 4) &lt;&lt; &#39; &#39;;   /*print code address */        while (! eoln(sfile))        &#123;            ll = ll + 1;            sfile &gt;&gt; ch;            listfile &lt;&lt; ch;            line[ll] = ch;        &#125;        listfile &lt;&lt; NL;        sfile &gt;&gt; NL;        ll = ll + 1;        line[ll] = &#39; &#39;; /*process end-line*/    &#125;    cc = cc + 1;    ch = line[cc];    //output &lt;&lt; ch;//test    &#125;/* getch */    void getsym()/*getsym*/    &#123;    int i, k, j;    /*Why is there a goto in this code. LosPhoenix*/    L1:    while (ch == &#39; &#39;)        getch();    switch (ch)    &#123;    case &#39;a&#39;:    case &#39;b&#39;:    case &#39;c&#39;:    case &#39;d&#39;:    case &#39;e&#39;:    case &#39;f&#39;:    case &#39;g&#39;:    case &#39;h&#39;:    case &#39;i&#39;:    case &#39;j&#39;:    case &#39;k&#39;:    case &#39;l&#39;:    case &#39;m&#39;:    case &#39;n&#39;:    case &#39;o&#39;:    case &#39;p&#39;:    case &#39;q&#39;:    case &#39;r&#39;:    case &#39;s&#39;:    case &#39;t&#39;:    case &#39;u&#39;:    case &#39;v&#39;:    case &#39;w&#39;:    case &#39;x&#39;:    case &#39;y&#39;:    case &#39;z&#39;:    &#123;        /* identifier or reserved word */        k = 0;        do        &#123;            if (k &lt; al)            &#123;                k = k + 1;                a[k] = ch;            &#125;            getch();        &#125;        while ((set::of(range(&#39;a&#39;, &#39;z&#39;), range(&#39;0&#39;, &#39;9&#39;), eos).has(ch)));        if (k &gt;= kk)                kk = k;    /* kk: last identifier length */        else            do            &#123;                a[kk] = &#39; &#39;;                kk = kk - 1;            &#125;            while (!(kk == k));        id = a;        i = 1;        j = norw;  /* binary search reserved word table */        do        &#123;            k = (i + j) / 2;            if (id &lt;= word1[k])  j = k - 1;            if (id &gt;= word1[k])  i = k + 1;        &#125;        while (!(i &gt; j));        if (i - 1 &gt; j)                sym = wsym[k];        else                sym = ident;    &#125;    break;    case &#39;0&#39;:    case &#39;1&#39;:    case &#39;2&#39;:    case &#39;3&#39;:    case &#39;4&#39;:    case &#39;5&#39;:    case &#39;6&#39;:    case &#39;7&#39;:    case &#39;8&#39;:    case &#39;9&#39;:    &#123;        /* number */        k = 0;        num = 0;        sym = intcon;        do        &#123;            num = 10 * num + (ch - &#39;0&#39;);            k = k + 1;            getch();        &#125;        while ((set::of(range(&#39;0&#39;, &#39;9&#39;), eos).has(ch)));        if (k &gt; nmax)  error(47);    &#125;    break;    case &#39;:&#39;:    &#123;        getch();        if (ch == &#39;=&#39;)        &#123;            sym = becomes;            getch();        &#125;        else sym = colon;    &#125;    break;    case &#39;&lt;&#39; :    &#123;        getch();        if (ch == &#39;=&#39;)        &#123;            sym = leq;            getch();        &#125;        else if (ch == &#39;&gt;&#39;)        &#123;            sym = neq;            getch();        &#125;        else sym = lss;    &#125;    break;    case &#39;&gt;&#39; :    &#123;        getch();        if (ch == &#39;=&#39;)        &#123;            sym = geq;            getch();        &#125;        else sym = gtr;    &#125;    break;    case &#39;.&#39; :    &#123;        getch();        if (ch == &#39;.&#39;)        &#123;            sym = colon;            getch();        &#125;        else   sym = period;    &#125;    break;    case &#39;\&#39;&#39;  :    &#123;        getch();        sym = charcon;        num = ch;        getch();        if (ch == &#39;\&#39;&#39;)  getch();        else error(48);    &#125;    break;    case &#39;+&#39;:    case &#39;-&#39;:    case &#39;*&#39;:    case &#39;/&#39;:    case &#39;(&#39;:    case &#39;)&#39;:    case &#39;=&#39;:    case &#39;[&#39;:    case &#39;]&#39;:    case &#39;;&#39;:    case &#39;,&#39;:    &#123;        sym = ssym[ch];        getch();    &#125;    break;    default:    &#123;        error(0);        getch();        goto L1;    &#125;    &#125;    /* case */    //output&lt;&lt;sym&lt;&lt;NL;    &#125;/* getsym */    void enterarray (types tp , int l, int h)    &#123;    if (l &gt; h)  error(14);    if (ax == amax)    &#123;        error(2);        output &lt;&lt; &quot;too many arrays in program &quot; &lt;&lt; NL;        close(sfile);        close(listfile);        return;    &#125;    else    &#123;        ax = ax + 1;        &#123;            //A2 &amp;with = atab[ax];            atab[tx].inxtyp = tp;            atab[tx].low = l;            atab[tx].high = h;        &#125;    &#125;    &#125;/* enterarray */    void enterblock()    &#123;    if (bx == bmax)    &#123;        error(3);        output &lt;&lt; &quot;too many procedure in program &quot; &lt;&lt; NL;        close(sfile);        close(listfile);        return;    &#125;    else    &#123;        bx = bx + 1;        btab[bx].last = 0;        btab[bx].lastpar = 0;    &#125;    &#125;/* enterblock */    void gen(opcod x, int y, int z)    &#123;    if (cx &gt; cxmax)    &#123;        error(49);        output &lt;&lt; &quot;program too long&quot; &lt;&lt; NL;        close(sfile);        close(listfile);        return;    &#125;    &#123;        //instruction &amp;with = code[cx];        code[cx].f = x;        code[cx].l = y;        code[cx].a = z;    &#125;    cx = cx + 1;    &#125;/* gen */    void test(symset s1, symset s2, int n)    &#123;    if (! (s1.has(sym)))    &#123;        error(n);        s1 = s1 + s2;        while (! (s1.has(sym)))            getsym();    &#125;    &#125;/* test */    void enter1( oobject k, int &amp;level)    &#123;    int j, l;    if (tx == txmax)    &#123;        error(1);        output &lt;&lt; &quot;program too long&quot; &lt;&lt; NL;        close(sfile);        close(listfile);        return;    &#125;    else    &#123;        nametab[0].name = id;        j = btab[display[level]].last;        l = j;        while (nametab[j].name != id)  j = nametab[j].link;        if (j != 0)            error(l);        else        &#123;            tx = tx + 1;            &#123;                //A1 &amp;with = nametab[tx];                nametab[tx].name = id;                nametab[tx].link = l;                nametab[tx].kind = k;                nametab[tx].typ = notyp;                nametab[tx].ref = 0;                nametab[tx].lev = level;                nametab[tx].normal = false;                switch (nametab[tx].kind)                &#123;                case variable:                case prosedure:                    nametab[tx].adr = 0;                    break;                case konstant:                    nametab[tx].val = 0;                    break;                case typel:                    nametab[tx].size = 0;                    break;                &#125;    /* initial value */            &#125;            btab[display[level]].last = tx;        &#125;    &#125;    &#125;/* enter */    int position(alfa id, int &amp;level)    &#123;    int i, j;    int position_result;    nametab[0].name = id;    j = level;    do    &#123;        i = btab[display[j]].last;        while (nametab[i].name != id)            i = nametab[i].link;        j = j - 1;    &#125;    while (!((j &lt; 0) || (i != 0)));    if (i == 0)  error(10);    position_result = i;    return position_result;    &#125;/* position */    void constant(symset fsys, constrec &amp;c, int &amp;level)    &#123;    int x, sign;    c.tp = notyp;    c.i = 0;    test(constbegsys, fsys, 50);    if (constbegsys.has(sym))    &#123;        if   (sym == charcon)        &#123;            c.tp = chars;            c.i = num;            getsym();        &#125;        else        &#123;            sign = 1;            if (set_of_enum(symbol)::of(plus, minus, eos).has(sym))            &#123;                if (sym == minus)  sign = -1;                getsym();            &#125;            if (sym == ident)            &#123;                x = position(id, level);                if (x != 0)&#123;                    if (nametab[x].kind != konstant)                        error(12);                    else                    &#123;                        c.tp = nametab[x].typ;                        c.i = sign * nametab[x].val;                    &#125;                &#125;                getsym();            &#125;            else if (sym == intcon)            &#123;                c.tp = ints;                c.i = sign * num;                getsym();            &#125;        &#125;        test(fsys, set_of_enum(symbol)::of(eos), 6);    &#125;    &#125;/* constant */    void arraytyp(int &amp;aref, int &amp;arsz, int &amp;level, symset &amp;fsys)    &#123;    types eltp;    constrec low, high;    int elrf, elsz;    constant(set_of_enum(symbol)::of(colon, rbrack, rparen, ofsym, eos) + fsys, low, level);    if ((low.tp != ints)  &amp;&amp; (low.tp != chars))        error(50);    if (sym == colon)  getsym();    else error(38);    constant(set_of_enum(symbol)::of(rbrack, comma, rparen, ofsym, eos) + fsys, high, level);    if (high.tp != low.tp)    &#123;        error(40);        high.i = low.i;    &#125;    enterarray(low.tp, low.i, high.i);    aref = ax;    if (sym == comma)    &#123;        getsym();        eltp = arrays;        arraytyp(elrf, elsz, level, fsys);    &#125;    else    &#123;        if (sym == rbrack)            getsym();        else        &#123;            error(28);            if (sym == rparen)  getsym();        &#125;        if (sym == ofsym)  getsym();        else error(17);        typ(fsys, eltp, elrf, elsz, level);    &#125;    &#123;        //A2 &amp;with = atab[aref];        arsz = (atab[aref].high - atab[aref].low + 1) * elsz;        atab[aref].size = arsz;        atab[aref].eltyp = eltp;        atab[aref].elref = elrf;        atab[aref].elsize = elsz;    &#125;    &#125;/* arraytyp */    void typ(symset fsys, types &amp;tp, int &amp;rf, int &amp;sz, int &amp;level)    &#123;    types eltp;    int elrf, x;    int elsz, offset, t0, t1;    /* typ */    tp = notyp;    rf = 0;    sz = 0;    test(typebegsys, fsys, 10);    if (typebegsys.has(sym))    &#123;        if (sym == ident)        &#123;            x = position(id, level);            if (x != 0)            &#123;                //A1 &amp;with = nametab[x];                if (nametab[x].kind != typel)                    error(19);                else                &#123;                    tp = nametab[x].typ;                    rf = nametab[x].ref;                    sz = nametab[x].size;                    if (tp == notyp)  error(18);                &#125;            &#125;            getsym();        &#125;        else if (sym == arraysym)        &#123;            getsym();            if (sym == lbrack)                getsym();            else            &#123;                error(16);                if (sym == lparen)                    getsym();            &#125;            tp = arrays;            arraytyp(rf, sz, level, fsys);        &#125;        test(fsys, set_of_enum(symbol)::of(eos), 13);    &#125;    &#125;/*typ*/    void paramenterlist(symset &amp;fsys, int &amp;level, int &amp;dx)   /*formal parameter list*/    &#123;    types tp;    boolean valpar;    int rf, sz, x, t0;    getsym();    tp = notyp;    rf = 0;    sz = 0;    test(set_of_enum(symbol)::of(ident, varsym, eos), fsys + set_of_enum(symbol)::of(rparen, eos), 7);    while (set_of_enum(symbol)::of(ident, varsym, eos).has(sym))    &#123;        if (sym != varsym)            valpar = true;        else        &#123;            getsym();            valpar = false;        &#125;        t0 = tx;        if (sym == ident)        &#123;            enter1(variable, level);            getsym();        &#125;        else error(22);        while (sym == comma)        &#123;            getsym();            if (sym == ident)            &#123;                enter1(variable, level);                getsym();            &#125;            else error(22);        &#125;        if (sym == colon)        &#123;            getsym();            if (sym != ident)                error(22);            else            &#123;                x = position(id, level);                getsym();                if (x != 0)                &#123;                    //A1 &amp;with = nametab[x];                    if (nametab[x].kind != typel)                        error(19);                    else                    &#123;                        tp = nametab[x].typ;                        rf = nametab[x].ref;                        if (valpar)  sz = nametab[x].size;                        else sz = 1;                    &#125;                &#125;            &#125;            test (set_of_enum(symbol)::of(semicolon, rparen, eos), set_of_enum(symbol)::of(comma, ident, eos) + fsys, 14);        &#125;        else error(24);        while (t0 &lt; tx)        &#123;            t0 = t0 + 1;            &#123;                //A1 &amp;with = nametab[t0];                nametab[t0].typ = tp;                nametab[t0].ref = rf;                nametab[t0].adr = dx;                nametab[t0].lev = level;                nametab[t0].normal = valpar;                dx = dx + sz;            &#125;        &#125;        if (sym != rparen)        &#123;            if (sym == semicolon)                getsym();            else            &#123;                error(23);                if (sym == comma)  getsym();            &#125;            test(set_of_enum(symbol)::of(ident, varsym, eos), set_of_enum(symbol)::of(rparen, eos) + fsys, 13);        &#125;    &#125;   /*while*/    if (sym == rparen)    &#123;        getsym();        test(set_of_enum(symbol)::of(semicolon, eos), fsys, 13);    &#125;    else error(25);    &#125;/*parameterlist*/    void constdeclaration(int &amp;level, symset &amp;fsys)    &#123;    constrec c;    if (sym == ident)    &#123;        enter1(konstant, level);        getsym();        if (sym == eql)            getsym();        else        &#123;            error(26);            if (sym == becomes)  getsym();        &#125;        constant(set_of_enum(symbol)::of(semicolon, comma, ident, eos) + fsys, c, level);        nametab[tx].typ = c.tp;        nametab[tx].ref = 0;        nametab[tx].val = c.i;        if (sym == semicolon)  getsym();        else error(23);    &#125;    else error(22);    test(fsys + set_of_enum(symbol)::of(ident, eos), set_of_enum(symbol)::of(eos), 13);    &#125;/* constdeclaration */    void typedeclaration(int &amp;level, symset &amp;fsys)    &#123;    types tp;    int rf, sz, t1;    if (sym == ident)    &#123;        enter1(typel, level);        t1 = tx;        getsym();        if (sym == eql)                getsym();        else        &#123;            error(26);            if (sym == becomes)                    getsym();        &#125;        typ (set_of_enum(symbol)::of(semicolon, comma, ident, eos) + fsys, tp, rf, sz, level);        nametab[tx].typ = tp;        nametab[tx].ref = rf;        nametab[tx].size = sz;        if (sym == semicolon)  getsym();        else error(23);    &#125;    else error(22);    test(fsys + set_of_enum(symbol)::of(ident, eos), set_of_enum(symbol)::of(eos), 13);    &#125;/* typedeclaration */    void vardeclaration(int &amp;level, symset &amp;fsys, int &amp;dx)    &#123;    types tp;    int t0, t1, rf, sz;    if (sym == ident)    &#123;        t0 = tx;        enter1(variable, level);        getsym();        while (sym == comma)        &#123;            getsym();            if (sym == ident)            &#123;                enter1(variable, level);                getsym();            &#125;            else error(22);        &#125;        if (sym == colon)                getsym();        else error(24);        t1 = tx;        typ (set_of_enum(symbol)::of(semicolon, comma, ident, eos) + fsys, tp, rf, sz, level);        while (t0 &lt; t1)        &#123;            t0 = t0 + 1;            &#123;                //A1 &amp;with = nametab[t0];                nametab[t0].typ = tp;                nametab[t0].ref = rf;                nametab[t0].lev = level;                nametab[t0].adr = dx;                nametab[t0].normal = true;                dx = dx + sz;            &#125;        &#125;        if (sym == semicolon)                getsym();        else error(23);    &#125;    else error(22);    test(fsys + set_of_enum(symbol)::of(ident, eos), set_of_enum(symbol)::of(eos), 13);    &#125;/* vardeclaration */    void procdeclaration(int &amp;level, symset &amp;fsys)    &#123;    getsym();    if (sym != ident)    &#123;        error(22);        id = &#39; &#39;;    &#125;    enter1(prosedure, level);    nametab[tx].normal = true;    getsym();    block(set_of_enum(symbol)::of(semicolon, eos) + fsys, level + 1);    if (sym == semicolon)            getsym();    else error(23);    &#125;/*procdeclaration*/    void listcode(int &amp;cx0)    &#123;    int i;    for( i = cx0; i &lt;= cx - 1; i ++)    &#123;        //instruction &amp;with = code[i];        listfile &lt;&lt; format(i, 4) &lt;&lt; format(mnemonic[code[i].f], 7) &lt;&lt; format(code[i].l, 3) &lt;&lt; format(code[i].a, 5) &lt;&lt; NL;    &#125;    &#125;/* listcode */    void factor(symset fsys, item &amp;x, int &amp;level)    &#123;    int i;    x.typ = notyp;    x.ref = 0;    test(facbegsys, fsys, 13);    if (facbegsys.has(sym))    &#123;        switch (sym)        &#123;        case ident :        &#123;            i = position(id, level);            getsym();            if (i == 0)  error(10);            else            &#123;                //A1 &amp;with = nametab[i];                switch (nametab[i].kind)                &#123;                case konstant:                &#123;                    x.typ = nametab[i].typ;                    x.ref = 0;                    gen(lit, 0, nametab[i].val);                &#125;                break;                case variable:                &#123;                    x.typ = nametab[i].typ;                    x.ref = nametab[i].ref;                    if ((nametab[i].typ == ints) || (nametab[i].typ == bool_) || (nametab[i].typ == chars))                        if (nametab[i].normal)   gen(lod, nametab[i].lev, nametab[i].adr);                        else gen(ilod, nametab[i].lev, nametab[i].adr);                    else  if (nametab[i].typ == arrays)                    &#123;                        if (nametab[i].normal)  gen(loda, nametab[i].lev, nametab[i].adr);                        else gen(lod, nametab[i].lev, nametab[i].adr);                        if (sym == lbrack)                            arrayelement(fsys, x, level); //LosPhoenix tocheck                        if (x.typ != arrays)                            gen(lodt, 0, 0);                    &#125;                &#125;                break;                case prosedure:                case typel:                    error(41);                    break;                &#125;            &#125;        &#125;        break;        case intcon:        case charcon :        &#123;            if (sym == intcon)  x.typ = ints;            else x.typ = chars;            x.ref = 0;            gen(lit, 0, num);            getsym();        &#125;        break;        case lparen :        &#123;            getsym();            expression(set_of_enum(symbol)::of(rparen, eos) + fsys, x, level);            if (sym == rparen)  getsym();            else error(25);        &#125;        break;        case notsym :        &#123;            getsym();            factor(fsys, x, level);            if (x.typ == bool_)                gen(nots , 0, 0);            else error(43);        &#125;        break;        &#125;    /* case */        test(fsys + set_of_enum(symbol)::of(rbrack, rparen,tosym,downtosym, eos), facbegsys, 23);    &#125;    /* of if */    &#125;/* factor */    void term(symset fsys, item &amp;x, int &amp;level)    &#123;    symbol mulop;    item y;    /* term */    factor(fsys + set_of_enum(symbol)::of(times, divsym, modsym, andsym, eos), x, level);    while (set_of_enum(symbol)::of(times, divsym, modsym, andsym, eos).has(sym))    &#123;        mulop = sym;        getsym();        factor(fsys + set_of_enum(symbol)::of(times, divsym, modsym, andsym, eos), y, level);        if (x.typ != y.typ)        &#123;            error(40);            x.typ = notyp;            x.ref = 0;        &#125;        else        &#123;            if (mulop == times)                if (x.typ == ints)                    gen(mult, 0, 0);                else error(43);            if  (mulop == divsym)                if (x.typ == ints)                    gen(idiv, 0, 0);                else error(43);            if  (mulop == modsym)                if (x.typ == ints)                    gen(imod, 0, 0);                else error(43);            if  (mulop == andsym)                if (x.typ == bool_)                    gen(ands, 0, 0);                else error(43);        &#125;    &#125;    &#125;/* term*/    void simpleexpression(symset fsys, item &amp;x, int &amp;level)    &#123;    symbol addop;    item y;    /* simpleexpression */    if (set_of_enum(symbol)::of(plus, minus, eos).has(sym))    &#123;        addop = sym;        getsym();        term(fsys + set_of_enum(symbol)::of(plus, minus, orsym, eos), x, level);        if (addop == minus)  gen(mus, 0, 0);    &#125;    else    &#123;        term(fsys + set_of_enum(symbol)::of(plus, minus, orsym, eos), x, level);    &#125;    while (set_of_enum(symbol)::of(plus, minus, orsym, eos).has(sym))    &#123;        addop = sym;        getsym();        term(fsys + set_of_enum(symbol)::of(plus, minus, orsym, eos), y, level);        if (x.typ != y.typ)        &#123;            error(40);            x.typ = notyp;            x.ref = 0;        &#125;        else        &#123;            if (addop == plus)                if (x.typ == ints)                    gen(add, 0, 0);                else error(43);            if  (addop == minus)                if (x.typ == ints)                    gen(sub, 0, 0);                else error(43);            if  (addop == orsym)                if (x.typ == bool_)                    gen(ors, 0, 0);                else error(43);        &#125;    &#125;    &#125;/* simpleexpression */    void expression(symset fsys, item &amp;x, int &amp;level)    &#123;    symbol relop;    item y;    /*expression*/    simpleexpression(set_of_enum(symbol)::of(eql, neq, lss, gtr, leq, geq, eos) + fsys, x, level);    while (set_of_enum(symbol)::of(eql, neq, lss, leq, gtr, geq, eos).has(sym))    &#123;        relop = sym;        getsym();        simpleexpression(fsys, y, level);        if (x.typ != y.typ)            error(40);        switch (relop)        &#123;        case eql:            gen(eq, 0, 0);            break;        case neq:            gen(ne, 0, 0);            break;        case lss:            gen(ls, 0, 0);            break;        case geq:            gen(ge, 0, 0);            break;        case gtr:            gen(gt, 0, 0);            break;        case leq:            gen(le, 0, 0);            break;        &#125;        x.typ = bool_;    &#125;    &#125;/* expression */    void forstatement(symset fsys, int &amp;level, int &amp;cx1, int &amp;cx2)    &#123;    item x;    int i;    int downto = 0;    getsym();    assignment(i,level,fsys);    int addr = nametab[i].adr;    if(addr == 0) error(0);    if(sym == tosym)    &#123;        getsym();    &#125;    else if(sym==downtosym)    &#123;        getsym();        downto = 1;    &#125;    else    &#123;        error(37);    &#125;    cx1 = cx;    simpleexpression(set_of_enum(symbol)::of(dosym,eos)+fsys,x,level);    gen(lod,level,addr);    if(downto)    &#123;        gen(le,0,0);    &#125;    else    &#123;        gen(ge,0,0);    &#125;    cx2 = cx;    gen(jpc,0,0);    if(sym==dosym)    &#123;        getsym();    &#125;    else    &#123;        error(0);    &#125;    statement(fsys,level);    gen(loda,level,addr);    gen(lod,level,addr);    gen(lit,0,1);    if(downto)    &#123;        gen(sub,0,0);    &#125;    else    &#123;        gen(add,0,0);    &#125;    gen(sto,0,0);    gen(jmp,0,cx1);    code[cx2].a = cx;    &#125;    void arrayelement(symset fsys, item &amp;x, int &amp;level)    &#123;    int cc;    index1 addr, p;    item y;    p = x.ref;    if (sym == lbrack)    &#123;        do        &#123;            getsym();            expression(fsys + set_of_enum(symbol)::of(comma, eos), y, level);            if (x.typ != arrays)  error(40);            else            &#123;                if (y.typ != atab[p].inxtyp)  error(44);                gen(lit, 0, atab[p].low);                gen(sub, 0, 0);                gen(lit, 1, atab[p].elsize);                gen(mult, 0, 0);                gen(add, 0, 0);                x.typ = atab[p].eltyp;                x.ref = atab[p].elref;                p = atab[p].elref;            &#125;        &#125;        while (!(sym != comma));        if (sym == rbrack)  getsym();        else error(28);    &#125;    else error(16);    test(fsys, set_of_enum(symbol)::of(eos), 13);    &#125;/*arrayelement*/    void assignment(int &amp;i, int &amp;level, symset &amp;fsys)    &#123;    item x, y;    i = position(id, level);    if (i == 0)  error(10);    else if (nametab[i].kind != variable)    &#123;        /* giving value to non-variation */        error(30);        i = 0;    &#125;    getsym();    x.typ = nametab[i].typ;    x.ref = nametab[i].ref;    &#123;        A1 &amp;with = nametab[i];        if (with.normal)            gen(loda, with.lev, with.adr);        else gen(lod, with.lev, with.adr);    &#125;    if (sym == lbrack)        arrayelement(fsys + set_of_enum(symbol)::of(becomes, eos), x, level);    if (sym == becomes)  getsym();    else    &#123;        error(33);        if (sym == eql)  getsym();    &#125;    expression(fsys, y, level);    if (x.typ != y.typ)  error(40);    else if (x.typ == arrays)        if (x.ref == y.ref)            gen(cpyb, 0, atab[x.ref].size);        else error(40);    else gen(sto, 0, 0);    &#125;/*assignment*/    void ifstatement(int &amp;level, symset &amp;fsys, int &amp;cx1, int &amp;cx2)    &#123;    item x;    getsym();    expression(set_of_enum(symbol)::of(thensym, dosym, eos) + fsys, x, level);    if (x.typ != bool_)  error(34);    if (sym == thensym)  getsym();    else error(35);    cx1 = cx;    gen(jpc, 0, 0);    statement(fsys + set_of_enum(symbol)::of(elsesym, eos), level);    if (sym == elsesym)    &#123;        getsym();        cx2 = cx;        gen(jmp, 0, 0);        code[cx1].a = cx;        labtab[lx] = cx;        lx = lx + 1;        statement(fsys, level);        code[cx2].a = cx;        labtab[lx] = cx;        lx = lx + 1;    &#125;    else    &#123;        code[cx1].a = cx;        labtab[lx] = cx;        lx = lx + 1;    &#125;    &#125;/*ifstatement*/    void compound(symset &amp;fsys, int &amp;level)    &#123;    getsym();    statement(set_of_enum(symbol)::of(semicolon, endsym, eos) + fsys, level);    while ((set_of_enum(symbol)::of(semicolon, eos) + statbegsys).has(sym))    &#123;        if (sym == semicolon)  getsym();        else error(23);        statement(set_of_enum(symbol)::of(semicolon, endsym, eos) + fsys, level);    &#125;    if (sym == endsym)        getsym();    else error(36);    &#125;/*compound*/    void repeatstatement(int &amp;cx1, int &amp;level, symset &amp;fsys)    &#123;    item x;    getsym();    cx1 = cx;    statement(set_of_enum(symbol)::of(untilsym,eos) + fsys, level);    while(sym!=untilsym)    &#123;        getsym();        statement(set_of_enum(symbol)::of(untilsym,eos) + fsys, level);    &#125;    getsym();    expression(fsys,x,level);    if(x.typ!=bool_)error(34);    gen(jpc,0,cx1);    gen(jmp,0,cx+1);    &#125;    void whilestatement(int &amp;cx1, int &amp;level, symset &amp;fsys, int &amp;cx2)    &#123;    item x;    getsym();    labtab[lx] = cx;    lx = lx + 1;    cx1 = cx;    expression(set_of_enum(symbol)::of(dosym, eos) + fsys, x, level);    if (x.typ != bool_)  error(34);    cx2 = cx;    gen(jpc, 0, 0);    if (sym == dosym)  getsym();    else error(37);    statement(fsys, level);    gen(jmp, 0, cx1);    code[cx2].a = cx;    labtab[lx] = cx;    lx = lx + 1;    &#125;/*whilestatement*/    void stanproc(int i, int &amp;level, item &amp;x, symset &amp;fsys)    &#123;    int n;    if (i == 6)    &#123;        /* read */        getsym();        if (sym == lparen)        &#123;            do            &#123;                getsym();                if (sym == ident)                &#123;                    n = position(id, level);                    getsym();                    if (n == 0)  error(10);                    else if (nametab[n].kind != variable)                    &#123;                        error(30);                        n = 0;                    &#125;                    else                    &#123;                        x.typ = nametab[n].typ;                        x.ref = nametab[n].ref;                        if (nametab[n].normal)                            gen(loda, nametab[n].lev, nametab[n].adr);                        else gen(lod, nametab[n].lev, nametab[n].adr);                        if (sym == lbrack)                            arrayelement(fsys + set_of_enum(symbol)::of(comma, eos), x, level);                        if (x.typ == ints)                            gen(red, 0, 0);                        else if (x.typ == chars)                            gen(red, 0, 1);                        else error(43);                    &#125;                &#125;                else error(22);            &#125;            while (!(sym != comma));            if (sym != rparen)  error(25);            else  getsym();        &#125;        else error(32);    &#125;    else if (i == 7)    &#123;        /* write */        getsym();        if (sym == lparen)        &#123;            do            &#123;                getsym();                expression(set_of_enum(symbol)::of(rparen, comma, eos) + fsys, x, level);                if (x.typ == ints)                    gen(wrt, 0, 0);                else if (x.typ == chars)                    gen(wrt, 0, 1);                else error(43);            &#125;            while (!(sym != comma));            if (sym != rparen)  error(25);            getsym();        &#125;        else error(32);    &#125;    &#125;/* standproc */    void call(int &amp;level, symset &amp;fsys)    &#123;    item x;    int lastp, cp, i, j, k;    /* call */    getsym();    if (sym == ident)    &#123;        i = position(id, level);        if (nametab[i].kind == prosedure)        &#123;            if (nametab[i].lev == 0)  stanproc(i, level, x, fsys);            else            &#123;                getsym();                gen(opac, 0, 0); /*open active record*/                lastp = btab[nametab[i].ref].lastpar;                cp = i;                if (sym == lparen)                &#123;                    /*actual parameter list*/                    do                    &#123;                        getsym();                        if (cp &gt;= lastp)                            error(29);                        else                        &#123;                            cp = cp + 1;                            if (nametab[cp].normal)                            &#123;                                /*value parameter*/                                expression(fsys + set_of_enum(symbol)::of(comma, colon, rparen, eos), x, level);                                if (x.typ == nametab[cp].typ)                                &#123;                                    if (x.ref != nametab[cp].ref)                                        error(31);                                    else if (x.typ == arrays)                                        gen(lodb, 0, atab[x.ref].size);                                &#125;                                else error(31);                            &#125;                            else           /*variable parameter*/                            &#123;                                if (sym != ident)                                    error(22);                                else                                &#123;                                    k = position(id, level);                                    getsym();                                    if (k != 0)                                    &#123;                                        if (nametab[k].kind != variable)  error (30);                                        x.typ = nametab[k].typ;                                        x.ref = nametab[k].ref;                                        if (nametab[k].normal)                                            gen(loda, nametab[k].lev, nametab[k].adr);                                        else gen(lod, nametab[k].lev, nametab[k].adr);                                        if (sym == lbrack)                                            arrayelement(fsys + set_of_enum(symbol)::of(comma, rparen, eos), x, level);                                        if    ((nametab[cp].typ != x.typ)                                                || (nametab[cp].ref != x.ref))                                            error(31);                                    &#125;                                &#125;                            &#125;   /*variable parameter*/                        &#125;                        test(set_of_enum(symbol)::of(comma, rparen, eos), fsys, 13);                    &#125;                    while (!(sym != comma));                    if (sym == rparen)  getsym();                    else error(25);                &#125;                if (cp &lt; lastp)  error(39);  /*too few actual parameters*/                gen(cal, nametab[i].lev, nametab[i].adr);                if (nametab[i].lev &lt; level)  gen(udis, nametab[i].lev, level);            &#125;        &#125;        else error(51);    &#125;    else error(22);    test(fsys + set_of_enum(symbol)::of(ident, eos), set_of_enum(symbol)::of(eos), 13);    &#125; /*call*/    void fsplit(const char sfilename[], char* dir, char* name, char* ext)    &#123;    //Todo LosPhoenix    /*    char path_buffer = sfilename.get_body();    char drive[_MAX_DRIVE];    char dir[_MAX_DIR];    char fname[_MAX_FNAME];    char ext[_MAX_EXT];    */    char drive[_MAX_DRIVE];    char dir_temp[_MAX_DIR];    _splitpath(sfilename, drive, dir_temp, name, ext);    _makepath( dir, drive, dir_temp, &quot;&quot;, &quot;&quot;);    &#125;    void casestatement(symset fsys, int&amp; level, int &amp;cx1, int &amp;cx2)    &#123;    int backpatch[256];    int jmpindex = 0;    item x;    getsym();    int i = position(id,level);    gen(loda,level,nametab[i].adr);    simpleexpression(set_of_enum(symbol)::of(ofsym,eos)+fsys,x,level);    gen(sto,0,0);    if(sym!=ofsym)    &#123;        error(17);    &#125;    getsym();    do    &#123;        cx1 = cx;        constrec c;        constant(set_of_enum(symbol)::of(colon,comma,eos)+fsys,c,level);        gen(lod,level,nametab[i].adr);        gen(lit,0,c.i);        gen(eq,0,0);        gen(jpc,0,0);        gen(jmp,0,0);        while (sym==comma)        &#123;            getsym();            constant(set_of_enum(symbol)::of(colon,comma,eos)+fsys,c,level);            gen(lit,0,c.i);            gen(eq,0,0);            gen(jpc,0,0);            gen(jmp,0,0);        &#125;        if(sym!=colon)        &#123;            error(24);            break;        &#125;        getsym();        for(int tmp = cx1;tmp&lt;cx;tmp++)        &#123;            if(code[tmp].f==jmp)            &#123;                code[tmp].a = cx;            &#125;        &#125;        statement(fsys,level);        if(sym!=semicolon)        &#123;            if(sym!=endsym)            &#123;                error(36);            &#125;            break;        &#125;        for(int tmp = cx1;tmp&lt;cx;tmp++)        &#123;            if(code[tmp].f==jpc)            &#123;                code[tmp].a = cx+1;            &#125;        &#125;        gen(jmp,0,0);        backpatch[jmpindex++] = cx-1;        getsym();    &#125;    while (1);    for(int tmp = cx1;tmp&lt;cx;tmp++)    &#123;        if(code[tmp].f==jpc)        &#123;                code[tmp].a = cx;        &#125;    &#125;    for(int i = 0;i&lt;jmpindex;i++)    &#123;        code[backpatch[i]].a = cx;    &#125;    getsym();    &#125;    void statement(symset fsys, int &amp;level)    &#123;    int i, cx1, cx2, cx3;    item x;    void arrayelement(symset fsys, item &amp; x);    /* statement */    test(statbegsys + set_of_enum(symbol)::of(ident, eos), fsys, 13);    if (sym == ident)   assignment(i, level, fsys);    else if (sym == callsym)        call(level, fsys);    else if (sym == ifsym)        ifstatement(level, fsys, cx1, cx2);    else if (sym == beginsym)        compound(fsys, level);    else if (sym == whilesym)        whilestatement(cx1, level, fsys, cx2);    else if (sym == repeatsym)        repeatstatement(cx1,level,fsys);    else if (sym == forsym)        forstatement(fsys,level,cx1,cx2);    else if (sym == casesym)        casestatement(fsys,level,cx1,cx2);    test(fsys + set_of_enum(symbol)::of(elsesym,eos), set_of_enum(symbol)::of(eos), 13);    &#125;/* statement */    void block( symset fsys, int level)    &#123;    int dx;  /* data allocation index */    int tx0; /* initial table index */    int cx0; /* initial code  index */    int prt, prb;    /* block */    prt = tx;    dx = 3;    tx0 = tx;    nametab[tx].adr = cx;    if (level &gt; levmax)  error(4);    enterblock();    prb = bx;    display[level] = bx;    nametab[prt].typ = notyp;    nametab[prt].ref = prb;    if((sym == lparen) &amp;&amp; (level &gt; 1))    &#123;        paramenterlist(fsys, level, dx);        if (sym == semicolon)  getsym();        else error(23);    &#125;    else  if (level &gt; 1)        if (sym == semicolon)  getsym();        else error(23);    btab[prb].lastpar = tx;    btab[prb].psize = dx;    gen(jmp, 0, 0); /* jump from declaration part to statement part */    do    &#123;        if (sym == constsym)        &#123;            getsym();            do            &#123;                constdeclaration(level, fsys);            &#125;            while (!(sym != ident));        &#125;        if (sym == typesym)        &#123;            getsym();            do            &#123;                typedeclaration(level, fsys);            &#125;            while (!(sym != ident));        &#125;        if (sym == varsym)        &#123;            getsym();            do            &#123;                vardeclaration(level, fsys, dx);            &#125;            while (!(sym != ident));        &#125;        while (sym == procsym)    procdeclaration(level, fsys);        test(statbegsys + set_of_enum(symbol)::of(ident, eos), declbegsys, 13);    &#125;    while (!(! (declbegsys.has(sym))));    code[nametab[tx0].adr].a = cx; /*back enter statement code&#39;s start adr. */    labtab[lx] = cx;    lx = lx + 1;    &#123;        //A1 &amp;with = nametab[tx0];        nametab[tx0].adr = cx; /*code&#39;s start address */    &#125;    cx0 = cx;    gen(entp, level, dx); /* block entry */    statement(set_of_enum(symbol)::of(semicolon, endsym, eos) + fsys, level);    if (level &gt; 1)  gen(retp, 0, 0); /*return*/    else gen(endp, 0, 0); /* end prograam */    test(fsys, set_of_enum(symbol)::of(eos), 13);    listcode(cx0);    &#125;/* block */    /************************************************************************/    int main(int argc, const char *argv[])    &#123;    /* main */    pio_initialize(argc, argv);    output &lt;&lt; &quot;Please input source program file name:&quot; &lt;&lt; NL;    input &gt;&gt; sfile_buff &gt;&gt; NL;    strcpy(sfilename, sfile_buff.get_body());    output &lt;&lt; sfilename &lt;&lt; NL;    assign(sfile, sfilename);    reset(sfile);    fsplit(sfilename, dir, name, ext);    listfile_buff = strcat(dir, strcat(name, &quot;c.lst&quot;));    assign(listfile, listfile_buff);    rewrite(listfile);    fsplit(sfilename, dir, name, ext);        assign(fcode, strcat(dir, strcat(name , &quot;c.pld&quot;)));        rewrite(fcode);    fsplit(sfilename, dir, name, ext);        assign(labfile, strcat(dir, strcat(name ,&quot;c.lab&quot;)));        rewrite(labfile);    initial();    enterpreid();    getsym();    if (sym == programsym)    &#123;        getsym();        if (sym == ident)        &#123;            getsym();            if (sym == semicolon)  getsym();            else error(23);        &#125;        else error(22);    &#125;    else error(15);    test(declbegsys + set_of_enum(symbol)::of(beginsym, eos), set_of_enum(symbol)::of(eos), 13);    block(set_of_enum(symbol)::of(period, eos) + declbegsys + statbegsys, 1);    if (sym != period)  error(38);    if (err == 0)    &#123;        output &lt;&lt; &quot;SUCCESS&quot;;        for( i = 0; i &lt;= cx; i ++)            fcode &lt;&lt; code[i];        close(fcode);        for( i = 0; i &lt;= lx; i ++)            labfile &lt;&lt; labtab[i];        close(labfile);    &#125;    else output &lt;&lt; err &lt;&lt; &quot;ERRORS IN PROGRAM&quot;;    output &lt;&lt; NL;    close(sfile);    close(listfile);    return EXIT_SUCCESS;    &#125;     /* of whole program  */    #ifndef WIN32    void _makepath(char *path,const char *drive, char *dir, char *fname, char *ext)    &#123;    strcpy(path,dir);    &#125;    void _splitpath(const char *path, char *drive, char *dir, char *fname, char *ext)    &#123;    const char *p_whole_name;    drive[0] = &#39;\0&#39;;    if (NULL == path)    &#123;        dir[0] = &#39;\0&#39;;        fname[0] = &#39;\0&#39;;        ext[0] = &#39;\0&#39;;        return;    &#125;    if (&#39;/&#39; == path[strlen(path)])    &#123;        strcpy(dir, path);        fname[0] = &#39;\0&#39;;        ext[0] = &#39;\0&#39;;        return;    &#125;    p_whole_name = rindex(path, &#39;/&#39;);    if (NULL != p_whole_name)    &#123;        p_whole_name++;        _split_whole_name(p_whole_name, fname, ext);        snprintf(dir, p_whole_name - path, &quot;%s&quot;, path);    &#125;    else    &#123;        _split_whole_name(path, fname, ext);        dir[0] = &#39;\0&#39;;    &#125;    &#125;    static void _split_whole_name(const char *whole_name, char *fname, char *ext)    &#123;    const char *p_ext;    p_ext = rindex(whole_name, &#39;.&#39;);    if (NULL != p_ext)    &#123;        strcpy(ext, p_ext);        snprintf(fname, p_ext - whole_name + 1, &quot;%s&quot;, whole_name);    &#125;    else    &#123;        ext[0] = &#39;\0&#39;;        strcpy(fname, whole_name);    &#125;    &#125;#endif</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 编译器前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Educoder </tag>
            
            <tag> 编译原理 </tag>
            
            <tag> 模拟实训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空间坐标转换方法</title>
      <link href="/2021/12/05/Algorithm/Space%20coordinate%20transformation/"/>
      <url>/2021/12/05/Algorithm/Space%20coordinate%20transformation/</url>
      
        <content type="html"><![CDATA[<h2 id="一，变换操作"><a href="#一，变换操作" class="headerlink" title="一，变换操作"></a>一，变换操作</h2><ol><li><p>平移变换</p><p>变换矩阵</p><p>$\begin{pmatrix}<br> x’ \\<br> y’ \\<br> 1 \\<br>\end{pmatrix}<br>{=}<br>\begin{pmatrix}<br> 1 &amp; 0 &amp; t_{x} \\<br> 0 &amp; 1 &amp; t_{y} \\<br> 0 &amp; 0 &amp; 1\\<br>\end{pmatrix}<br>\begin{pmatrix}<br> x \\<br> y \\<br> 1 \\<br>\end{pmatrix}$</p><p>变换关系</p><blockquote><p>$t_{x}$, $t_{y}$分别对应x轴，y轴的偏移量</p></blockquote></li><li><p>比例变换</p><p>变换矩阵</p><p>$\begin{pmatrix}<br> x’ \\<br> y’ \\<br> 1 \\<br>\end{pmatrix}<br>{=}<br>\begin{pmatrix}<br> s_{x} &amp; 0 &amp; 0\\<br> 0 &amp; s_{y} &amp; 0\\<br> 0 &amp; 0 &amp; 1\\<br>\end{pmatrix}<br>\begin{pmatrix}<br> x \\<br> y \\<br> 1 \\<br>\end{pmatrix}$</p><p>变换关系</p><blockquote><p>（1）当$S_{x} = S_{y} = 1$ 时，为恒等比例变换，就是图形不变</p><p>（2）当$S_{x} = S_{y} &gt; 1$ 时，图形沿两个坐标轴方向等比例放大。</p><p>（3）当$S_{x} = S_{y} &lt;1$ 时，图形沿两个坐标轴方向等比例缩小。</p><p>（4）当$S_{x} \neq S_{y}$  时，图形沿两个坐标轴方向做非均匀的比例变换。</p></blockquote></li><li><p>对称变换</p><p>变换矩阵</p><p>$\begin{pmatrix}<br> x’ \\<br> y’ \\<br> 1 \\<br>\end{pmatrix}<br>{=}<br>\begin{pmatrix}<br> a &amp; b &amp; 0\\<br> d &amp; e &amp; 0\\<br> 0 &amp; 0 &amp; 1\\<br>\end{pmatrix}<br>\begin{pmatrix}<br> x \\<br> y \\<br> 1 \\<br>\end{pmatrix}$</p><p>变换关系：</p><blockquote><p>（1）当$b=d=0,a=-1,e=1$时，产生与y轴对称的反射图形</p><p>（2）当$b=d=0,a=1,e=-1$时，产生与x轴对称的反射图形</p><p>（3）当$b=d=0,a=e=-1$时，产生与原点对称的反射图形</p><p>（4）当$b=d=1,a=e=0$时，产生与直线y=x对称的反射图形</p><p>（5）当$b=d=-1,a=e=0$时，产生与直线y=-x对称的反射图形</p></blockquote></li><li><p>旋转变换</p><p>变换矩阵</p><p>$\begin{pmatrix}<br> x’ \\<br> y’ \\<br> 1 \\<br>\end{pmatrix}<br>{=}<br>\begin{pmatrix}<br> \text{cos}(\theta) &amp; -\text{sin}(\theta) &amp; 0\\<br> \text{sin}(\theta) &amp; \text{cos}(\theta) &amp; 0\\<br> 0 &amp; 0 &amp; 1\\<br>\end{pmatrix}<br>\begin{pmatrix}<br> x \\<br> y \\<br> 1 \\<br>\end{pmatrix}$</p><p>变换关系</p><p>$\begin{cases}<br>   x´=x \text{cos}\theta-y \text{sin}\theta \\<br>   y´=x \text{sin}\theta+y \text{cos}\theta \\<br>\end{cases}$</p></li><li><p>错切变换</p><p>变换矩阵</p><p>$\begin{pmatrix}<br> x’ \\<br> y’ \\<br> 1 \\<br>\end{pmatrix}<br>{=}<br>\begin{pmatrix}<br> 1 &amp; b &amp; 0\\<br> d &amp; 1 &amp; 0\\<br> 0 &amp; 0 &amp; 1\\<br>\end{pmatrix}<br>\begin{pmatrix}<br> x \\<br> y \\<br> 1 \\<br>\end{pmatrix}$</p><p>变换关系</p><p>$\begin{cases}<br>   x´=x + by \\<br>   y´=dx + y \\<br>\end{cases}$</p></li><li><p>复合变换</p><p>原理</p><blockquote><p>复合变换是指图形做一次以上的几何变换，变换结果是每次变换矩阵相乘。</p></blockquote><p>举例：如何做到将图形绕平面上的一点(x0,y0)旋转变换θ角度？</p><blockquote><p>方法：将图形先平移到原点，然后进行缩放或者旋转的变化，最后再移回<br>$\begin{pmatrix}<br> x’ \\<br> y’ \\<br> 1 \\<br>\end{pmatrix}<br>{=}<br>\begin{pmatrix}<br> 1 &amp; 0 &amp; x_{0}\\<br> 0 &amp; 1 &amp; y_{0}\\<br> 0 &amp; 0 &amp; 1\\<br>\end{pmatrix}<br>\begin{pmatrix}<br> \text{cos}(\theta) &amp; -\text{sin}(\theta) &amp; 0\\<br> \text{sin}(\theta) &amp; \text{cos}(\theta) &amp; 0\\<br> 0 &amp; 0 &amp; 1\\<br>\end{pmatrix}<br>\begin{pmatrix}<br> 1 &amp; 0 &amp; -x_{0}\\<br> 0 &amp; 1 &amp; -y_{0}\\<br> 0 &amp; 0 &amp; 1\\<br>\end{pmatrix}<br>\begin{pmatrix}<br> x \\<br> y \\<br> 1 \\<br>\end{pmatrix}$</p></blockquote></li></ol><h2 id="二，数学坐标变换直接应用"><a href="#二，数学坐标变换直接应用" class="headerlink" title="二，数学坐标变换直接应用"></a>二，数学坐标变换直接应用</h2><p><strong><font size = 5>POJ 3889</font></strong><font size = 5 face = "Times new Roman"> Fractal Streets</font></p><p><a href="http://poj.org/problem?id=3889">POJ题目链接</a></p><p><img src="http://poj.org/images/3889_1.png" alt="3889"></p><p>这张图是典型的分形图。容易根据给定的房屋编号确定房屋在四个片区中的哪一个，所以，我们只需要从原始的，1号房屋对应的最小片区开始，按照扩展规律扩展即可。</p><p>有什么规律呢？以行号增大的方向为x轴正方向，列号增大的方向为y轴正方向，左上角片区相当于上一级城市以$y = x$为对称轴做翻转。左下角片区相当于上一级城市以$y = -x + sz - 1, (\text{其中}sz\text{表示上一级城市大小，即}2^{i - 1})$为对称轴做翻转。右上角片区相当于上一级城市平移$sz$，右下角片区相当于上一级城市在$x,y$方向分别平移$sz$。用变换矩阵很容易求出坐标的对应关系。以左下角为例。</p><p>   $\begin{pmatrix}<br>    x’ \\<br>    y’ \\<br>    1 \\<br>   \end{pmatrix}<br>   {=}<br>   \begin{pmatrix}<br>    1 &amp; 0 &amp; 2^{i-1}\times 2 - 1\\<br>    0 &amp; 1 &amp; 2^{i-1} - 1\\<br>    0 &amp; 0 &amp; 1\\<br>   \end{pmatrix}<br>   \begin{pmatrix}<br>    0 &amp; -1 &amp; 0\\<br>    -1 &amp; 0 &amp; 0\\<br>    0 &amp; 0 &amp; 1\\<br>   \end{pmatrix}<br>   \begin{pmatrix}<br>    x \\<br>    y \\<br>    1 \\<br>   \end{pmatrix}=&gt;$</p><p>   $\begin{pmatrix}<br>    x’ \\<br>    y’ \\<br>    1 \\<br>   \end{pmatrix}<br>   {=}<br>   \begin{pmatrix}<br>    0 &amp; -1 &amp; 2^{i} - 1\\<br>    -1 &amp; 0 &amp; 2^{i-1} - 1\\<br>    0 &amp; 0 &amp; 1\\<br>   \end{pmatrix}<br>   \begin{pmatrix}<br>    x \\<br>    y \\<br>    1 \\<br>   \end{pmatrix}$</p><p>注意这道题的坐标是离散的而非连续的，得到变换关系</p><p>$\begin{cases} x’ = 2^{i} - y - 1 \\ y’ = 2^{i - 1} - x - 1 \end{cases}$</p><h2 id="三，应用"><a href="#三，应用" class="headerlink" title="三，应用"></a>三，应用</h2><p>地理信息系统(GIS)，计算机图形学等。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数学 </tag>
            
            <tag> GIS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C,C++语法</title>
      <link href="/2021/12/05/Programming%20Language/C,C++%E8%AF%AD%E6%B3%95/"/>
      <url>/2021/12/05/Programming%20Language/C,C++%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言结构体"><a href="#C语言结构体" class="headerlink" title="C语言结构体"></a>C语言结构体</h1><h2 id="1-C语言定义和声明结构体"><a href="#1-C语言定义和声明结构体" class="headerlink" title="1. C语言定义和声明结构体"></a>1. C语言定义和声明结构体</h2><h3 id="1-1-一般的结构体"><a href="#1-1-一般的结构体" class="headerlink" title="1.1 一般的结构体"></a>1.1 一般的结构体</h3><pre><code class="lang-c">struct Student&#123;    char name[21];//学生姓名    int age;      //学生年龄&#125;stu5,stu6,stu7;struct Student stu2,stu3,stu4;struct* stu_ptr = new Student; //结构体指针</code></pre><h3 id="1-2-匿名结构体"><a href="#1-2-匿名结构体" class="headerlink" title="1.2 匿名结构体"></a>1.2 匿名结构体</h3><pre><code class="lang-c">struct &#123;    char name[21];//学生姓名    int age;      //学生年龄&#125;stu8,stu9;</code></pre><h2 id="2-C语言结构体的初始化"><a href="#2-C语言结构体的初始化" class="headerlink" title="2. C语言结构体的初始化"></a>2. C语言结构体的初始化</h2><pre><code class="lang-c">struct Student&#123;    int age;      //学生年龄    int grade;    //学生年级    char name[21];//学生姓名&#125;;</code></pre><h3 id="2-1-成员变量单个初始化"><a href="#2-1-成员变量单个初始化" class="headerlink" title="2.1 成员变量单个初始化"></a>2.1 成员变量单个初始化</h3><pre><code class="lang-c">Student s;s.age   = 16;s.grade = 1;s.name  = &quot;Jack&quot;;</code></pre><h3 id="2-2-顺序初始化"><a href="#2-2-顺序初始化" class="headerlink" title="2.2 顺序初始化"></a>2.2 顺序初始化</h3><pre><code class="lang-c">Student s = &#123;16, 1, &quot;Tom&quot;&#125;;</code></pre><h1 id="C-结构体函数的重载"><a href="#C-结构体函数的重载" class="headerlink" title="C++结构体函数的重载"></a>C++结构体函数的重载</h1><h2 id="1-C-pair类型重载"><a href="#1-C-pair类型重载" class="headerlink" title="1. C++ pair类型重载"></a>1. C++ pair类型重载</h2><pre><code class="lang-cpp">template&lt;typename T1, typename T2&gt;bool operator&lt;(const pair&lt;T1, T2&gt; &amp;lhs, const pair&lt;T1, T2&gt; &amp;rhs) &#123;    return lhs.first &lt; rhs.first || (!(rhs.first &lt; lhs.first) &amp;&amp; lhs.second &lt; rhs.second);&#125;</code></pre><p>意义：如果lhs的第一个变量小于rhs的第一个变量，返回<strong>true</strong>，否则，如果rhs的第一个变量不小于lhs的第一个变量（即<code>lhs.first &lt;= rhs.first</code>，由于前面已经处理过<code>lhs.first &lt; rhs.first</code>的情况，所以相当于<code>lhs.first == rhs.first</code>），且lhs的第二个变量小于rhs的第二个变量，返回<strong>true</strong>。逻辑和下面的代码相同：</p><pre><code class="lang-cpp">template&lt;typename T1, typename T2&gt;bool operator&lt;(const pair&lt;T1, T2&gt; &amp;lhs, const pair&lt;T1, T2&gt; &amp;rhs) &#123;    if (lhs.first == rhs.first) return lhs.second &lt; rhs.second;    else return lhs.first &lt; rhs.first;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用网页用户限制的解除</title>
      <link href="/2021/11/15/Front/%E8%A7%A3%E9%99%A4csdn%E4%B8%8D%E8%83%BD%E5%A4%8D%E5%88%B6%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2021/11/15/Front/%E8%A7%A3%E9%99%A4csdn%E4%B8%8D%E8%83%BD%E5%A4%8D%E5%88%B6%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="解决CSDN的复制粘贴限制"><a href="#解决CSDN的复制粘贴限制" class="headerlink" title="解决CSDN的复制粘贴限制"></a>解决CSDN的复制粘贴限制</h2><p>CSDN站曾经是一个非常好的计算机技术交流平台。但现在却开始商业化，为了用户数量不择手段，现在居然连复制代码都要限制（我现在已经不喜欢它了）。</p><p>为了复制一小段代码就注册个账号是很麻烦的，而且CSDN对用户数据安全也没那么上心。所以我总结了以下几个好用的方法。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>第一步：键入F12，打开浏览器开发者工具。选择要复制的代码块。在开发者工具显示的的源码中，会自动定位到如下位置。</p><pre><code class="lang-html">&lt;code class=&quot;prism language-cpp&quot;&gt;...&lt;/code&gt;</code></pre><p>第二步：在开发者工具的控制台(console)中，输入如下JavaScript命令，替换getElementByClassName()方法中的字符串为上面html中code class字符串的内容，想要复制的代码会显示在控制台的输出中。</p><pre><code class="lang-javascript">[...document.getElementsByClassName(&quot;prism language-cpp&quot;)].forEach(i=&gt;console.log(i.innerText))</code></pre><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>在控制台输入</p><pre><code class="lang-javascript">(function()&#123;    var code = document.getElementsByTagName(&#39;code&#39;);    for(var i = 0; i &lt; code.length; ++i)  &#123;        code[i].style.userSelect=&#39;text&#39;;    &#125;&#125;)();</code></pre><p>这样就能编辑代码块中的内容了，也就能复制代码了。可以建一个收藏夹，每次点击收藏夹时就会运行这段代码。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网页前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网页内容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educoder 实训平台评测程序代码的获取</title>
      <link href="/2021/11/11/Operation%20System/Educoder%20%E8%AF%84%E6%B5%8B%E7%A8%8B%E5%BA%8F/"/>
      <url>/2021/11/11/Operation%20System/Educoder%20%E8%AF%84%E6%B5%8B%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="实训地址"><a href="#实训地址" class="headerlink" title="实训地址"></a>实训地址</h1><p><a href="https://www.educoder.net/paths/2104">操作系统 (educoder.net)</a></p><h1 id="分析历程"><a href="#分析历程" class="headerlink" title="分析历程"></a>分析历程</h1><h2 id="一，实训机上偶然的发现"><a href="#一，实训机上偶然的发现" class="headerlink" title="一，实训机上偶然的发现"></a>一，实训机上偶然的发现</h2><p>在修改输入答案文件夹中的答案时，我误删了<code>/data/workspace/edu/step1/test1</code>文件。再点击评测时，发现评测界面输出一行红字<font color = red face = "宋体">“评测文件被修改”</font>。说明实训项目可能是依赖test1文件进行评测的。</p><p>尝试运行test1，发现权限不够。做实训时，用户是以<code>root</code>身份登录的。所以输入<code>ls -la</code>命令查看test的权限。果然没分给我。于是使用<code>chmod -R 777 test1</code>命令更改文件夹权限，接着输入<code>./test1</code>运行之。运行结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/shixun/shixunRE0.png" alt="运行结果"></p><p>果然，和平常做实训时的评测结果一样。由python的报错可知，实训使用python脚本进行评测。那么，test1文件应该是python封装的可执行文件。</p><h2 id="二，本机进行分析"><a href="#二，本机进行分析" class="headerlink" title="二，本机进行分析"></a>二，本机进行分析</h2><p>用某种方法，将test1文件导出到本机上。使用python的archive_viewer.py脚本，对test1文件进行分析。</p><pre><code class="lang-sh">python &lt;archive_viewer.py的路径&gt; &lt;待分析评测文件&gt;</code></pre><p>下图是部分结果。</p><p>archiev_viewer.py的位置（site-packages/PyInstaller/utils/cliutils/archive_viewer.py）</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/shixun/shixunRE1.png" alt="archive_viewer.py运行结果"></p><p>观察发现图中(12469, 1669, 4892, 1 ,’s’, ‘test1’)这一组就是test1的python代码。</p><p>输入<code>x test1</code>命令将其提取出来。</p><p>使用wxmedit软件，发现其内容如下。</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/shixun/shixunRE2.png" alt="test1的内容"></p><p>E3开头，说明是比较标准的python代码二进制文件。但是，如果我们直接用python的逆向器，是无法对这个文件进行反编译的。所以，要对这个文件进行一些补充。主要补充python解释器的版本号信息和代码的时间戳。在开头补充16B代码</p><pre><code class="lang-c">42 0D 0D 0A 00 00 00 00 70 79 69 30 10 01 00 00</code></pre><p>即可。</p><p>补充后的代码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/shixun/shixunRE3.png" alt="test1补充后的内容"></p><p>然后，将test1增加.pyc扩展名。重命名为test1.pyc。使用python的uncompyle库进行反编译。</p><p>如果没有安装ucompyle工具，那么需要在python cmd中输入如下命令下载：</p><pre><code class="lang-sh">pip install uncompyle</code></pre><p>然后使用uncompyle反编译，将输出文件保存到test1.py</p><pre><code class="lang-sh">uncompyle6 test1.pyc &gt; test1.py</code></pre><p>使用打开test1.py文件，惊喜发生了，我们获得了评测程序的代码。该实训评测代码如下：</p><p>从代码中，可以知道评测机制，和所有问题的答案。</p><pre><code class="lang-python"># uncompyle6 version 3.8.0# Python bytecode 3.7.0 (3394)# Decompiled from: Python 3.8.12 (default, Oct 12 2021, 03:01:40) [MSC v.1916 64 bit (AMD64)]# Embedded file name: test1.py# Compiled at: 1995-09-28 00:18:56# Size of source mod 2**32: 272 bytesimport osif os.path.exists(&#39;/root/gdb.log&#39;):    file = open(&#39;/root/gdb.log&#39;, encoding=&#39;utf-8&#39;).read()    file = file.replace(&#39;\n&#39;, &#39;&#39;).replace(&#39; &#39;, &#39;&#39;).replace(&#39;\t&#39;, &#39;&#39;)    if &#39;i_zone=&#123;112,0,0,0,0,0,0,0,0&#125;,i_wait=0x0&lt;startup_32&gt;,i_atime=0,i_ctime=0,i_dev=768,i_num=1&#39; in file:        print(&#39;函数find_entry第1次开始运行时，参数dir所对应的i节点正确&#39;)    else:        print(&#39;函数find_entry第1次开始运行时，参数dir所对应的i节点错误&#39;)else:    if &#39;bread(dev=768,block=112)atbuffer.c:271271&#123;1:current-&gt;pid=1&#39; in file:        print(&#39;函数bread第1次开始运行时，参数block的值正确&#39;)    else:        print(&#39;函数bread第1次开始运行时，参数block的值错误&#39;)    if &#39;inode=1,name=&quot;.&quot;,&#39; in file:        print(&#39;函数match第1次开始运行时，参数de指向的目录项的i节点号和名字正确&#39;)    else:        print(&#39;函数match第1次开始运行时，参数de指向的目录项的i节点号和名字错误&#39;)    if &#39;inode=48,name=&quot;usr&#39; in file:        print(&#39;函数match第8次开始运行时，参数de指向的目录项的i节点号和名字正确&#39;)    else:        print(&#39;函数match第8次开始运行时，参数de指向的目录项的i节点号和名字错误&#39;)    if &#39;iget(dev=768,nr=48)atinode.c:245245&#123;1:current-&gt;pid=1&#39; in file:        print(&#39;函数iget第1次开始运行时，参数nr的值正确&#39;)    else:        print(&#39;函数iget第1次开始运行时，参数nr的值错误&#39;)    if &#39;bread(dev=768,block=6)atbuffer.c:271271&#123;1:current-&gt;pid=1&#39; in file:        print(&#39;函数bread第2次开始运行时，参数block的值正确&#39;)    else:        print(&#39;函数bread第2次开始运行时，参数block的值错误&#39;)    if &#39;i_zone=&#123;987,0,0,0,0,0,0,0,0&#125;,i_wait=0x0&lt;startup_32&gt;,i_atime=0,i_ctime=0,i_dev=768,i_num=48,i_count=1,i_lock=0&#39; in file:        print(&#39;函数find_entry第2次开始运行时，参数dir所对应的i节点正确&#39;)    else:        print(&#39;函数find_entry第2次开始运行时，参数dir所对应的i节点错误&#39;)    if &#39;i_zone=&#123;4721,0,0,0,0,0,0,0,0&#125;,i_wait=0x0&lt;startup_32&gt;,i_atime=0,i_ctime=0,i_dev=768,i_num=131,i_count=1,i_lock=0&#39; in file:        print(&#39;函数find_entry第3次开始运行时，参数dir所对应的i节点正确&#39;)    else:        print(&#39;函数find_entry第3次开始运行时，参数dir所对应的i节点错误&#39;)    if &#39;inode=134,name=&quot;hello.c&#39; in file:        print(&#39;函数match匹配到/usr/root/hello.c的目录项时，参数de指向的目录项的i节点正确&#39;)    else:        print(&#39;函数match匹配到/usr/root/hello.c的目录项时，参数de指向的目录项的i节点错误&#39;)    if &#39;open_namei(pathname=0x18407&quot;/usr/root/hello.c&quot;,flag=0,mode=32768,res_inode=0xffffb4&#39; in file:        if &#39;i_ctime=0,i_dev=768,i_num=134,i_count=1,i_lock=0&#39; in file:            print(&#39;函数open_namei结束时，变量res_inode指向的i节点正确&#39;)        else:            print(&#39;函数open_namei结束时，变量res_inode指向的i节点错误&#39;)    else:        print(&#39;未检测到gdb.log&#39;)    file = open(&#39;第一关.txt&#39;, &#39;r&#39;, encoding=&#39;utf-8&#39;)    f = file.read().replace(&#39;\n&#39;, &#39;&#39;)    file.close()    a = &#39;1.&#39;    b = &#39;2.&#39;    c = &#39;3.&#39;    d = &#39;4.&#39;    e = &#39;5.&#39;    g = &#39;6.&#39;    h = &#39;7.&#39;    i = &#39;8.&#39;    j = &#39;9.&#39;    one = f[f.index(a):f.index(b)]    two = f[f.index(b):f.index(c)]    three = f[f.index(c):f.index(d)]    four = f[f.index(d):f.index(e)]    five = f[f.index(e):f.index(g)]    six = f[f.index(g):f.index(h)]    seven = f[f.index(h):f.index(i)]    eight = f[f.index(i):f.index(j)]    nine = f[f.index(j):]    one_answer_1 = one.split(&#39;(&#39;)[1].split(&#39;)&#39;)[0]    one_answer_2 = one.split(&#39;(&#39;)[2].split(&#39;)&#39;)[0]    if one_answer_1 == &#39;1&#39;:        if one_answer_2 == &#39;112&#39;:            print(&#39;第一题答案正确&#39;)        else:            print(&#39;第一题答案错误&#39;)        two_answer_1 = two.split(&#39;(&#39;)[1].split(&#39;)&#39;)[0]        if two_answer_1 == &#39;112&#39;:            print(&#39;第二题答案正确&#39;)    else:        print(&#39;第二题答案错误&#39;)three_answer_1 = three.split(&#39;(&#39;)[1].split(&#39;)&#39;)[0]three_answer_2 = three.split(&#39;(&#39;)[2].split(&#39;)&#39;)[0]if three_answer_1 == &#39;1&#39;:    if three_answer_2 == &#39;&quot;.&quot;&#39;:        print(&#39;第三题答案正确&#39;)    else:        print(&#39;第三题答案错误&#39;)else:    four_answer_1 = four.split(&#39;(&#39;)[1].split(&#39;)&#39;)[0]    four_answer_2 = four.split(&#39;(&#39;)[2].split(&#39;)&#39;)[0]    if four_answer_1 == &#39;48&#39;:        if four_answer_2 == &#39;&quot;usr&quot;&#39;:            print(&#39;第四题答案正确&#39;)        else:            print(&#39;第四题答案错误&#39;)        five_answer_1 = five.split(&#39;(&#39;)[1].split(&#39;)&#39;)[0]        if five_answer_1 == &#39;48&#39;:            print(&#39;第五题答案正确&#39;)    else:        print(&#39;第五题答案错误&#39;)six_answer_1 = six.split(&#39;(&#39;)[1].split(&#39;)&#39;)[0]six_answer_2 = six.split(&#39;(&#39;)[2].split(&#39;)&#39;)[0]if six_answer_1 == &#39;48&#39;:    if six_answer_2 == &#39;987&#39;:        print(&#39;第六题答案正确&#39;)    else:        print(&#39;第六题答案错误&#39;)else:    seven_answer_1 = seven.split(&#39;(&#39;)[1].split(&#39;)&#39;)[0]    seven_answer_2 = seven.split(&#39;(&#39;)[2].split(&#39;)&#39;)[0]    if seven_answer_1 == &#39;131&#39;:        if seven_answer_2 == &#39;4721&#39;:            print(&#39;第七题答案正确&#39;)        else:            print(&#39;第七题答案错误&#39;)        eight_answer_1 = eight.split(&#39;(&#39;)[1].split(&#39;)&#39;)[0]        if eight_answer_1 == &#39;134&#39;:            print(&#39;第八题答案正确&#39;)    else:        print(&#39;第八题答案错误&#39;)nine_answer_1 = nine.split(&#39;(&#39;)[1].split(&#39;)&#39;)[0]nine_answer_2 = nine.split(&#39;(&#39;)[2].split(&#39;)&#39;)[0]if nine_answer_1 == &#39;134&#39; and nine_answer_2 == &#39;4743&#39;:    print(&#39;第九题答案正确&#39;)else:    print(&#39;第九题答案错误&#39;)# okay decompiling test1.pyc</code></pre>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 实训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Educoder </tag>
            
            <tag> 模拟实训 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 逆向分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educoder 操作系统实训7.x实验</title>
      <link href="/2021/11/08/Operation%20System/Educoder%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%AE%AD7.x/"/>
      <url>/2021/11/08/Operation%20System/Educoder%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%AE%AD7.x/</url>
      
        <content type="html"><![CDATA[<h1 id="实训地址"><a href="#实训地址" class="headerlink" title="实训地址"></a>实训地址</h1><p><a href="https://www.educoder.net/paths/2104">操作系统 (educoder.net)</a></p><h1 id="实训7-1：文件系统的静态结构"><a href="#实训7-1：文件系统的静态结构" class="headerlink" title="实训7.1：文件系统的静态结构"></a>实训7.1：文件系统的静态结构</h1><h2 id="第一关：文件-usr-root-hello-c-的手动分析"><a href="#第一关：文件-usr-root-hello-c-的手动分析" class="headerlink" title="第一关：文件 /usr/root/hello.c 的手动分析"></a>第一关：文件 /usr/root/hello.c 的手动分析</h2><h3 id="补充：Linux文件系统静态结构简图"><a href="#补充：Linux文件系统静态结构简图" class="headerlink" title="补充：Linux文件系统静态结构简图"></a>补充：Linux文件系统静态结构简图</h3><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/shixun/rootimage-blocks.png" alt="Linux文件系统的静态结构"></p><h3 id="补充：Linux文件访问过程简图"><a href="#补充：Linux文件访问过程简图" class="headerlink" title="补充：Linux文件访问过程简图"></a>补充：Linux文件访问过程简图</h3><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/shixun/Linuxfilesystem-1.png" alt="Linux文件系统简图"></p><h3 id="实验方法和答案"><a href="#实验方法和答案" class="headerlink" title="实验方法和答案"></a>实验方法和答案</h3><p>在Linux操作系统的文件系统中，超级块相当于文件系统的地图。在超级块中保存着文件系统的属性信息、磁盘布局和资源使用情况等信息。文件系统通过超级块了解磁盘的布局，查找已用和可用资源等。超级块又相当于入口，文件系统的操作通常从超级块开始。</p><p>超级块的数据结构如下</p><pre><code class="lang-c">struct super_block &#123;    unsigned short s_ninodes; /* i节点数 */    unsigned short s_nzones; /* 逻辑块数，或称为区块数 */    unsigned short s_imap_blocks; /* i节点位图所占块数 */    unsigned short s_zmap_blocks; /* 逻辑块位图所占块数 */    unsigned short s_firstdatazone; /* 数据区第一个逻辑块块号 */    unsigned short s_log_zone_size; /* Log_2(磁盘块数/逻辑块) */    unsigned long s_max_size; /* 最大文件长度 */    unsigned short s_magic; /* 文件系统幻数 *//* These are only in memory */    struct buffer_head * s_imap[8];    struct buffer_head * s_zmap[8];    unsigned short s_dev;    struct m_inode * s_isup;    struct m_inode * s_imount;    unsigned long s_time;    struct task_struct * s_wait;    unsigned char s_lock;    unsigned char s_rd_only;    unsigned char s_dirt;&#125;;</code></pre><p>用<strong>hexdump</strong>打开rootimage-0.11，输入如下命令，查看超级块的内容。</p><pre><code class="lang-c">hexdump -s 0x400 -n 1024 -C rootimage-0.11</code></pre><p>索引节点区就是文件系统静态结构图中的<strong>i</strong>节点区。根据上面的文件系统静态结构图，可算出i节点区是第五块，地址为$0\text{x}400 \times 0\text{x}5 = 0\text{x}1400$（从0开始编号）。</p><p>查看0号索引节点（i节点区）内容</p><pre><code class="lang-c">hexdump -s 0x1400 -n 32 -C rootimage-0.11</code></pre><p>显示内容如下，注意内容是<strong>小端存储</strong>的。</p><pre><code class="lang-c">00001400  ed 41 00 00 80 00 00 00  0c 7a 65 5f 00 08 70 00  |.A.......ze_..p.|00001410  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|00001420</code></pre><pre><code class="lang-c">1.在超级块中，i 节点位图所占的块数是多少？(1)区块位图所占的块数是多少？(2)数据区的第一个区块的编号是多少？(0x70)索引节点区的第一个数据块的编号和起始地址是多少？(5)(0x1400)</code></pre><p>一号索引节点位置在0x70，所以计算出它的起始地址$0 + 0\text{x}70 \times 0\text{x}400 = 0\text{x}1\text{c}000$</p><pre><code class="lang-c">2.1 号索引节点的第一个区块的编号和起始地址分别是多少？(0x70)(0x1c000)</code></pre><p>目录项本质上是一类特殊的文件，包含了子目录和自身的一些信息，并且该文件和一般文件都存储在数据区中，因此如果要想知道某个目录的索引节点编号，你只需要找到父目录项文件存储在数据区的位置(地址)，然后输出父目录文件中的数据，就可以得到子目录的相关信息。</p><p>显示数据区的内容。</p><pre><code class="lang-sh">hexdump -s 0x1c000 -n 1024 -C rootimage-0.11</code></pre><p>内容如下</p><pre><code class="lang-c">0001c000  01 00 2e 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|0001c010  01 00 2e 2e 00 00 00 00  00 00 00 00 00 00 00 00  |................|0001c020  02 00 62 69 6e 00 00 00  00 00 00 00 00 00 00 00  |..bin...........|0001c030  0f 00 64 65 76 00 00 00  00 00 00 00 00 00 00 00  |..dev...........|0001c040  23 00 65 74 63 00 00 00  00 00 00 00 00 00 00 00  |#.etc...........|0001c050  2e 00 72 6f 6f 74 00 00  00 00 00 00 00 00 00 00  |..root..........|0001c060  2f 00 74 6d 70 00 00 00  00 00 00 00 00 00 00 00  |/.tmp...........|0001c070  30 00 75 73 72 00 00 00  00 00 00 00 00 00 00 00  |0.usr...........|0001c080  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|*0001c400</code></pre><p>发现了文件目录和文件名。</p><p>目录项的数据结构如下：</p><pre><code class="lang-c">/* 定义在include/linux/fs.h中 */#define NAME_LEN 14#define ROOT_INO 1//文件目录项结构struct dir_entry &#123;      unsigned short inode; /* i节点号 */    char name[NAME_LEN]; /* 文件名 */&#125;;</code></pre><p>注意这一行，结合目录项的数据结构，找到索引节点编号为0x30，一个索引节点占 32 字节，计算出起始地址（<strong>一定要注意：索引节点从 1 开始编号！</strong>）$0\text{x}1400 + (0\text{x}30 - 0\text{x}1) \times 0\text{x}20 = 0\text{x}19\text{e}0$</p><pre><code class="lang-c">0001c070  30 00 75 73 72 00 00 00  00 00 00 00 00 00 00 00  |0.usr...........|</code></pre><pre><code class="lang-c">3.目录 /usr 的索引节点的编号和起始地址分别是多少？(0x30)(0x19e0)</code></pre><p>查看/usr目录索引节点的内容，一个索引节点占 32 字节，所以显示32个字节即可。</p><pre><code class="lang-sh">hexdump -s 0x19e0 -n 32 -C rootimage-0.11</code></pre><p>显示内容如下</p><pre><code class="lang-c">000019e0  ed 41 00 00 60 00 00 00  b4 5d 65 5f 00 06 db 03  |.A..`....]e_....|000019f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|00001a00</code></pre><p>iNode的结构如下</p><pre><code class="lang-c">struct d_inode &#123;    unsigned short i_mode; /* 文件的类型和属性 */    unsigned short i_uid; /* 文件宿主的用户id */    unsigned long i_size; /* 文件长度（字节） */    unsigned long i_time; /* 修改时间 */    unsigned char i_gid; /* 文件宿主的主id */    unsigned char i_nlinks; /* 链接数（有多少个文件指向该节点） */    unsigned short i_zone[9];     /* 文件占用的盘上逻辑块号数组。其中zone[0] - zone[6]是直接块号     zone[7]是间接块号，zone[8]是二次（双重）间接块号。    zone是区的意思，可译成区块或逻辑块。对于设备特殊文件名的i节点，    其zone[0]存放的是改文件名所指设备的设备号。zone[0]是第一区块的编号。    */&#125;;</code></pre><p>寻找zone[0]对应的第一个区块的值为0x3db。计算起始地址$0 + 0\text{x}3\text{db} \times 0\text{x}400 = 0\text{x}\text{f}6\text{c}00$</p><pre><code class="lang-c">4.目录 /usr 的索引节点的第一个区块的编号和起始地址分别是多少？(0x03db)(0xf6c00)</code></pre><p>接下来寻找子目录root，操作与寻找/usr目录一样。</p><pre><code class="lang-c">hexdump -s 0xf6c00 -n 1024 -C rootimage-0.11hexdump -s 0x2440 -n 32 -C rootimage-0.11hexdump -s 0x49c400 -n 1024 -C rootimage-0.11hexdump -s 0x24a0 -n 32 -C rootimage-0.11hexdump -s 0x4a1c00 -n 2 -C rootimage-0.11</code></pre><pre><code class="lang-c">5.目录 /usr/root 的索引节点的编号和起始地址分别是多少？(0x0083)(0x2440)6.目录 /usr/root 的索引节点的第一个区块的编号和起始地址分别是多少？(0x1271)(0x49c400)7.文件 /usr/root/hello.c 的索引节点的编号和起始地址分别是多少？(0x0086)(0x24a0)8.文件 /usr/root/hello.c 的索引节点的第一个区块的编号和起始地址分别是多少？(0x1287)(0x4a1c00)9.文件 /usr/root/hello.c 的头两个字节是什么？(0x23)(0x69)</code></pre><h2 id="第二关：文件-etc-magic-的手动分析"><a href="#第二关：文件-etc-magic-的手动分析" class="headerlink" title="第二关：文件 /etc/magic 的手动分析"></a>第二关：文件 /etc/magic 的手动分析</h2><h3 id="实验方法"><a href="#实验方法" class="headerlink" title="实验方法"></a>实验方法</h3><p>和第一关大致相同，不再细致讲解，只给出操作</p><pre><code class="lang-sh">hexdump -s 0x400 -n 1024 -C rootimage-0.11hexdump -s 0x1400 -n 32 -C rootimage-0.11hexdump -s 0x1c000 -n 1024 -C rootimage-0.11hexdump -s 0x1840 -n 32 -C rootimage-0.11hexdump -s 0xedc00 -n 1024 -C rootimage-0.11hexdump -s 0x1920 -n 32 -C rootimage-0.11hexdump -s 0xf4000 -n 1024 -C rootimage-0.11hexdump -s 0xf5400 -n 1024 -C rootimage-0.11</code></pre><h3 id="本关答案"><a href="#本关答案" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-c">1.目录 /etc 的索引节点的编号和起始地址分别是多少？(0x0023)(0x1840)2.目录 /etc 的索引节点的第一个区块的编号和起始地址分别是多少？(0x03b7)(0xedc00)3.文件 /etc/magic 的索引节点的编号和起始地址分别是多少？(0x002a)(0x1920)4.文件 /etc/magic 的索引节点的最后一个区块的编号和起始地址分别是多少？(0x3d5)(0xf5400)5.文件 /etc/magic 的尾部包含字符串 XENIX 8086 relocatable or 80286 small model ，其起始地址是什么？(0x000f55ec)</code></pre><h2 id="第三关：硬链接和软链接"><a href="#第三关：硬链接和软链接" class="headerlink" title="第三关：硬链接和软链接"></a>第三关：硬链接和软链接</h2><h3 id="实验方法-1"><a href="#实验方法-1" class="headerlink" title="实验方法"></a>实验方法</h3><p>在bochs虚拟机中</p><pre><code class="lang-sh"># 创建硬链接ln hello.c hello-2.csync</code></pre><p>在Ubuntu中</p><pre><code class="lang-sh">cd images# 查看超级块内容，找到数据区第一个逻辑块的块号为0x70# 注意x86的使用的是小端表示法# i节点位图占了1个块，逻辑块位图占了2个块，从i节点区在5号块（块编号从0开始）hexdump -s 0x400 -n 1024 -C rootimage-0.11# 查看i索引节点节点区内容，i节点区的起始位置在0 + 0x400 * 0x5 = 0x1400hexdump -s 0x1400 -n 1024 -C rootimage-0.11# 查看文件占用的逻辑块号，计算文件区块的地址为0x70 * 0x400 = 0x1c000hexdump -s 0x1c000 -n 1024 -C rootimage-0.11# 看到usr的目录项，根据目录项结构，找到i节点号为0x30，由此找到usr目录子目录的i节点地址为0x1400 + 0x20 * (0x30 - 0x1)=0x19e0hexdump -s 0x19e0 -n 32 -C rootimage-0.11# 找到usr目录子目录的数据地址0 + 0x3db * 0x400 = 0xf6c00hexdump -s 0xf6c00 -n 1024 -C rootimage-0.11# 继续重复前两步操作，查看root里面的内容hexdump -s 0x2440 -n 32 -C rootimage-0.11hexdump -s 0x49c400 -n 1024 -C rootimage-0.11# 最后，就查看到/usr/root目录中文件和目录的相关信息</code></pre><p>在bochs虚拟机中</p><pre><code class="lang-sh"># 删除hello.crm hello.csync</code></pre><p>在Ubuntu中</p><pre><code class="lang-sh"># 不用重复上面的大量操作了，直接查看即可。hexdump -s 0x49c400 -n 1024 -C rootimage-0.11# 保存评测用的history文件history &gt; /data/workspace/myshixun/history4.log</code></pre><h3 id="本关答案-1"><a href="#本关答案-1" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">1.(0x49c430)(0x86)2.(0x49c440)(0x86)3.(0x00)(0x00)4.(0x86)(0x00)</code></pre><h2 id="第四关：文件的删除和恢复"><a href="#第四关：文件的删除和恢复" class="headerlink" title="第四关：文件的删除和恢复"></a>第四关：文件的删除和恢复</h2><h3 id="实验方法-2"><a href="#实验方法-2" class="headerlink" title="实验方法"></a>实验方法</h3><pre><code class="lang-sh">hexdump -s 0x49c400 -n 1024 -C rootimage-0.11hexdump -s 0x24a0 -n 32 -C rootimage-0.11hexdump -s 4a1c00 -n 1024 -C rootimage-0.11hexdump -s 4a1c00 -n 1024 -C rootimage-0.11</code></pre><h3 id="本关答案-2"><a href="#本关答案-2" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">1.(0x49c430)2.(0x24a0)3.(0x4a1c00)4.(1)(0x86)(0x00)5.(否)6.(否)7.(是)(是)</code></pre><h1 id="实训7-2：文件访问类系统调用的分析"><a href="#实训7-2：文件访问类系统调用的分析" class="headerlink" title="实训7.2：文件访问类系统调用的分析"></a>实训7.2：文件访问类系统调用的分析</h1><h2 id="第一关：open-系统调用的工作过程分析"><a href="#第一关：open-系统调用的工作过程分析" class="headerlink" title="第一关：open 系统调用的工作过程分析"></a>第一关：open 系统调用的工作过程分析</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p>除了问地址的值以外，其他的答案都是以十进制来写</p></li><li><p>分析hello.c的文件打开过程时，分析的时刻是你在Linux操作系统输入回车后的过程，输入回车之前的各个函数find_entry请不要分析，因为那时候还没有真正打开hello.c文件。</p></li></ol><h3 id="实验方法-3"><a href="#实验方法-3" class="headerlink" title="实验方法"></a>实验方法</h3><pre><code class="lang-sh"># 终端一，常规操作cp /data/workspace/myshixun/exp1/2.tgz ~/os/cd ~/os/linux-0.11-labtar -zxvf ../2.tgzrm -rf curln -s 2 curcd cur/linuxmakecd ../.../rungdb</code></pre><pre><code class="lang-sh"># 终端二cd ~/os/linux-0.11-lab./mygdbb sys_openccdisable 2b find_entrycp **dir# 函数 find_entry 第 1 次开始运行时，参数 dir 所对应的 i 节点的编号就是i_num的值。# 该 i 节点的第一个数据块的块号就是zone[0]的值。b breaddisable 3cp block # 这条命令找到参数block的值b matchdisable 4cp *de # 找到de指向i节点的信息cccccccp *de # 找到运行8次后de指向i节点的信息b igetdisable 5cp nrenable 4disable 6cp blockenable 3disable 4cp **dircp **dirdisable 3enable 5ccccp *deb namei.c:409disable 5cp **res_inode</code></pre><h3 id="本关答案-3"><a href="#本关答案-3" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">1.函数 find_entry 第 1 次开始运行时，参数 dir 所对应的 i 节点的编号是什么？(1)该 i 节点的第一个数据块的块号是什么？(112)2.函数 bread 第 1 次开始运行时，参数 block 的值是什么？(112)3.函数 match 第 1 次开始运行时，参数 de 指向的目录项的 i 节点号和名字分别是什么？(1)(&quot;.&quot;)4.函数 match 第 8 次开始运行时，参数 de 指向的目录项的 i 节点号和名字分别是什么？(48)(&quot;usr&quot;)5.函数 iget 第 1 次开始运行时，参数 nr 的值是什么？(48)6.函数 find_entry 第 2 次开始运行时，参数 dir 所对应的 i 节点的编号是什么？(48)该 i 节点的第一个数据块的块号是什么？(987)7.函数 find_entry 第 3 次开始运行时，参数 dir 所对应的 i 节点的编号是什么？(131)该 i 节点的第一个数据块的块号是什么？(4721)8.函数 match 匹配到 /usr/root/hello.c 的目录项时，参数 de 指向的目录项的 i 节点号是什么？(134)9.函数 open_namei 结束时，变量 res_inode 指向的 i 节点的编号是什么？(134)该 i 节点的第一个数据块的块号是什么？(4743)</code></pre><h2 id="第二关：文件管理相关的内核数据结构分析"><a href="#第二关：文件管理相关的内核数据结构分析" class="headerlink" title="第二关：文件管理相关的内核数据结构分析"></a>第二关：文件管理相关的内核数据结构分析</h2><h3 id="实验方法-4"><a href="#实验方法-4" class="headerlink" title="实验方法"></a>实验方法</h3><pre><code class="lang-sh">b sys_openccb 185cp fdp currnet-&gt;filpp file_tablep inode_table</code></pre><h3 id="本关答案-4"><a href="#本关答案-4" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">1.函数 sys_open 返回的文件描述符（fd）是多少？(3)2.文件 hello.c 在进程的打开文件表中对应的数组元素的值是什么？(0x25df0)3.文件 hello.c 在读写状态信息表中的当前读写位置是多少？(0)4.文件 hello.c 在活跃文件目录表中的索引节点号是多少？(134)该索引节点的第一个数据块的块号是多少？(4743)5.当前进程的打开文件表中的有效数组元素有几个？(4)6.读写状态信息表中的有效数组元素有几个？(2)7.活跃文件目录表中的有效数组元素有几个？(6)其索引节点号分别是多少？(1 15 26 48 131 134)（第七题的索引节点号之间用空格分隔开！！！）</code></pre><h2 id="第四关：read-系统调用的分析"><a href="#第四关：read-系统调用的分析" class="headerlink" title="第四关：read 系统调用的分析"></a>第四关：read 系统调用的分析</h2><h3 id="实验方法-5"><a href="#实验方法-5" class="headerlink" title="实验方法"></a>实验方法</h3><pre><code class="lang-sh">b sys_readccp file_tablep inode_tableb breadcp block</code></pre><h3 id="本关答案-5"><a href="#本关答案-5" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">1.对 /usr/root/hello.c 的读操作刚开始时，其对应的 file 对象内存放的当前位置是什么？(0)其对应的 inode 对象内存放的第一个数据块的块号是什么？(4743)2.读 /usr/root/hello.c 时，传递给 bread 函数的参数 block 是什么？(4743)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 实训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Educoder </tag>
            
            <tag> 模拟实训 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习PostgreSQL</title>
      <link href="/2021/11/07/SQL/PostgreSql/"/>
      <url>/2021/11/07/SQL/PostgreSql/</url>
      
        <content type="html"><![CDATA[<p>PostgreSQL在未创建新用户时，默认登录用户是超级用户postgres。</p><h2 id="数据库用户操作"><a href="#数据库用户操作" class="headerlink" title="数据库用户操作"></a>数据库用户操作</h2><ol><li><p>输入登录命令，输入正确的账号密码</p><pre><code class="lang-sql">psql -U postgres -d postgrespsql -U &lt;用户名&gt; -d &lt;数据库名&gt;</code></pre></li><li><p>创建数据库新用户</p><pre><code class="lang-sql">CREATE USER Username WITH PASSWORD &#39;*****&#39;;</code></pre></li><li><p>创建数据库</p><pre><code class="lang-sql">CREATE DATABASE &lt;数据库名&gt;;</code></pre></li><li><p>授予用户数据库全部权限</p><pre><code class="lang-sql">GRANT ALL PRIVILEGES ON DATABASE &lt;数据库名&gt; TO &lt;用户名&gt;;</code></pre></li><li><p>设置年月日输入格式（在线有效，离线无效）</p><pre><code class="lang-sql">SET datestyle TO &#39;DMY&#39;;</code></pre></li><li><p>删除，添加，修改属性</p><pre><code class="lang-sql">ALTER TABLE SC DROP COLUMN grade;ALTER TABLE SC ADD COLUMN grade NUMERIC(3, 0);ALTER TABLE S ALTER COLUMN sage TYPE NUMERIC(3, 0);</code></pre></li><li><p>删除，添加约束</p><pre><code class="lang-sql">ALTER TABLE S DROP CONSTRAINT &quot;s_sage_check&quot;;ALTER TABLE SC ADD CONSTRAINT &quot;sc_grade_check&quot; CHECK(grade &gt;= 0 AND grade &lt;= 100);ALTER TABLE SC ADD PRIMARY KEY(sno, cno);</code></pre></li></ol><h2 id="数据库资源操作"><a href="#数据库资源操作" class="headerlink" title="数据库资源操作"></a>数据库资源操作</h2><ol><li><p>显示所有表名称和结构</p><p>命令 :</p><pre><code class="lang-sql">\d\d &lt;TableName&gt;</code></pre></li><li><p>创建表</p><pre><code class="lang-sql">CREATE TABLE &lt;表名&gt;(&lt;列名&gt; &lt;数据类型&gt; [列级完整性约束条件][,&lt;列名&gt; &lt;数据类型&gt; [列级完整性约束条件]]…[,&lt;表级完整性约束条件&gt;…]);</code></pre></li></ol><h2 id="数据库的查询操作"><a href="#数据库的查询操作" class="headerlink" title="数据库的查询操作"></a>数据库的查询操作</h2><ol><li><p>查询的一般格式</p><pre><code class="lang-sql">SELECT [DISTINCT] &lt;目标列表达式列表&gt;FROM &lt;基本表或视图列表&gt;[WHERE &lt;条件表达式&gt;][GROUP BY &lt;列名列表&gt; [HAVING &lt;条件表达式&gt;]][ORDER BY &lt;列名&gt; [ASC|DESC]];</code></pre></li></ol><h2 id="数据库的增删改操作"><a href="#数据库的增删改操作" class="headerlink" title="数据库的增删改操作"></a>数据库的增删改操作</h2><ol><li><p>插入元组：</p><ul><li><p>不能违背完整性约束！</p></li><li><p>如果没有指定元组某个元素的值，系统默认将其赋值为空。</p></li><li><p>如果表明后添加(属性)，那么属性列的顺序可与表中不一样，只要和常量相对应即可</p></li></ul><p>语法和示例</p><pre><code class="lang-sql">INSERT INTO &lt;表名&gt;[(&lt;属性列1&gt; [,&lt;属性列2&gt;]…)]&lt;子查询&gt;;INSERT INTO S(Sno, Sname, Ssex, Sage) VALUES (&#39;S14&#39;, &#39;Tom&#39;, &#39;M&#39;);INSERT INTO S(Sno, Sname, Ssex) VALUES (&#39;S14&#39;, &#39;Tom&#39;, &#39;M&#39;);</code></pre></li><li><p>插入子查询结果：</p><p>例：计算每门课的平均分，存入如下数据库表中</p><pre><code class="lang-sql">CREATE TABLE AvgGrade(   Cno CHAR(9) PRIMARY KEY,   grade INT;);INSERT INTO AvgGrade   SELECT Cno, AVG(grade)   FROM SC   GROUP BY Cno;</code></pre></li><li><p>修改内容</p><p>语法和示例</p><pre><code class="lang-sql">UPDATE &lt;表名&gt;SET &lt;列名1&gt;=&lt;表达式1&gt; [, &lt;列名2&gt;=&lt;表达式2&gt;]…[WHERE &lt;条件表达式&gt;];UPDATE SCSET grade = grade * 1.3WHERE Cno IN   (SELECT Cno FROM C WHERE Cname = &#39;DB&#39;)</code></pre></li><li><p>删除内容</p><p>语法和示例</p><pre><code class="lang-sql">DELETE FROM &lt;表名&gt; [WHERE &lt;条件表达式&gt;];DELETE FROM SCWHERE Cno IN (SELECT Cno FROM CWHERE Cname=&#39;DB&#39;);</code></pre></li></ol><h2 id="数据库理论知识"><a href="#数据库理论知识" class="headerlink" title="数据库理论知识"></a>数据库理论知识</h2><h3 id="一，-数据库的空值"><a href="#一，-数据库的空值" class="headerlink" title="一， 数据库的空值"></a>一， 数据库的空值</h3><ol><li>一般需特殊处理，常用的空值处理方法：NULLIF(p, v) : 若p非空值，返回p，否则返回v</li><li>空值与其它值的算术运算结果为空值，如：NULL+3=NULL</li><li>空值进行比较的结果为UNKNOWN。</li><li>UNKNOWN可进行逻辑运算<ul><li>如：3&gt;NULL的结果不为真也不为假，结果为UNKNOWN</li><li>如：UNKNOWN OR TRUE=TRUE、UNKNOWN AND TRUE=UNKNOWN</li></ul></li></ol><h3 id="二，-数据库视图"><a href="#二，-数据库视图" class="headerlink" title="二， 数据库视图"></a>二， 数据库视图</h3><ol><li><p>视图</p><p>可以理解成数据库的“窗口”，是一个“虚表”，只能看到视图定义的信息，数据实际存放在基本表中。</p><p>在视图中的增删改相当于对数据的增删改。</p></li><li><p>创建视图：</p><p>语法和示例</p><pre><code class="lang-sql">CREATE [OR REPLACE] VIEW&lt;视图名&gt; [(&lt;列名1&gt;[, &lt;列名2&gt;]…)]AS &lt;子查询&gt;[WITH CHECK OPTION]; /* 防止插入非法数据 */</code></pre></li><li><p>删除视图</p><pre><code class="lang-sql">DROP VIEW &lt;视图名&gt; [CASCADE];DROP VIEW M_C1 CASCADE CONSTRAINT;</code></pre><ul><li>如选择了CASCADE，则级联删除由该视图导出的其它视图。</li><li>若未选择，则保留由其导出的视图，但这些导出的视图将无法使用，除非重新定义该视图。</li><li>SQL没有提供修改视图的方法，修改需要先删除后创建。</li></ul></li><li><p>在视图中查询和更新：与基本表的查询和更新相同</p><ul><li><p>目前多数DBMS对行列子集视图的查询能够进行正确转换，但对非行列子集视图的查询不一定能够转换</p></li><li><p>一些的视图是不可更新的，因为对这些视图的更新不能唯一地、有意义地转换成对相应基本表的更新</p></li></ul></li><li><p>视图种类：</p><p>(1) 行列子集视图</p><pre><code class="lang-sql">CREATE OR REPLACE VIEWM_S(Sno, Sname, Ssex, Sage)AS SELECT Sno, Sname, Ssex, SageFROM SWHERE Ssex=&#39;M&#39;WITH CHECK OPTION;</code></pre><p>(2) 基于多表的视图</p><pre><code class="lang-sql">CREATE OR REPLACE VIEWM_C1AS SELECT S.Sno, Sname, gradeFROM S, SCWHERE S.Sno=SC.Sno ANDS.Ssex=&#39;M&#39; ANDSC.Cno=&#39;C1&#39;;</code></pre><p>(3) 基于视图的视图</p><pre><code class="lang-sql">CREATE OR REPLACE VIEW M_C1_AAS SELECT Sno, Sname, gradeFROM M_C1WHERE grade&gt;=90;</code></pre><p>(4) 带表达式的视图</p><pre><code class="lang-sql">CREATE OR REPLACE VIEWBirth_SAS SELECT Sno, Sname, Ssex, 2021-Sage SbirthFROM S;</code></pre><p>(5) 分组视图</p><pre><code class="lang-sql">CREATE OR REPLACE VIEWS_G(Sno, Gavg)AS SELECT Sno, AVG(grade)FROM SCGROUP BY SnoORDER BY Sno ASC;</code></pre></li><li><p>为什么需要视图？</p><p>(1) 简化查询操作，一次定义，多次使用。</p><p>(2) 分别满足不同用户的需求，使不同用户从不同角度看待同一数据</p><p>(3) 提供逻辑独立性</p><p>   数据库模式对应关系：模式 $\stackrel{对应}{\rightarrow}$ 表，外模式 $\stackrel{对应}{\rightarrow}$ 视图</p><p>   应用程序使用外模式访问数据库。如果改变了表，那么只需改变模式与外模式的映射，这样应用程序就不用发生改变。</p><p>(4) 对机密数据提供安全保护</p><p>(5) 适当利用视图可以更清晰地表达查询</p></li></ol><h3 id="三，触发器"><a href="#三，触发器" class="headerlink" title="三，触发器"></a>三，触发器</h3><ol><li><p>触发器：一种<strong>完整性控制</strong>机制</p></li><li><p>定义触发器：不同数据库略有不同</p></li><li><p>应用：对外码的修改</p><p>举例：在表T上定义触发器，如修改教师工号，则级联修改C表中的教师工号。</p><pre><code class="lang-sql">CREATE OR REPLACE TRIGGER t1AFTER -- 触发时机UPDATE OF Tno ON T -- 触发事件FOR EACH ROW -- 触发器类型：行级触发器BEGIN -- 触发器执行的动作   UPDATE C SET Tno=:NEW.Tno   WHERE Tno=:OLD.TnoEND;</code></pre><p>注释：</p><ul><li><p>Before：触发事件执行之前调用触发器。</p></li><li><p>After：触发事件执行之后调用触发器。</p></li><li><p>NEW：数据类型是RECORD。对于行级触发器，它存有INSERT或UPDATE操作产生的新的数据行。对于语句级触发器，它的值是NULL。</p></li><li><p>OLD：数据类型是RECORD。对于行级触发器，它存有被UPDATE或DELETE操作修改或删除的旧的数据行。对于语句级触发器，它的值是NULL。</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 课程实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educoder 操作系统实训6.x实验</title>
      <link href="/2021/11/03/Operation%20System/Educoder%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%AE%AD6.x/"/>
      <url>/2021/11/03/Operation%20System/Educoder%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%AE%AD6.x/</url>
      
        <content type="html"><![CDATA[<h1 id="实训地址"><a href="#实训地址" class="headerlink" title="实训地址"></a>实训地址</h1><p><a href="https://www.educoder.net/paths/2104">操作系统 (educoder.net)</a></p><h1 id="实训6-1：块设备访问"><a href="#实训6-1：块设备访问" class="headerlink" title="实训6.1：块设备访问"></a>实训6.1：块设备访问</h1><h2 id="第一关：文件的读取过程分析"><a href="#第一关：文件的读取过程分析" class="headerlink" title="第一关：文件的读取过程分析"></a>第一关：文件的读取过程分析</h2><h3 id="实验方法"><a href="#实验方法" class="headerlink" title="实验方法"></a>实验方法</h3><pre><code class="lang-sh">cp /data/workspace/myshixun/exp1/2.tgz ~/os/cd ~/os/linux-0.11-labtar -zxvf ../2.tgzrm -rf curln -s 2 curcd cur/linuxmakecd ../.../rungdb</code></pre><pre><code class="lang-sh">b sys_readc# 然后回到bochs，按下Enter键cp/x buf# 此时找到用户缓冲区地址b breadcb add_requestcp *reqp *devb hd_outcb read_intrcnx/8bx 0x3fcc00nnx/8bx 0x3fcc00b wake_updisable 6disable 5disable 4disable 3disable 2cb schedulecccp task[next]-&gt;pidp c</code></pre><h3 id="本关答案"><a href="#本关答案" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">1.函数 sys_read 的参数中记录的用户缓冲区地址（段内偏移）是多少？(0x254fb)2.函数 bread 的参数中记录的硬盘数据块号是多少？(4743)3.函数 add_request 执行时，硬盘请求队列头指针的值是多少？所添加请求的扇区号、扇区数、和对应系统缓冲区的地址分别是多少？(0x0)(9486)(2)(0x3fcc00)4.函数 hd_out 的参数中记录的硬盘柱面号、磁头号、扇区号分别是多少？(237)(0)(7)5.硬盘读中断处理函数 read_intr 第一次开始执行时，上述系统缓冲区的头 8 个字节是什么？(0x00)(0x00)(0x00)(0x00)(0x00)(0x00)(0x00)(0x00)6.在该函数读取了硬盘控制器的数据后，该系统缓冲区的头 8 个字节是什么？(0x23)(0x69)(0x6e)(0x63)(0x6c)(0x75)(0x64)(0x65)7.1 号进程被唤醒时，是在几号进程？(0)8.1 号进程后来被调度程序重新选中时，它的剩余时间片是多少？(13)</code></pre><h2 id="第二关：第一次读硬盘的过程分析"><a href="#第二关：第一次读硬盘的过程分析" class="headerlink" title="第二关：第一次读硬盘的过程分析"></a>第二关：第一次读硬盘的过程分析</h2><h3 id="实验方法-1"><a href="#实验方法-1" class="headerlink" title="实验方法"></a>实验方法</h3><pre><code class="lang-sh">b breadcb add_requestcp *devp *reqb hd_outcb read_intrcx/8bx 0x3ffc00b 260disable 5disable 4disable 3disable 2cx/8bx 0x3ffc00</code></pre><h3 id="本关答案-1"><a href="#本关答案-1" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">1.bochs 虚拟机的硬盘镜像文件的头8个字节是什么？(eb)(3c)(90)(4d)(53)(44)(4f)(53)2.函数 bread 的参数中记录的硬盘数据块号是多少？(0)3.函数 add_request 执行时，硬盘请求队列头指针的值是多少？(0x0)所添加请求的扇区号、扇区数、和对应系统缓冲区的地址分别是多少？(0)(2)(0x3ffc00)4.函数 hd_out 的参数中记录的硬盘柱面号、磁头号、扇区号分别是多少？(0)(0)(1)5.硬盘读中断处理函数 read_intr 第一次开始执行时，上述系统缓冲区的头 8 个字节是什么？(0x00)(0x00)(0x00)(0x00)(0x00)(0x00)(0x00)(0x00)6.在该函数读取了硬盘控制器的数据后，该系统缓冲区的头 8 个字节是什么？(0xeb)(0x3c)(0x90)(0x4d)(0x53)(0x44)(0x4f)(0x53)</code></pre><h2 id="第三关：编写一个显示文件内容的程序"><a href="#第三关：编写一个显示文件内容的程序" class="headerlink" title="第三关：编写一个显示文件内容的程序"></a>第三关：编写一个显示文件内容的程序</h2><h3 id="实验方法-2"><a href="#实验方法-2" class="headerlink" title="实验方法"></a>实验方法</h3><p>编写如图所示的代码，将代码放入虚拟机中，按要求在/etc/rc中添加一行文字<code>/usr/root/a.out</code>（a.out处是可执行文件的名字），如果编译时指定了文件名，就是指定的可执行文件名。代码之外的其它操作见<a href="https://redleaves699.github.io/2021/10/07/Educoder%20操作系统实训4.x/#第三关：可执行文件的执行">这里</a>。</p><p>修改得到的<code>/etc/rc</code>文件为</p><pre><code class="lang-sh">/etc/update &amp;echo &quot;/dev/hd0 /&quot; &gt; /etc/mtabecho &quot;Ok. &quot;/usr/root/a.out</code></pre><p>mycat代码为</p><pre><code class="lang-c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#define MSG_LEN 80#define FILE_FROM &quot;/usr/root/hello.c&quot;#define FILE_TO &quot;/usr/root/hello-new.c&quot;int main() &#123;    char msg[MSG_LEN + 10];    int fd, num;    printf(&quot;\n\rHi, press ENTER to continue...\n\r&quot;);    read(0, msg, 1);    if ((fd = open(FILE_FROM, O_RDONLY, 0)) &lt; 0) &#123;        printf(&quot;Open file error.\n\r&quot;);        exit(0);    &#125;    if ((num = read(fd, msg, MSG_LEN)) &lt; 0) &#123;        printf(&quot;Read file error.\n\r&quot;);        exit(0);    &#125;    close(fd);    msg[num] = 0;    printf(&quot;Content of file \&quot;%s\&quot;:\n\r---\n\r%s---\n\r&quot;, FILE_TO, msg);    return 0;&#125;</code></pre><h3 id="本关答案-2"><a href="#本关答案-2" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">答案正确</code></pre><h2 id="第四关：版本-0-内核中文件的读取过程分析"><a href="#第四关：版本-0-内核中文件的读取过程分析" class="headerlink" title="第四关：版本 0 内核中文件的读取过程分析"></a>第四关：版本 0 内核中文件的读取过程分析</h2><h3 id="实验方法-3"><a href="#实验方法-3" class="headerlink" title="实验方法"></a>实验方法</h3><p>本关操作建立在第三关的基础上。</p><pre><code class="lang-sh">b do_execveccommands 2p current-&gt;start_code + filenameendcc# 此时发现正要执行的程序是/usr/root/a.outb sys_read# 执行continue调试命令后，sys_read读入a.outc# 再次执行continue调试命令cp/x bufb add_requestcp *reqp dev-&gt;current_requestp req-&gt;sectorp req-&gt;nr_sectorsp req-&gt;bufferb wake_updisable 2disable 3disable 4cb schedulecccsp c</code></pre><h3 id="本关答案-3"><a href="#本关答案-3" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">1.函数 sys_read 的参数中记录的用户缓冲区地址（段内偏移）是多少？(0x3fffebc)2.函数add_request执行时，硬盘请求队列头指针的值是多少？(0x0)所添加请求的扇区号、扇区数、和对应系统缓冲区的地址分别是多少？(9486)(2)(0x3c8800)3.该进程被唤醒时，是在几号进程？(0)4.该进程后来被调度程序重新选中时，它的剩余时间片是多少？(15)</code></pre><h1 id="实训6-2：对字符设备的访问"><a href="#实训6-2：对字符设备的访问" class="headerlink" title="实训6.2：对字符设备的访问"></a>实训6.2：对字符设备的访问</h1><h2 id="第一关：键盘的读取过程分析-不是自己做的"><a href="#第一关：键盘的读取过程分析-不是自己做的" class="headerlink" title="第一关：键盘的读取过程分析(不是自己做的)"></a>第一关：键盘的读取过程分析(不是自己做的)</h2><h2 id="实验方法-4"><a href="#实验方法-4" class="headerlink" title="实验方法"></a>实验方法</h2><pre><code class="lang-sh">b sys_readcb tty_readcp tty_table[0].read_qx/3i keyboard_interruptb *0x16d1dc# (在虚拟机里enter一下)p tty_table[0].read_qb do_tty_interruptcp tty_table[0].read_qp current-&gt;start_code  + bufp tty_table[0].secondaryb wake_upcp tty_table[0].read_qp tty_table[0].secondaryp current-&gt;start_code  + bufb tty_io.c:288cp tty_table[0].secondaryx/2bx 0x40254fb</code></pre><h2 id="本关答案-4"><a href="#本关答案-4" class="headerlink" title="本关答案"></a>本关答案</h2><pre><code class="lang-sh">1.函数 sys_read 的参数中记录的用户缓冲区地址（段内偏移）是多少？(0x254fb)2.函数 tty_read 开始运行时，0 号终端的 read_q 队列的头指针（数组下标）和尾指针分别是多少？(0)(0)3.键盘中断处理程序开始运行时，0 号终端的 read_q 队列的头指针和尾指针分别是多少？(0)(0)4.函数 do_tty_interrupt 开始运行时，0 号终端的 read_q 队列的头指针和尾指针分别是多少？(1)(0)5.该队列中的未读取字符串是什么？(&quot;\r&quot;)0 号终端的 secondary 队列的头指针和尾指针分别是多少？(0)(0)6.函数 wake_up 开始运行时，0 号终端的 read_q 队列的头指针和尾指针分别是多少？(1)(1) 7.0 号终端的 secondary 队列的头指针和尾指针分别是多少？(1)(0)该队列中的未读取字符串是什么？(&quot;\n&quot;)8.函数 tty_read 结束时，0 号终端的 secondary 队列的头指针和尾指针分别是多少？(1)(1)用户缓冲区的头 2 个字节是什么？(0x0a)(0x00)注：答案需要使用引号的地方全部使用英文双引号！！！</code></pre><h2 id="第二关：从键盘的一行数据中读取一个字符-不是自己做的"><a href="#第二关：从键盘的一行数据中读取一个字符-不是自己做的" class="headerlink" title="第二关：从键盘的一行数据中读取一个字符(不是自己做的)"></a>第二关：从键盘的一行数据中读取一个字符(不是自己做的)</h2><h2 id="实验方法-5"><a href="#实验方法-5" class="headerlink" title="实验方法"></a>实验方法</h2><pre><code class="lang-sh">b tty_readcp tty_table[0].read_qb do_tty_interruptc# (在虚拟机输入abc然后enter，虚拟机不会显示，直接回到gdb继续调试)p tty_table[0].read_qp tty_table[0].secondaryb wake_upcp tty_table[0].read_qp tty_table[0].secondarycccp tty_table[0].read_qp tty_table[0].secondarycp tty_table[0].read_qp tty_table[0].secondarycccccccp tty_table[0].read_qp tty_table[0].secondarycp tty_table[0].read_qp tty_table[0].secondaryb tty_io.c:288cp tty_table[0].secondaryp current-&gt;start_code + bufx/2bx 0x40254fb</code></pre><h2 id="本关答案-5"><a href="#本关答案-5" class="headerlink" title="本关答案"></a>本关答案</h2><pre><code class="lang-sh">1.函数 tty_read 开始运行时，0 号终端的 read_q 队列的头指针（数组下标）和尾指针分别是多少？(0)(0)2.函数 do_tty_interrupt 第一次开始运行时，0 号终端的 read_q 队列的头指针和尾指针分别是多少？(1)(0)该队列中的未读取字符串是什么？(&quot;a&quot;)3.0 号终端的 secondary 队列的头指针和尾指针分别是多少？(0)(0)4.函数 wake_up 第一次开始运行时，0 号终端的 read_q 队列的头指针和尾指针分别是多少？(1)(1)0 号终端的 secondary 队列的头指针和尾指针分别是多少？(1)(0)该队列中的未读取字符串是什么？(&quot;a&quot;)5.函数 do_tty_interrupt 第三次开始运行时，0 号终端的 read_q 队列的头指针和尾指针分别是多少？(2)(1)该队列中的未读取字符串是什么？(&quot;b&quot;)6.0 号终端的 secondary 队列的头指针和尾指针分别是多少？(1)(0)7.函数 wake_up 第三次开始运行时，0 号终端的 read_q 队列的头指针和尾指针分别是多少？(2)(2)0 号终端的 secondary 队列的头指针和尾指针分别是多少？(2)(0)该队列中的未读取字符串是什么？(&quot;ab&quot;)8.函数 do_tty_interrupt 第七次开始运行时，0 号终端的 read_q 队列的头指针和尾指针分别是多少？(4)(3)该队列中的未读取字符串是什么？(&quot;\r&quot;)0 号终端的 secondary 队列的头指针和尾指针分别是多少？(3)(0)9.函数 wake_up 第七次开始运行时，0 号终端的 read_q 队列的头指针和尾指针分别是多少？(4)(4) 0 号终端的 secondary 队列的头指针和尾指针分别是多少？(4)(0)该队列中的未读取字符串是什么？(&quot;abc\n&quot;)该队列里目前有多少行？(1)10.函数 tty_read 结束时，0 号终端的 secondary 队列的头指针和尾指针分别是多少？(4)(1)该队列中的未读取字符串是什么？(&quot;bc\n&quot;)用户缓冲区的头 2 个字节是什么？(0x61)(0x00)</code></pre><h2 id="第三关：观察从键盘输入的口令-不是自己做的"><a href="#第三关：观察从键盘输入的口令-不是自己做的" class="headerlink" title="第三关：观察从键盘输入的口令(不是自己做的)"></a>第三关：观察从键盘输入的口令(不是自己做的)</h2><h2 id="实验方法-6"><a href="#实验方法-6" class="headerlink" title="实验方法"></a>实验方法</h2><pre><code class="lang-sh">b do_execvecccc# (在虚拟机中输入passwd,enter后回到gdb)b tty_readcp tty_table[0].secondaryp tty_io.c:288c# (在虚拟机中输入secret，enter后回到gdb)p tty_table[0].secondary</code></pre><h2 id="本关答案-6"><a href="#本关答案-6" class="headerlink" title="本关答案"></a>本关答案</h2><pre><code class="lang-sh">1.程序 passwd 会在几号进程中执行？(6)2.上述进程第一次开始执行函数 tty_read 时，0 号终端的 secondary 队列的头指针和尾指针分别是多少？(7)(7)该队列的 buf 数组中记录的字符串是什么？(&quot;passwd\n&quot;)3.上述进程第一次执行完函数 tty_read 时，0 号终端的 secondary 队列的头指针和尾指针分别是多少？(14)(14)该队列的 buf 数组中记录的字符串是什么？(&quot;passwd\nsecret\n&quot;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 实训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Educoder </tag>
            
            <tag> 模拟实训 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决GitHub资源访问问题</title>
      <link href="/2021/11/02/Git/GitHub%20resource/"/>
      <url>/2021/11/02/Git/GitHub%20resource/</url>
      
        <content type="html"><![CDATA[<h2 id="问题：访问GitHub速度很慢"><a href="#问题：访问GitHub速度很慢" class="headerlink" title="问题：访问GitHub速度很慢"></a>问题：访问GitHub速度很慢</h2><p>平时，访问GitHub非常不稳定，访问速度忽快忽慢，有时还打不开。从GitHub上下载文件也很让人头痛。</p><h2 id="解决方法一：关闭计算机代理"><a href="#解决方法一：关闭计算机代理" class="headerlink" title="解决方法一：关闭计算机代理"></a>解决方法一：关闭计算机代理</h2><p>Windows10系统默认开启网页代理选项，这样会加快国内网站的访问速度。但是，这个代理会影响国外网站的解析。所以要提升访问GitHub的速度，就要关闭它。</p><p>关闭方法：Win10设置 -&gt; 网络和Internet -&gt; 代理，将自动设置代理选项的自动检测设置开关关闭。</p><h2 id="解决方法二：使用CDN加速"><a href="#解决方法二：使用CDN加速" class="headerlink" title="解决方法二：使用CDN加速"></a>解决方法二：使用CDN加速</h2><p>在网页按如下格式输入网址，可以使用CDN加速，这样访问仓库里的文件就会快一些</p><pre><code class="lang-url">https://cdn.jsdelivr.net/gh/&#123;你的github用户名&#125;/&#123;仓库名称&#125;/&#123;仓库具体路径&#125;</code></pre><p>这是我存在GitHub仓库里的一张图片，可以正常打开</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/Source%20license.jpeg" alt="Source license"></p><p>以下是一个生成CDN加速链接的Python脚本：</p><p>使用时，新建一个名为CDN的目录，与.git放在同一目录，并添加到.gitignore中</p><pre><code class="lang-python">import osimport jsondef list_dir(dirs):    L = []    for dirr in os.listdir(dirs):        dirr = os.path.join(dirs, dirr)        if (os.path.isfile(dirr)) :            L.append(dirr)        else :            L += list_dir(dirr)    return Ldef list_all_file(dirs):    L = []    for dirr in os.listdir(dirs) :        dirr = os.path.join(dirs, dirr)        if (os.path.isdir(dirr)) :            L += list_dir(dirr)        else:            L.append(dirr)    return Ldef str_replace(string, L):    for i in range(0, len(L)) :        L[i] = L[i].replace(string, &quot;&quot;)        L[i] = L[i].replace(&#39; &#39;, &quot;%20&quot;)        L[i] = L[i].replace(&#39;\\&#39;, &#39;/&#39;)        if (L[i][0] == &#39;/&#39;):            L[i] = L[i][1 : len(L[i]) : 1]    return Ldef transURL(info):    tmp = url[url.find(info[&#39;repodir&#39;]) : ]    tmp = tmp.replace(&#39;\n&#39;, &quot;&quot;)    tmp = tmp.replace(&#39; &#39;, &quot;%20&quot;)    return info[&#39;cdn_url&#39;] + &#39;/&#39; + info[&#39;GitHubusr&#39;] + &#39;/&#39; + info[&#39;Repo&#39;] + &#39;/&#39; + tmpdef writefilelist(info, imagefile):    with open(&quot;pic.log&quot;, &quot;w&quot;) as f:        for image_name in imagefile:            f.write(info[&#39;cdn_url&#39;] + &#39;/&#39; + info[&#39;GitHubusr&#39;] + &#39;/&#39; + info[&#39;Repo&#39;] + &#39;/&#39; + info[&#39;repodir&#39;] + &#39;/&#39; + image_name + &#39;\n&#39;)def writefilelistasHtml(info, imagefile):    with open(&quot;pic.html&quot;, &quot;w&quot;) as f:        for image_name in imagefile:            f.write(&#39;&lt;img src = \&quot;&#39; + \                info[&#39;cdn_url&#39;] + &#39;/&#39; + info[&#39;GitHubusr&#39;] + &#39;/&#39; + info[&#39;Repo&#39;] + \                     &#39;/&#39; + info[&#39;repodir&#39;] + &#39;/&#39; + image_name + &#39;\&quot;&#39; + &#39;width = 120 height = 120&#39; +&#39;/&gt;&#39; + &#39;\n&#39;)def read_info():    with open(&quot;settings.json&quot;, &quot;r&quot;) as s:        dict_json = json.loads(s.read())        s.close()        return dict_jsondef helps():    print(&quot;----------------------------------------&quot;)    print(&quot;Welcome to GitHub image CDN transformer:\nChoose:&quot;)    print(&quot;    1. transform GitHub url to CDN url then CONTINUE\n    2. tranform GitHub url in a dir then EXIT\n    3. tranform GitHub url in html\nOther. exit&quot;)    print(&quot;----------------------------------------&quot;)if __name__ == &quot;__main__&quot; :    helps()    info = read_info()    pic_ = os.path.join(os.path.abspath(os.path.dirname(os.getcwd())), info[&#39;imagefile&#39;])    while (True) :        try:            a = input(&#39;Please input command : &#39;)            if a == &#39;1&#39; :                url = input(&#39;input url : &#39;)                print(transURL(info))            elif a == &#39;2&#39; :                writefilelist(info, str_replace(pic_, list_all_file(pic_)))            elif a == &#39;3&#39; :                writefilelistasHtml(info, str_replace(pic_, list_all_file(pic_)))            else:                print(&#39;Finished!&#39;)                break            print(&#39;Finished!&#39;)            helps()        except EOFError :            break    print(&quot;Bye~&quot;)</code></pre><h2 id="解决方法三：使用镜像站"><a href="#解决方法三：使用镜像站" class="headerlink" title="解决方法三：使用镜像站"></a>解决方法三：使用镜像站</h2><p>在此推荐一个镜像站</p><p><a href="https://hub.連接.台灣">GitHub台灣</a>：<a href="https://hub.連接.台灣">https://hub.連接.台灣</a></p><h2 id="解决方法四：更改主机Host文件"><a href="#解决方法四：更改主机Host文件" class="headerlink" title="解决方法四：更改主机Host文件"></a>解决方法四：更改主机Host文件</h2><p>修改C:\Windows\System32\drivers\etc路径下的hosts文件，根据域名得到实时有效的ip地址，并改到hosts文件中，本方法现在作用不大，所以放在最后。</p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android项目的阅读 - UI（总第二篇）</title>
      <link href="/2021/10/28/Android/Android%20UI%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/10/28/Android/Android%20UI%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-UI设计"><a href="#1-UI设计" class="headerlink" title="1. UI设计"></a>1. UI设计</h1><h2 id="1-1-fragment与fragment管理器的简介"><a href="#1-1-fragment与fragment管理器的简介" class="headerlink" title="1.1 fragment与fragment管理器的简介"></a>1.1 fragment与fragment管理器的简介</h2><p>fragment是一种<strong>控制器对象</strong>，activity可以委派它完成一些任务。这些任务通常就是管理用户界面。受管理的用户界面可以是整屏或整屏的一部分。</p><!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=5,IE=9" ><![endif]--><p>&lt;!DOCTYPE html&gt;</p><html><head><title>blog drawer</title><meta charset="utf-8"/></head><body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;Electron\&quot; modified=\&quot;2021-10-28T15:37:29.706Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) draw.io/15.4.0 Chrome/91.0.4472.164 Electron/13.5.0 Safari/537.36\&quot; etag=\&quot;H2XLTjLyDGW3-ZPlysxt\&quot; version=\&quot;15.4.0\&quot; type=\&quot;device\&quot;&gt;&lt;diagram id=\&quot;8VTii5JQyqyGZYSvtrSO\&quot; name=\&quot;第 1 页\&quot;&gt;7VdNc5swEP01e3THfBjDEWycdqY5ZDKeNr0pIINagRhZjk1+fRcQxhTbTWfcOM30BPt2Vx/v7UoA1izb3UhSpLciphzMcbwDaw6maYxNGx8VUjbIxDMbIJEs1kEdcM+eaZup0Q2L6boXqITgihV9MBJ5TiPVw4iUYtsPWwnen7UgCR0A9xHhQ/QLi1XaoK457fCPlCVpO7PheI0nI22w3sk6JbHYHkBWCNZMCqGat2w3o7wir+WlyVuc8O4XJmmuXpJQGN/uFnerkX/7vFyGN8uRM38cGZZenCrbHdMYCdCmkCoVicgJDzs0kGKTx7QadoxWF/NZiAJBA8HvVKlSq0k2SiCUqoxrL90x9bVK/zDR1sOBZ77TI9dGqY1mndXiTu5fQ2uxkRE9t+m2kIhMqDoXaO51wgKnIqNKlpgoKSeKPfVXQnSlJfu4Tgx80Xr8iTZ64CfCN3oqEuG0TJUD0fqSbFOm6H1Baha22Jh9+vWwVCq6O0/mcOs6wbJ0Veu23lf5tmsST0PpQX+0aZcny/lXChkZluVBUmU+HPq6tNr6Gw1gvrQBJldtAHPQACtJkqza71trAGt87QawB2RBOAF/Cp4NoQOBDUE4oA0JUH1u1kqKH3QmuJCI5CKvGmXFOP8FIpwlOZoREkYRDyo6GV6cvnZkLI7rLjsmRl+uS+jh2v0DyRnq4byqHpOBHstPEKIcE3BnEHrgzcE3314hu9cu5OmRQp6CH4Jv1PyNwR0e9u+2kC372oXsHtFjAcEMPH//PVLp4gMuHY+cwAXXql8MwGLCs8dzwJ1CiCdQAME71s42f/9VZJivKp53Wrz9XfpfvGPiHbvRDesy4qHZ/fjVvoPfZyv8CQ==&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div><script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script></body></html><p>管理用户界面的fragment又称为UI fragment。它自己也有产生于布局文件的视图，fragment的视图包含了用户可以交互的可视化UI元素。</p><p>activity视图可预留供fragment视图插入的位置，如果有多个fragment要插入，activity可提供多个位置。</p><!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=5,IE=9" ><![endif]--><p>&lt;!DOCTYPE html&gt;</p><html><head><title>blog drawer</title><meta charset="utf-8"/></head><body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;Electron\&quot; modified=\&quot;2021-10-28T15:17:16.831Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) draw.io/15.4.0 Chrome/91.0.4472.164 Electron/13.5.0 Safari/537.36\&quot; etag=\&quot;2OXMoMwM14fjRU-aTrIf\&quot; version=\&quot;15.4.0\&quot; type=\&quot;device\&quot;&gt;&lt;diagram id=\&quot;8VTii5JQyqyGZYSvtrSO\&quot; name=\&quot;第 1 页\&quot;&gt;zVZLc6MwDP41OqbDG3PECeleOtNOp7OPmwsOeJbgjHGapL9+bTAQIG232+7OnkCfJVnSJ9kGd7k9XguyK254RktwrOwI7gocx7YcT300cmoRP3JaIBcsM0oDcM+eaWdp0D3LaD1SlJyXku3GYMqriqZyhBEh+GGstuHleNcdyekMuE9JOUe/skwWLYqccMC/UJYX3c52ELUrW9Ipm0zqgmT8cAa5CbhLwbls/7bHJS118bq6tHbrF1b7wASt5O8Y7Owfd+u7zSK+eX54SK4fFsHqcWHIeCLl3iRsgpWnrgKC76uMaicWuPhQMEnvdyTVqwfFucIKuS2VZKtf444KSY8vxmn32au2oXxLpTgpFWPgeKZgpmMcy8iHof5uaLDivPbIgMRwnve+h7KoH1OZd1TJnVcp8QEhiEJIEMQ2xGgjSL7VKSYhRDEgr1kJAQVaN8KAE0jWgJeAlo2Op4wgCbQbHDb+1hCvIfEAY4h9rYMcwFGzFGpQLyFAq8ah1flp95qGA0mkf3D0MT4zJtRUMV4pueZ7Xf9P4difcGzPObatSxwHf4vj4ALHAUSq3okusyo/Cj7K8ZzRlshzq2bDviGioIkiAGz1mw5R9K3SBIqbQGMFxq/1wyyr/7JD3ODtDulPin/TIejts5JWWawvHSWlJalrlo6LNa4szdRVY4y5kAXPeUXKZECxKpY4fdPqV57fyd+VvLCuLAt1yOrYeWyk07l0SwVT+VNhwDZmvfXrzKh7loicyrcujzmDgpZEsqex/0tsGNNbztTOPfOeFY6Yt/0JoarLREqN1fmFN3U0OWT6A6Vz1CY4c9Q0R5/Pn/dL17FnDUPUpDwxebpwbkxbSY2OHDcPKVmupyxVRGk6sR4wpp4qsVnYsixr2kbQmj2Tx8aV5nynU2yS9jH4K+1rL3ndPra061oK/pMuecl1m1S80l42rCwn0GcMduiNWXHng40uzLXz/rFW4vC8alkdHqlu8gs=&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div><script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script></body></html><p>根据用户需求，可联合使用fragment和activity来组装用户界面。<br>利用fragment，可轻松实现选择不同的列表项就显示对应的明细视图的操作。activity负责以一个明细fragment替换另一个明细fragment，如图7-3所示。这样，视图切换的过程中，也不用销毁activity了。</p><p>除列表明细类应用外，使用UI fragment将应用的UI分解成构建块，还适用于其他类型的应用。例如，利用单个构建块，可以方便地构建分页界面、动画侧边栏界面等更多定制界面。</p><p>不过，UI设计得这样灵活也是要付出代价的，即更复杂的应用、更多的部件以及大量的实现代码。</p><h2 id="1-2-fragment功能概览"><a href="#1-2-fragment功能概览" class="headerlink" title="1.2 fragment功能概览"></a>1.2 fragment功能概览</h2><p>fragment<strong>不具有在屏幕上显示视图的能力</strong>。因此，只有将它的视图放在activity的视图层结构中，fragment视图才能显示在屏幕上。</p><p>下图是《Android编程权威指南》的一个名为CrimeIntent的项目。</p><p>下面第一张图体现了“CrimeActivity托管CrimeFragment”的关系。</p><p>从图中可以看到，灰色区域是fragment类的一个实例CrimeFragment的<strong>控制范围</strong>（fragment不能靠自己直接显示界面，要在类内部使用view类），实例中调用了fragment_crime.xml资源，使得灰色区域中的那个白色的方框能够按格式显示。白色方框中有两个组件，EditText（可编辑的文字模块）和Checkbox（可选方框）。onTextChanged()是监听输入的方法，如果有EditText组件有输入，则告诉fragment现在有输入。同理，如果Checkbox组件被勾选，onCheckedChanged()负责告知fragment组件被勾选的消息。</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/Android/code%20reading/BNRG-crimeintent0.11.png" alt="CrimeIntent CrimeActivity托管着CrimeFragment"></p><p>第二张图体现了这些类之间的关系。箭头指向的，是一个类管理的其他类或资源。以CrimeActivity类为例，它需要管理CrimeFragment类和FrameLayout视图资源。CrimeFragment则管理3个视图资源Button（按钮），Checkbox，和EditText。</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/Android/code%20reading/BNRG-crimeintent0.1.png" alt="CrimeIntent 对象之间的关系"></p><blockquote><p>CrimeActivity视图由FrameLayout组件组成，FrameLayout组件为CrimeFragment视图安排了显示位置。<br>CrimeFragment视图由一个LinearLayout组件及其三个子视图组成。这三个子视图包括一个EditText组件、一个Button组件和一个CheckBox组件。CrimeFragment类中有存储它们的成员变量，并设有监听器，会响应用户操作时，更新模型层数据。</p></blockquote><h2 id="1-3-fragment的托管功能"><a href="#1-3-fragment的托管功能" class="headerlink" title="1.3 fragment的托管功能"></a>1.3 fragment的托管功能</h2><p>为托管UI fragment，activity必须做到：</p><ul><li>在布局中为fragment的视图安排位置</li><li>管理fragment实例的生命周期</li></ul><h3 id="1-3-1-fragment的生命周期"><a href="#1-3-1-fragment的生命周期" class="headerlink" title="1.3.1 fragment的生命周期"></a>1.3.1 fragment的生命周期</h3><p>下图展示了fragment的生命周期。类似于activity的生命周期，它具有停止、暂停以及运行状态，也拥有可以覆盖的<strong>生命周期方法</strong>，用来在关键节点完成一些任务。可以看到，许多方法对应着activity的生命周期方法，如onCreate(Bundle)。<br>这种对应非常重要。因为fragment代表activity工作，所以它的状态应该反映activity的状态。显然，fragment需要相对应的生命周期方法来处理activity的工作。<br>fragment生命周期与activity生命周期的一个关键区别就在于，fragment的生命周期方法由托管activity而不是操作系统调用。操作系统不关心activity用来管理视图的fragment。fragment的使用是activity内部的事情。</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/Android/code%20reading/fragment_lifetime.svg" alt="activity管理的fragment的生命周期"></p><h3 id="1-3-2-fragment托管的两种方式"><a href="#1-3-2-fragment托管的两种方式" class="headerlink" title="1.3.2 fragment托管的两种方式"></a>1.3.2 fragment托管的两种方式</h3><p>activity托管UI fragment有如下两种方式：</p><ul><li>在activity布局中添加fragment</li><li>在activity代码中添加fragment</li></ul><p>第一种方法就是使用布局fragment，这种方式不够灵活，第二种方式比较复杂，但可以在运行时控制fragment。何时添加fragment以及随后可以完成何种具体任务由你自己定；你也可以移除fragment，或用其他fragment代替当前fragment，然后重新添加已移除的fragment。</p><h2 id="1-4-创建UI-fragment"><a href="#1-4-创建UI-fragment" class="headerlink" title="1.4 创建UI fragment"></a>1.4 创建UI fragment</h2><p>创建UI fragment的步骤与创建activity的步骤相同：</p><ul><li>定义用户界面布局文件；</li><li>创建fragment类并设置其视图为定义的布局；</li><li>编写代码，组装在布局文件中实例化的组件；</li></ul><p>下面主要学习代码的编写，下面是一段示例代码</p><pre><code class="lang-java">public class CrimeFragment extends Fragment &#123;    private Crime mCrime;    @Override    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        mCrime = new Crime();    &#125;&#125;</code></pre><p>以上实现代码中，有以下几点值得一说。</p><ul><li><p>首先，Fragment.onCreate(Bundle)是<strong>公共方法</strong>，而Activity.onCreate(Bundle)是<strong>受保护方法</strong>。Fragment.onCreate(Bundle)方法及其他<strong>Fragment生命周期方法必须是公共方法</strong>，因为托管fragment的activity要调用它们。</p></li><li><p>其次，类似于activity，<strong>fragment同样具有保存及获取状态的bundle</strong>。如同使用Activity.onSaveInstanceState(Bundle)方法那样，你也可以根据需要覆盖-Fragment.onSaveInstanceState(Bundle)方法。</p></li><li><p>另外，fragment的视图并没有在Fragment.onCreate(Bundle)方法中生成。虽然我们在该方<br>法中配置了fragment实例，但<strong>创建和配置fragment视图是另一个Fragment生命周期方法完成的</strong>：</p><pre><code class="lang-java">public View onCreateView(LayoutInflater inflater, ViewGroup container,Bundle savedInstanceState)</code></pre></li></ul><p>该方法实例化fragment视图的布局， 然后将<strong>实例化的View 返回</strong>给托管activity 。<strong>LayoutInflater</strong>及<strong>ViewGroup</strong>是<strong>实例化布局的必要参数</strong>。Bundle用来存储恢复数据，可供该方法从保存状态下重建视图。</p><p>下面添加onCreateView(…)方法的实现代码，从fragment_crime.xml布局中实例化并返回视图.</p><pre><code class="lang-java">public class CrimeFragment extends Fragment &#123;    private Crime mCrime;    @Override    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        mCrime = new Crime();    &#125;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) &#123;        View v = inflater.inflate(R.layout.fragment_crime, container, false);        return v;    &#125;&#125;</code></pre><p>在onCreateView(…)方法中，fragment的视图是直接通过<strong>调用LayoutInflater.inflate(…)方法</strong>并传入布局的资源ID生成的。<strong>第二个参数</strong>是视图的<strong>父视图</strong>，我们通常需要父视图来正确配置组件。<strong>第三个参数</strong>告诉布局生成器<strong>是否将生成的视图添加给父视图</strong>。这里，传入了false参数，因为我们将以代码的方式添加视图。</p><p>下面是生成fragment中的EditText、CheckBox和Button组件的代码。它们也是在onCreateView(…)方法里实例化。</p><pre><code class="lang-java">public class CrimeFragment extents Fragment &#123;    private Crime mCrime;    private EditText mTitleField;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) &#123;        View v = inflater.inflate(R.layout.fragment_crime, container, false);        mTitleField = (EditText)v.findViewById(R.id.crime_title);// 这里的代码调用了view类        mTitleField.addTextChangedListener(new TextWatcher() &#123;            @Override            public void beforeTextChanged(                CharSequence s, int start, int count, int after) &#123;                // This space intentionally left blank            &#125;            @Override            public void onTextChanged(                CharSequence s, int start, int before, int count) &#123;                mCrime.setTitle(s.toString());            &#125;            @Override            public void afterTextChanged(Editable s) &#123;                // This one too            &#125;        &#125;);        return v;    &#125;&#125;</code></pre><p>对比以下调用activity的代码</p><pre><code class="lang-java">public class QuizActivity extends AppCompatActivity &#123;    ...    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_quiz);        mQuestionTextView = (TextView) findViewById(R.id.question_text_view);        int question = mQuestionBank[mCurrentIndex].getTextResId();        mQuestionTextView.setText(question);        mTrueButton = (Button) findViewById(R.id.true_button); //这里的代码没有调用view类        ...    &#125;&#125;</code></pre><p>Fragment.onCreateView(…)方法中的组件引用几乎等同于Activity.onCreate(Bundle)方法的处理。唯一的区别是，你调用了fragment视图的View.findViewById(int)方法。以前使用Activity.findViewById(int)方法十分便利，能够在后台自动调用View.findViewById(int)方法，而Fragment类没有对应的便利方法，因此必须手动调用。</p><p>fragment中监听器方法的设置和activity中完全一样。</p><h2 id="1-5-fragmentManager类"><a href="#1-5-fragmentManager类" class="headerlink" title="1.5 fragmentManager类"></a>1.5 fragmentManager类</h2><p>FragmentManager类负责管理fragment并将它们的视图添加到activity的视图层级结构中。</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/Android/code%20reading/BNRG-fragmentManager.jpg" alt="fragment 简图"></p><p>FragmentManager类具体管理：</p><ul><li>fragment队列</li><li>fragment事务回退栈</li></ul><p>要以代码的方式将fragment添加给activity，需要直接调用activity的FragmentManager。首先是获取FragmentManager本身。在CrimeActivity.java中，在onCreate(Bundle)方法中添加代码取得FragmentManager，如下面的代码所示。</p><pre><code class="lang-java">public class CrimeActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_crime);        FragmentManager fm = getSupportFragmentManager();    &#125;&#125;</code></pre><p>如果添完代码遇到错误，记得检查导入语句，看是否已导入支持库版本的FragmentManager类。</p><p>因为使用了支持库及AppCompatActivity类，所以这里调用了getSupportFragmentManager()方法。如果不考虑旧版本的兼容性问题，可直接继承Activity类并调用getFragmentManager()方法。</p><h3 id="1-5-1-fragment-事务"><a href="#1-5-1-fragment-事务" class="headerlink" title="1.5.1 fragment 事务"></a>1.5.1 fragment 事务</h3><p>获取FragmentManager之后，再获取一个fragment交给它管理</p><pre><code class="lang-java">public class CrimeActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_crime);        FragmentManager fm = getSupportFragmentManager();// 创建FragmentManager        Fragment fragment = fm.findFragmentById(R.id.fragment_container);// 使用R.id.fragment_container的容器视图资源ID，向FragmentManager请求并获取fragment。        if (fragment == null) &#123;// 如果没有获取到需要的fragment，根据当前资源新建一个fragment放入FragmentManager中            fragment = new CrimeFragment();            fm.beginTransaction()// 这段代码创建并提交了一个fragment事务                .add(R.id.fragment_container, fragment)                .commit();        &#125;    &#125;&#125;</code></pre><p>fragment事务被用来添加、移除、附加、分离或替换fragment队列中的fragment。这是使用fragment动态组装和重新组装用户界面的关键。FragmentManager管理着fragment队列和事务回退栈。</p><p>FragmentManager.beginTransaction()方法创建并返回FragmentTransaction实例。<br>FragmentTransaction类支持流接口（fluent interface）的链式方法调用，以此配置FragmentTransaction再返回它。因此，以上灰底代码可解读为：“创建一个新的fragment事务，执行一个fragment添加操作，然后提交该事务。”add(…)方法是整个事务的核心，它有两个参数：容器视图资源ID和新创建的CrimeFragment。</p><p>容器视图资源ID你应该很熟悉了，它是定义在activity_crime.xml中的FrameLayout组件的资源ID。<br>容器视图资源ID的作用有：</p><ul><li>告诉FragmentManager，fragment视图应该出现在activity视图的什么位置；</li><li>唯一标识FragmentManager队列中的fragment。</li></ul><p>如需从FragmentManager中获取CrimeFragment，使用容器视图资源ID就行了：</p><pre><code class="lang-java">Fragment fragment = fm.findFragmentById(R.id.fragment_container);</code></pre><p>FragmentManager使用FrameLayout组件的资源ID识别CrimeFragment。如果要向activity添加多个fragment，通常就需要分别为每个fragment创建具有不同ID的不同容器。</p><h4 id="注意：FragmentManager可以在activity销毁时保存fragment队列"><a href="#注意：FragmentManager可以在activity销毁时保存fragment队列" class="headerlink" title="注意：FragmentManager可以在activity销毁时保存fragment队列"></a>注意：FragmentManager可以在activity销毁时保存fragment队列</h4><p>设备旋转或回收内存时，Android系统会销毁CrimeActivity，而后重建时，会调用CrimeActivity.onCreate(Bundle)方法。activity被销毁时，它的FragmentManager会将fragment队列保存下来。这样，activity重建时，新的FragmentManager会首先获取保存的队列，然后重建fragment队列，从而恢复到原来的状态。</p><h3 id="1-5-2-重新审视fragment的生命周期"><a href="#1-5-2-重新审视fragment的生命周期" class="headerlink" title="1.5.2 重新审视fragment的生命周期"></a>1.5.2 重新审视fragment的生命周期</h3><p>activity的FragmentManager负责调用队列中fragment的生命周期方法。添加fragment供FragmentManager管理时，onAttach(Context)、onCreate(Bundle)和onCreateView(…)方法会被调用。</p><p>在fragment加入到fragmentManager队列后，onActivityCreated(Bundle)方法会被调用。</p><p>在activity处于运行状态时，添加fragment会发生什么呢？这种情况下，FragmentManager立即驱动fragment，调用一系列必要的生命周期方法，快速跟上activity的步伐（与activity的最新状态保持同步）。例如，向处于运行状态的activity中添加fragment时，以下fragment生命周期方法会被依次调用：onAttach(Context)、onCreate(Bundle)、onCreateView(…)、onActivityCreated(Bundle)、onStart()以及onResume()。</p><p>一旦追上，托管activity的FragmentManager就会边接收操作系统的调用指令，边调用其他生命周期方法，让<strong>fragment与activity的状态取得一致</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/Android/code%20reading/fragment_lifetime_m.svg" alt="fragmentManager管理的fragment生命周期"></p><h2 id="1-6-使用fragment要注意的点"><a href="#1-6-使用fragment要注意的点" class="headerlink" title="1.6 使用fragment要注意的点"></a>1.6 使用fragment要注意的点</h2><h3 id="1-6-1-Less-is-more"><a href="#1-6-1-Less-is-more" class="headerlink" title="1.6.1 Less is more"></a>1.6.1 Less is more</h3><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/Android/code%20reading/BNRG-less%20is%20more.jpg" alt="Less is more!"></p><h3 id="1-6-2-fragment-与支持库"><a href="#1-6-2-fragment-与支持库" class="headerlink" title="1.6.2 fragment 与支持库"></a>1.6.2 fragment 与支持库</h3><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/Android/code%20reading/BNRG-appcompatActivity.jpg" alt="fragment和支持库"></p><p>从图上可以看到，AppCompatActivity是FragmentActivity的子类。《TBNRG》这本书的第二版使用的就是FragmentActivity类。第三版换为AppCompatActivity类。</p><h2 id="1-7-使用RecyclerView显示列表"><a href="#1-7-使用RecyclerView显示列表" class="headerlink" title="1.7 使用RecyclerView显示列表"></a>1.7 使用RecyclerView显示列表</h2><p>本节将使用RecyclerView显示如图所示的列表</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/Android/code%20reading/BNRG-crimelist-display.jpg" alt="列表"></p><p>下图是CriminalIntent应用在本章的整体规划图。</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/Android/code%20reading/BNRG-crimelistdesign.jpg" alt="CriminalIntent_listdesign"></p><h3 id="1-7-1-先构造相应的数据类"><a href="#1-7-1-先构造相应的数据类" class="headerlink" title="1.7.1 先构造相应的数据类"></a>1.7.1 先构造相应的数据类</h3><pre><code class="lang-java">public class CrimeLab &#123;    private static CrimeLab sCrimeLab;    private List&lt;Crime&gt; mCrimes;    public static CrimeLab get(Context context) &#123;        if (sCrimeLab == null) &#123; // Android开发的命名约定，一看到此前缀，我们就知道sCrimeLab是一个静态变量            sCrimeLab = new CrimeLab(context);        &#125;        return sCrimeLab;    &#125;    private CrimeLab(Context context) &#123;        mCrimes = new ArrayList&lt;&gt;();    &#125;    public List&lt;Crime&gt; getCrimes() &#123;        return mCrimes;    &#125;    public Crime getCrime(UUID id) &#123;        for (Crime crime : mCrimes) &#123;            if (crime.getId().equals(id)) &#123;                return crime;            &#125;        &#125;        return null;    &#125;&#125;</code></pre><h3 id="1-7-1-Java的抽象类和抽象方法"><a href="#1-7-1-Java的抽象类和抽象方法" class="headerlink" title="1.7.1+ Java的抽象类和抽象方法"></a>1.7.1+ Java的抽象类和抽象方法</h3><p>合理运用抽象类，有助于我们消除大量的重复代码。详见下面的例子：</p><pre><code class="lang-java">// 创建一个新的activity时，都要调用以下代码唯一的区别就在注释一行/** Called when the activity is first created. */public class CrimeActivity extends AppCompatActivity &#123;       @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_fragment);        FragmentManager fm = getSupportFragmentManager();        Fragment fragment = fm.findFragmentById(R.id.fragment_container);        if (fragment == null) &#123;            fragment = new CrimeFragment(); //只有这里有区别            fm.beginTransaction()                .add(R.id.fragment_container, fragment)                .commit();        &#125;    &#125;&#125;</code></pre><p>如果应用中有很多activity，那么会出现大量的重复代码。</p><p>所以，我们可以为这些重复的代码建立<strong>抽象类</strong>，代码中不同的部分采用<strong>抽象方法</strong>代替。抽象类如下：</p><blockquote><p><strong>补充：抽象类和抽象方法</strong></p><p>所有的抽象方法和抽象方法所在的类都要使用abstract关键字定义，用abstract关键字定义的抽象方法所在的类称为抽象类</p><p>抽象类中包含抽象方法，抽象方法不包含方法体，即抽象类中没有具体实现，所以抽象类中不能直接产生实例化对象，抽象类只能被实体类继承之后再实例化。</p></blockquote><pre><code class="lang-java">public abstract class SingleFragmentActivity extends AppCompatActivity &#123; // 抽象类    protected abstract Fragment createFragment(); // 抽象方法    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_fragment);        FragmentManager fm = getSupportFragmentManager();        Fragment fragment = fm.findFragmentById(R.id.fragment_container);        if (fragment == null) &#123;            fragment = createFragment();            fm.beginTransaction()                .add(R.id.fragment_container, fragment)                .commit();        &#125;    &#125;&#125;</code></pre><p>这样，再创建一个activity类时，就可以直接这样实现，减少了重复代码，更加简洁：</p><pre><code class="lang-java">public class CrimeActivity extends AppCompatActivity SingleFragmentActivity &#123;    @Override    protected Fragment createFragment() &#123;        return new CrimeFragment();    &#125;&#125;</code></pre><h3 id="1-7-2-RecyclerView"><a href="#1-7-2-RecyclerView" class="headerlink" title="1.7.2 RecyclerView"></a>1.7.2 RecyclerView</h3><p>RecyclerView只创建刚好充满屏幕的View，而不是全部的View。用户滑动屏幕切换视图时，上一个视图会回收利用。顾名思义，RecyclerView所做的就是回收再利用，循环往复。</p><p>RecyclerView的任务仅限于<strong>回收和定位</strong>屏幕上的View。</p><p>列表项View能够显示数据还离不开另外两个类的支持：<strong>ViewHolder</strong>子类和<strong>Adapter</strong>子类。</p><h3 id="1-7-3-ViewHolder"><a href="#1-7-3-ViewHolder" class="headerlink" title="1.7.3 ViewHolder"></a>1.7.3 ViewHolder</h3><p>ViewHolder是一个容器，顾名思义，它只做一件事：<strong>容纳View视图</strong></p><pre><code class="lang-java">// A typical ViewHolder subclasspublic class ListRow extends RecyclerView.ViewHolder &#123;    public ImageView mThumbnail;    public ListRow(View view) &#123;        super(view);        mThumbnail = (ImageView) view.findViewById(R.id.thumbnail);    &#125;&#125;</code></pre><p>你可以创建ListRow来获取自定义的mThumbnail和RecyclerView.ViewHolder超类传入的itemView 。ViewHolder为itemView 而生： 它<strong>引用着</strong>传给super(view)的<strong>整个View视图</strong></p><pre><code class="lang-java">// The code is a typical usage of a ViewHolderListRow row = new ListRow(inflater.inflate(R.layout.list_row, parent, false));View view = row.itemView;ImageView thumbnailView = row.mThumbnail;</code></pre><h3 id="1-7-4-Adapter"><a href="#1-7-4-Adapter" class="headerlink" title="1.7.4 Adapter"></a>1.7.4 Adapter</h3><p><strong>RecyclerView自己不创建ViewHolder</strong>。这个任务实际是由Adapter来完成的。<strong>Adapter</strong>是一个控制器对象，<strong>从模型层获取数据，然后提供给RecyclerView显示</strong>，是沟通的桥梁。</p><p>Adapter负责</p><ul><li>创建必要的ViewHolder；</li><li>绑定ViewHolder至模型层数据；</li></ul><p>要创建Adapter，首先要定义RecyclerView.Adapter子类。然后由它封装从CrimeLab获取的crime。<br>RecyclerView需要显示视图对象时，就会去找它的Adapter。</p><p>调用过程如图</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/Android/code%20reading/recycle_adapter.svg" alt="recycleView &amp; adapter之间的关系"></p><p>整个过程执行完毕，RecyclerView就能在屏幕上显示crime列表项了。需要注意的是，相对于onBindViewHolder(ViewHolder, int)方法，onCreateViewHolder(ViewGroup, int)方法的调用并不频繁。一旦有了够用的ViewHolder，RecyclerView就会停止调用onCreate-ViewHolder(…)方法。随后，它会回收利用旧的ViewHolder以节约时间和内存。</p><h3 id="1-7-5-一个列表界面的创建代码"><a href="#1-7-5-一个列表界面的创建代码" class="headerlink" title="1.7.5 一个列表界面的创建代码"></a>1.7.5 一个列表界面的创建代码</h3><pre><code class="lang-java">// 为CrimeListFragment配置视图public class CrimeListFragment extends Fragment &#123;    // Nothing yet    private RecyclerView mCrimeRecyclerView;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) &#123;        View view = inflater.inflate(R.layout.fragment_crime_list, container, false);        mCrimeRecyclerView = (RecyclerView) view            .findViewById(R.id.crime_recycler_view);        /* As soon as you create your RecyclerView, you need to give it another object called a LayoutManager. RecyclerView requires a LayoutManager to work. */        mCrimeRecyclerView.setLayoutManager(new LinearLayoutManager(getActivity()));// RecyclerView 类不会亲自摆放屏幕上的列表项。实际上，摆放的任务被委托给了LayoutManager。        return view;    &#125;&#125;</code></pre><p>注意，没有LayoutManager的支持，不仅RecyclerView无法工作，还会导致应用崩溃。所以，RecyclerView视图创建完成后，就立即转交给了LayoutManager对象。</p><p>RecyclerView 类不会亲自摆放屏幕上的列表项。实际上，摆放的任务被委托给了LayoutManager。除了在屏幕上摆放列表项，LayoutManager还负责定义屏幕滚动行为。因此，没有LayoutManager，RecyclerView也就没法正常工作。</p><p>除了一些Android操作系统内置版实现，LayoutManager还有很多第三方库实现版本。上一段代码使用的是LinearLayoutManager类，它支持以竖直列表的形式展示列表项。系统内置实现中还有一个GridLayoutManager类，以网格形式展示列表项。</p><blockquote><h4 id="getActivity-方法"><a href="#getActivity-方法" class="headerlink" title="getActivity()方法"></a>getActivity()方法</h4><ul><li><code>getActivity()</code> in a <code>Fragment</code> returns the <code>Activity</code> the <code>Fragment</code> is currently associated with. (see <a href="http://developer.android.com/reference/android/app/Fragment.html#getActivity(">http://developer.android.com/reference/android/app/Fragment.html#getActivity(</a>))</li></ul></blockquote><p>上一段代码实现了一个RecyclerView空视图。要想显示出crime列表项，还需要完成Adapter和ViewHolder的实现。</p><pre><code class="lang-java">// 定义ViewHolder内部类public class CrimelistFragment extends Fragment &#123;    ...    private class CrimeHolder extends RecyclerView.ViewHolder &#123;        public CrimeHolder(LayoutInflater inflater, ViewGroup parent) &#123;            super(inflater.inflate(R.layout.list_item_crime, parent, false));        &#125;    &#125;&#125;</code></pre><p>在CrimeHolder的构造方法里，我们首先实例化list_item_crime布局，然后传给super(…)方法，也就是ViewHolder的构造方法。基类ViewHolder因而实际引用这个视图。如果你需要，可以在ViewHolder的itemView变量里找到它。<br>定义完ViewHolder，接下来的任务是创建Adapter。</p><pre><code class="lang-java">// 创建Adapter内部类，定义必要的方法。public class CrimeListFragment extends Fragment &#123;    private RecyclerView mCrimeRecyclerView;    private CrimeAdapter mAdapter;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) &#123;        View view = inflater.inflate(R.layout.fragment_crime_list, container, false);        mCrimeRecyclerView = (RecyclerView) view            .findViewById(R.id.crime_recycler_view);        mCrimeRecyclerView.setLayoutManager(new LinearLayoutManager(getActivity()));        updateUI();        return view;    &#125;    // 根据数据更新显示内容    private void updateUI() &#123;        CrimeLab crimeLab = CrimeLab.get(getActivity());        List&lt;Crime&gt; crimes = crimeLab.getCrimes();        mAdapter = new CrimeAdapter(crimes);        mCrimeRecyclerView.setAdapter(mAdapter);    &#125;    // 把视图绑定工作放入CrimeHolder类里，implement功能为了是增加一个监听器    private class CrimeHolder extends RecyclerView.ViewHolder implements View.OnClickListener &#123;         private TextView mTitleTextView;        private TextView mDateTextView;        private Crime mcrime;        public CrimeHolder(layoutinflater inflater, ViewGroup parent) &#123;            super(inflater.inflate(R.layout.list_item_crime, parent, false));            itemView.setOnClickListener(this); // 增加一个监听器            mTitleTextView = (TextView) itemView.findViewById(R.id.crime_title);            mDateTextView = (TextView) itemView.findViewById(R.id.crime_date);        &#125;        @Override        public void onClick(View view) &#123; // 监听器调用，响应点击事件            Toast.makeText(getActivity(),                           mCrime.getTitle() + &quot; clicked!&quot;, Toast.LENGTH_SHORT)                            .show();        &#125;        public void bind(Crime crime) &#123; // 每次有新的Crime要在CrimeHolder中显示时，都要调用它一次，刷新显示            mCrime = crime;            mTitleTextView.setText(mCrime.getTitle());            mDateTextView.setText(mCrime.getDate().toString());        &#125;    &#125;    private class CrimeAdapter extends RecyclerView.Adapter&lt;CrimeHolder&gt; &#123; // 定义Adapter内部类        private List&lt;Crime&gt; mCrimes;        public CrimeAdapter(List&lt;Crime&gt; crimes) &#123;            mCrimes = crimes;        &#125;        @Override        public CrimeHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;            LayoutInflater layoutInflater = LayoutInflater.from(getActivity());            return new CrimeHolder(layoutInflater, parent);        &#125;        @Override        public int getItemCount() &#123;            return mCrimes.size();        &#125;        @Override        public void onBindViewHolder(CrimeHolder holder, int position) &#123;            Crime crime = mCrimes.get(position);            holder.bind(crime);        &#125;    &#125;&#125;</code></pre><p>如果你一通猛滑，列表项滚动得非常流畅。这要归功于onBindViewHolder(…)方法。任何时候，只要有可能，都要确保这个方法轻巧、高效。</p><h2 id="1-8-ListView-和-GridView"><a href="#1-8-ListView-和-GridView" class="headerlink" title="1.8 ListView 和 GridView"></a>1.8 ListView 和 GridView</h2><p>Android操作系统核心库包含ListView、GridView和Adapter这3个类。Android 5.0之前，创建列表项或网格项都应该优先使用这些类。<br>这些类的API与RecyclerView的API非常相似。ListView和GridView不关心具体的展示项，只负责展示项的滚动。Adapter负责创建列表项的所有视图。不过，使用ListView和GridView时，不一定非要使用ViewHolder模式（虽然可以并且应该使用）。</p><p>过去传统的实现方式现已被RecyclerView的实现方式取代，因此不用再费力地调整ListView和GridView的工作行为了。</p><p>ListView和GridView 是 AdapterView 的子类，它们可以填充绑定到一个适配器，它从外部源检索数据，并创建一个视图表示每个数据项。</p><h3 id="1-8-1-ListView"><a href="#1-8-1-ListView" class="headerlink" title="1.8.1 ListView"></a>1.8.1 ListView</h3><p>简单的用法示例</p><pre><code class="lang-java">public class MainActivity extends Activity &#123;   String[] Array = &#123;&quot;A Type&quot;, &quot;B Type&quot;, &quot;C Type&quot;, &quot;Reset&quot;, &quot;Setting&quot;&#125;;   @Override   protected void onCreate(Bundle savedInstanceState) &#123;      super.onCreate(savedInstanceState);      setContentView(R.layout.activity_main);           ArrayAdapter adapter = new ArrayAdapter&lt;String&gt;(this,       R.layout.activity_listview, Array);          ListView listView = (ListView) findViewById(R.id.list);      listView.setAdapter(adapter);   &#125;&#125;</code></pre><p>运行这段代码，就可以显示出列表视图。</p><h3 id="1-8-2-GridView"><a href="#1-8-2-GridView" class="headerlink" title="1.8.2 GridView"></a>1.8.2 GridView</h3><p>与ListView大体相似。</p><h2 id="1-9-参考资料"><a href="#1-9-参考资料" class="headerlink" title="1.9 参考资料"></a>1.9 参考资料</h2><ul><li><p>《Android编程权威指南（第三版）》</p></li><li><p>《Android编程权威指南（第二版）》</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件开发 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Verilog的一些实用操作</title>
      <link href="/2021/10/25/Programming%20Language/Verilog%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2021/10/25/Programming%20Language/Verilog%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="位拼接运算符"><a href="#位拼接运算符" class="headerlink" title="位拼接运算符"></a>位拼接运算符</h2><h3 id="位截取"><a href="#位截取" class="headerlink" title="位截取"></a>位截取</h3><pre><code class="lang-verilog">rs2 = ins[24 : 20]</code></pre><h3 id="拼接方法"><a href="#拼接方法" class="headerlink" title="拼接方法"></a>拼接方法</h3><pre><code class="lang-verilog">&#123;ins[14 : 12], ins[31 : 25]&#125;&#123;3&#39;b000, 7&#39;b0000000&#125;</code></pre><h3 id="一个bit位的重复"><a href="#一个bit位的重复" class="headerlink" title="一个bit位的重复"></a>一个bit位的重复</h3><pre><code class="lang-verilog">Imm = &#123;&#123;20&#123;rImm[11 : 11]&#125;&#125;, rImm[11 : 0]&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 硬件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件描述语言 </tag>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educoder 操作系统实训5.x实验</title>
      <link href="/2021/10/20/Operation%20System/Educoder%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%AE%AD5.x/"/>
      <url>/2021/10/20/Operation%20System/Educoder%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%AE%AD5.x/</url>
      
        <content type="html"><![CDATA[<h1 id="实训5：进程的同步与互斥"><a href="#实训5：进程的同步与互斥" class="headerlink" title="实训5：进程的同步与互斥"></a>实训5：进程的同步与互斥</h1><h2 id="实训地址"><a href="#实训地址" class="headerlink" title="实训地址"></a>实训地址</h2><p><a href="https://www.educoder.net/paths/2104">操作系统 (educoder.net)</a></p><h2 id="第一关：多线程编程"><a href="#第一关：多线程编程" class="headerlink" title="第一关：多线程编程"></a>第一关：多线程编程</h2><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>使用 3 个线程计算从 1 到 200 的累加和，3 个线程分别完成函数 p1、p2 和 p3 的计算任务。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>主函数要等两个线程都执行完才行</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="主线程结束时，子线程会被杀死吗"><a href="#主线程结束时，子线程会被杀死吗" class="headerlink" title="主线程结束时，子线程会被杀死吗"></a>主线程结束时，子线程会被杀死吗</h4><p>是的，如果主线程结束时，子线程还没有结束，那么子线程会被操作系统杀死。可以在主线程中使用 <code>pthread_join</code> 来等待子线程结束。</p><h4 id="多线程程序如何编译"><a href="#多线程程序如何编译" class="headerlink" title="多线程程序如何编译"></a>多线程程序如何编译</h4><p>用 pthread 库实现的多线程程序，可以使用 gcc 来编译，且需加上 -pthread 参数：</p><pre><code>gcc 3.c -o 3 -pthread</code></pre><h4 id="pthread-create-函数的各个参数的含义是什么"><a href="#pthread-create-函数的各个参数的含义是什么" class="headerlink" title="pthread_create 函数的各个参数的含义是什么"></a>pthread_create 函数的各个参数的含义是什么</h4><p>该函数的原型和各参数的含义如下：</p><pre><code class="lang-c">int pthread_create(pthread_t *tidp, const pthread_attr_t *attr,    (void*)(*start_rtn)(void*), void *arg);</code></pre><p>第一个参数为指向线程标识符的指针；</p><p>第二个参数用来设置线程属性；</p><p>第三个参数是线程运行函数的起始地址；</p><p>最后一个参数是运行函数的参数。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;int sum1 = 0, sum2 = 0;void *p1()&#123;    int i, tmp = 0;    for (i = 1; i &lt;= 100; i++)        tmp += i;    sum1 += tmp;&#125;void *p2()&#123;    int i, tmp = 0;    for (i = 101; i &lt;= 200; i++)        tmp += i;    sum2 += tmp;&#125;void p3()&#123;    printf(&quot;sum: %d\n&quot;, sum1 + sum2);&#125;int main()&#123;    int res;    pthread_t t1, t2;    void *thread_result;    res = pthread_create(&amp;t1, NULL, p1, NULL);    if (res != 0)&#123;        perror(&quot;failed to create thread&quot;);        exit(1);    &#125;    res = pthread_create(&amp;t2, NULL, p2, NULL);    if (res != 0)&#123;        perror(&quot;failed to create thread&quot;);        exit(1);    &#125;    res = pthread_join(t1, &amp;thread_result);//主函数应该    if (res != 0)&#123;        perror(&quot;failed to join thread&quot;);        exit(2);    &#125;    res = pthread_join(t2, &amp;thread_result);    if (res != 0)&#123;        perror(&quot;failed to join thread&quot;);        exit(2);    &#125;    p3();    return 0;&#125;</code></pre><h2 id="第二关：信号量的应用"><a href="#第二关：信号量的应用" class="headerlink" title="第二关：信号量的应用"></a>第二关：信号量的应用</h2><h3 id="问题背景-1"><a href="#问题背景-1" class="headerlink" title="问题背景"></a>问题背景</h3><p>某休息厅里有足够多（10 把以上）的椅子，10 位顾客先后进入休息厅寻找空椅子，找到后开始在椅子上休息，休息完后让出空椅子、退出休息厅。请只在该程序中插入一些代码（不删除现有代码），来将上述场景调整为休息厅里只有 2 把椅子。</p><h3 id="补充：sem函数的介绍"><a href="#补充：sem函数的介绍" class="headerlink" title="补充：sem函数的介绍"></a>补充：sem函数的介绍</h3><h4 id="定义位置"><a href="#定义位置" class="headerlink" title="定义位置"></a>定义位置</h4><pre><code class="lang-c">#include &lt;semaphore.h&gt;</code></pre><h4 id="sem-init-sem-t-sem-int-pshared-unsigned-int-value"><a href="#sem-init-sem-t-sem-int-pshared-unsigned-int-value" class="headerlink" title="sem_init(sem_t *sem, int pshared, unsigned int __value)"></a>sem_init(sem_t *<strong>sem, int </strong>pshared, unsigned int __value)</h4><p>sem_init函数是Posix信号量操作中的函数。sem_init() 初始化一个定位在 sem 的匿名信号量。value 参数指定信号量的初始值。 pshared 参数指明信号量是由进程内线程共享，还是由进程之间共享。如果 pshared 的值为 0，那么信号量将被进程内的线程共享，并且应该放置在这个进程的所有线程都可见的地址上（如全局变量，或者堆上动态分配的变量）。</p><p>如果 pshared 是非零值，那么信号量将在进程之间共享，并且应该定位共享内存区域(见 shm_open、mmap和 shmget。因为通过 fork 创建的孩子继承其父亲的内存映射，因此它也可以见到这个信号量。所有可以访问共享内存区域的进程都可以用 sem_post、sem_wait 等等操作信号量。初始化一个已经初始的信号量其结果未定义。</p><h4 id="sem-wait-sem-t-sem"><a href="#sem-wait-sem-t-sem" class="headerlink" title="sem_wait(sem_t *sem)"></a>sem_wait(<strong>sem_t</strong> *sem)</h4><p>sem_wait是一个函数，也是一个原子操作，它的作用是从信号量的值减去一个“1”，但它永远会先等待该信号量为一个非零值才开始做减法。也就是说，如果你对一个值为2的信号量调用sem_wait()，线程将会继续执行，将信号量的值将减到1。</p><p>如果对一个值为0的信号量调用sem_wait()，这个函数就会原地等待直到有其它线程增加了这个值使它不再是0为止。如果有两个线程都在sem_wait()中等待同一个信号量变成非零值，那么当它被第三个线程增加一个“1”时，等待线程中只有一个能够对信号量做减法并继续执行，另一个还将处于等待状态。sem_trywait(sem_t *sem)是函数sem_wait的非阻塞版，它直接将信号量sem减1，同时返回错误代码。</p><h4 id="sem-post-sem-t-sem"><a href="#sem-post-sem-t-sem" class="headerlink" title="sem_post(sem_t *sem)"></a>sem_post(<strong>sem_t</strong> *sem)</h4><p>sem_post是给信号量的值加上一个“1”，它是一个“原子操作”－－－即同时对同一个信号量做加“1”操作的两个线程是不会冲突的；而同时对同一个文件进行读和写操作的两个程序就有可能会引起冲突。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt;#define SEAT_NUM  2#define CUSTOMER_NUM  10int customer_state[CUSTOMER_NUM] = &#123;0&#125;;void sleep_random(int t) &#123;    sleep((int)(t * (rand() / (RAND_MAX *1.0))));&#125;void print_cur_state() &#123;    int i;    printf(&quot;  customers with seats: (&quot;);    for (i = 0; i &lt; CUSTOMER_NUM; i++)    &#123;        if (0 != customer_state[i])            printf(&quot; %d&quot;, i+1);    &#125;    printf(&quot; )\n&quot;);&#125;sem_t empty_seat_num; /* 一个由椅子数量决定的信号量，实质上是允许同时运行的程序数量 */void *customer(void *id)&#123;    const int myid = *(int*)id;    sleep_random(2);    printf(&quot;customer %d: try to get a seat...\n&quot;, myid);    sem_wait(&amp;empty_seat_num); /* 如果empty_seat_num &gt; 0，继续执行，如果empty_seat_num == 0，进程会原地等待，不执行。直到有其它线程增加了这个值使它不再是0为止 */    printf(&quot;customer %d: sit down\n&quot;, myid);    customer_state[myid-1] = 1;    print_cur_state();    sleep_random(3);    printf(&quot;customer %d: stand up\n&quot;, myid);    customer_state[myid-1] = 0;    print_cur_state();    sem_post(&amp;empty_seat_num); /* 一个椅子被释放，让empty_seat_num这个信号量的值+1 */&#125;int main()&#123;    int i, id[CUSTOMER_NUM], res;    pthread_t t[CUSTOMER_NUM];    srand((int)time(0));    sem_init(&amp;empty_seat_num, 0, SEAT_NUM); /* 设置信号量的值为2 */    for (i = 0; i &lt; CUSTOMER_NUM; i++)    &#123;        id[i] = i + 1;        pthread_create(&amp;t[i], NULL, customer, &amp;id[i]);    &#125;    for (i = 0; i &lt; CUSTOMER_NUM; i++)    &#123;        res = pthread_join(t[i], NULL);        if (res != 0)&#123;            perror(&quot;failed to join thread&quot;);            exit(2);        &#125;    &#125;    return 0;&#125;</code></pre><h2 id="第三关：顺序资源分配法"><a href="#第三关：顺序资源分配法" class="headerlink" title="第三关：顺序资源分配法"></a>第三关：顺序资源分配法</h2><h3 id="问题背景：哲学家就餐"><a href="#问题背景：哲学家就餐" class="headerlink" title="问题背景：哲学家就餐"></a>问题背景：哲学家就餐</h3><p>五个哲学家共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五只筷子，他们的生活方式是交替的进行思考和进餐。平时，一个哲学家进行思考，饥饿时便试图取用其左右最靠近他的筷子，只有在他拿到两只筷子时才能进餐。进餐完毕，放下筷子继续思考。试模拟此过程</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>对信号量的应用，和第二问基本相同，信号量变为了桌上筷子的有无。即当前chopsticks[left]和chopsticks[right]的值为0还是1。如果当前的进程的chopsticks[left]或chopsticks[right]有一个为0，那么它就要等待别的进程执行完，且chopsticks[left] == chopsticks[right] == 1。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt;void sleep_random(int t) &#123;    sleep((int)(t * (rand() / (RAND_MAX *1.0))));&#125;void delay()&#123;    int i = 10000000;    while (i--)        ;&#125;#define N  5sem_t chopstick[N];void *phi(void *id)&#123;  /* &#39;id&#39; starts from 1 */    int i, left, right, myid = *(int*)id;    left = myid - 1;    right = (myid &lt; N) ? myid : 0;    for (i = 0; i &lt; 3; i++)&#123;        printf(&quot;phi #%d: thinking\n&quot;, myid);        if (left &lt; right)&#123;            sem_wait(&amp;chopstick[left]);            delay();            sem_wait(&amp;chopstick[right]);        &#125;        else&#123;            sem_wait(&amp;chopstick[right]);            delay();            sem_wait(&amp;chopstick[left]);        &#125;        printf(&quot;phi #%d: eating\n&quot;, myid);        sleep_random(3);        sem_post(&amp;chopstick[left]);        sem_post(&amp;chopstick[right]);    &#125;&#125;int main()&#123;    int i, id[N];    pthread_t t[N];    srand((int)time(0));    for (i = 0; i &lt; N; i++)&#123;        id[i] = i + 1;        sem_init(&amp;chopstick[i], 0, 1);    &#125;    for (i = 0; i &lt; N; i++)        pthread_create(&amp;t[i], NULL, phi, &amp;id[i]);    for (i = 0; i &lt; N; i++)        pthread_join(t[i], NULL);    return 0;&#125;</code></pre><h2 id="第四关：生产者与消费者问题"><a href="#第四关：生产者与消费者问题" class="headerlink" title="第四关：生产者与消费者问题"></a>第四关：生产者与消费者问题</h2><h3 id="问题背景：生产与消费"><a href="#问题背景：生产与消费" class="headerlink" title="问题背景：生产与消费"></a>问题背景：生产与消费</h3><p>有两个进程：一组生产者进程和一组消费者进程共享一个初始为空、固定大小为n的缓存（缓冲区）。生产者的工作是制造一段数据，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待，如此反复; 同时，只有缓冲区不空时，消费者才能从中取出消息，一次消费一段数据（即将其从缓存中移出），否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个消费者从中取出消息。</p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>用一个信号量mutex，在生产者生产（向buffer中添加元素）或消费者消费（从buffer删除元素）时，锁住这个过程，不让其他进程进行buffer的读写。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="lang-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt;#define N 8#define PRODUCT_NUM 15#define COSTUME_NUM 5#define PRODUCTOR_NUM 5int buffer[N], readpos = 0, writepos = 0;sem_t full, empty, mutex, aaa; //aaa是为了通过实训加的变量，其实完全没必要void sleep_random(int t) &#123;    sleep((int)(t * (rand() / (RAND_MAX *1.0))));&#125;void *produce(int *id)&#123;    int myid = *id;    for (int i = 0; i &lt; PRODUCT_NUM; i++)&#123;        sleep_random(2);        sem_wait(&amp;empty);        sem_wait(&amp;mutex);        buffer[writepos++] = myid * 1000 + i+1;        if (writepos &gt;= N)            writepos = 0;        printf(&quot;produce:    %d\n&quot;, myid * 1000 + i+1);        sem_post(&amp;mutex);        sem_post(&amp;full);    &#125;&#125;void *consume(int *id) &#123;    for (int i = 0; i &lt; PRODUCT_NUM; i++)&#123;        sleep_random(2);        sem_wait(&amp;full);        sem_wait(&amp;mutex);        printf(&quot;%d consume: %d\n&quot;, *id,buffer[readpos]);        buffer[readpos++] =  -1;        if (readpos &gt;= N)            readpos = 0;        sem_post(&amp;mutex);        sem_post(&amp;empty);    &#125;&#125;int main()&#123;    int res, i, id[PRODUCTOR_NUM] = &#123;0&#125;, id2[COSTUME_NUM] = &#123;0&#125;;    pthread_t t[PRODUCTOR_NUM] = &#123;0&#125;, t2[COSTUME_NUM] = &#123;0&#125;;    for (i = 0; i &lt; N; i++)        buffer[i] =  -1;    srand((int)time(0));    sem_init(&amp;full, 0, 0);    sem_init(&amp;empty, 0, N);    sem_init(&amp;mutex, 0, 1);    for (int i = 0; i &lt; PRODUCTOR_NUM; ++i) &#123;        id[i] = i + 1;        if (pthread_create(&amp;t[i], NULL, (void*)produce, &amp;id[i]) != 0) &#123;            perror(&quot;failed to create thread&quot;);            exit(1);        &#125;        id2[i] = i + 1;        if (pthread_create(&amp;t2[i], NULL, (void*)consume, &amp;id2[i]) != 0) &#123;            perror(&quot;failed to create thread&quot;);            exit(1);        &#125;    &#125;    for (int i = 0; i &lt; COSTUME_NUM; ++i) &#123;        if (res = pthread_join(t[i], NULL) != 0)&#123;            perror(&quot;failed to join thread&quot;);            exit(2);        &#125;        if (res = pthread_join(t2[i], NULL) != 0)&#123;            perror(&quot;failed to join thread&quot;);            exit(2);        &#125;    &#125;    return 0;&#125;</code></pre><h2 id="第五关：三个并发进程"><a href="#第五关：三个并发进程" class="headerlink" title="第五关：三个并发进程"></a>第五关：三个并发进程</h2><h3 id="问题背景：三进程流水"><a href="#问题背景：三进程流水" class="headerlink" title="问题背景：三进程流水"></a>问题背景：三进程流水</h3><p>假设有三个并发进程（ P、Q、R ），其中 P 负责从输入设备上读取信息并传给 Q ， Q 将信息加工后传给 R ，R 负责将信息打印输出。 写出符合下列条件下的并发程序。其中进程 P、Q 共享一个由 5 个缓冲区组成的缓冲池，进程 Q、R 共享另一个由 8 个缓冲区组成的缓冲池。</p><h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><p>对P读写时，Q不能读写，R读写时，Q不能读写。所以用两个信号量锁住进程对两个缓冲区的读写。</p><p>缓冲区中没有元素，不能读。元素已满，缓冲区不能写。用full和empty两个信号量锁住每进程对其对应缓冲区的读写权限。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="lang-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt;#define LIMIT  20#define M  5#define N  8/************************************/int buffer1[M], buffer2[N], readpos1, writepos1, readpos2, writepos2;sem_t full1, empty1, full2, empty2, mutex1, mutex2;/************************************/void sleep_random(int t) &#123;    sleep((int)(t * (rand() / (RAND_MAX *1.0))));&#125;void *P()&#123;    int i;    for (i = 0; i &lt; LIMIT; i++)&#123;        sleep_random(2);        /************************************/        sem_wait(&amp;empty1);        sem_wait(&amp;mutex1);        printf(&quot;P sends:         %d\n&quot;, i + 1);        buffer1[writepos1++] = i + 1;        writepos1 %= M;        sem_post(&amp;mutex1);        sem_post(&amp;full1);        /************************************/    &#125;&#125;void *Q()&#123;    int i, data;    for (i = 0; i &lt; LIMIT; i++)&#123;        sleep_random(2);        /************************************/        sem_wait(&amp;full1);        sem_wait(&amp;mutex1);        int reg = buffer1[readpos1++];        readpos1 %= M;        sem_post(&amp;mutex1);        sem_post(&amp;empty1);        sem_wait(&amp;empty2);        sem_wait(&amp;mutex2);        buffer2[writepos2++] = reg;        writepos2 %= N;        sem_post(&amp;mutex2);        sem_post(&amp;full2);        /************************************/    &#125;&#125;void *R()&#123;    int i;    for (i = 0; i &lt; LIMIT; i++)&#123;        sleep_random(2);        /************************************/        sem_wait(&amp;full2);        sem_wait(&amp;mutex2);        printf(&quot;R receives: %d\n&quot;, buffer2[readpos2++]);        readpos2 %= N;        sem_post(&amp;mutex2);        sem_post(&amp;empty2);        /************************************/    &#125;&#125;int main()&#123;    int i;    pthread_t t1, t2;    for (i = 0; i &lt; M; i++)        buffer1[i] =  -1;    for (i = 0; i &lt; N; i++)        buffer2[i] =  -1;    srand((int)time(0));    /************************************/    sem_init(&amp;empty1, 0, M);    sem_init(&amp;full1, 0, 0);    sem_init(&amp;full2, 0, 0);    sem_init(&amp;empty2, 0, N);    sem_init(&amp;mutex1, 0, 1);    sem_init(&amp;mutex2, 0, 1);    /************************************/    pthread_create(&amp;t1, NULL, P, NULL);    pthread_create(&amp;t2, NULL, Q, NULL);    R();    pthread_join(t1, NULL);    pthread_join(t2, NULL);    return 0;&#125;</code></pre><h2 id="第六关：理发师问题"><a href="#第六关：理发师问题" class="headerlink" title="第六关：理发师问题"></a>第六关：理发师问题</h2><h3 id="问题背景：理发室问题"><a href="#问题背景：理发室问题" class="headerlink" title="问题背景：理发室问题"></a>问题背景：理发室问题</h3><p>假设理发店由等待间（ 2 个座位）和理发间（只有一个座位）构成，5 位顾客先后进入等待间，再进入理发间。试写出模拟理发师和顾客的程序，要求为每一个顾客创建一个线程。</p><h3 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h3><p>用empty表示当前休息室空座位数目，控制进程的访问。用room表示剩余理发室的个数，为进程分配独占的理发室。用make告诉理发程序当前是否要执行。finish是理发程序告诉客户程序的，意思是“已经理完发了”。</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="lang-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt;#define SEAT_NUM  2#define CUSTOMER_NUM  5#define ROOM_NUM 1/************************************/sem_t empty, room, make, finish;/************************************/void sleep_random(int t) &#123;    sleep((int)(t * (rand() / (RAND_MAX *1.0))));&#125;void *barber()&#123;    while(5)    &#123;        /************************************/        sem_wait(&amp;make);        /************************************/        printf(&quot;barber: start cutting\n&quot;);        sleep_random(3);        printf(&quot;barber: finish cutting\n&quot;);        /************************************/        sem_post(&amp;finish);        /************************************/    &#125;&#125;void *customer(void *id)&#123;    const int myid = *(int*)id;    sleep_random(2);    printf(&quot;customer %d: enter waiting-room\n&quot;, myid);    /************************************/    sem_wait(&amp;empty);    /************************************/    printf(&quot;customer %d: sit down\n&quot;, myid);    /************************************/    sem_wait(&amp;room);    /************************************/    printf(&quot;customer %d: enter cutting-room and sit down\n&quot;, myid);    /************************************/    sem_post(&amp;make);    sem_wait(&amp;finish);    /************************************/    printf(&quot;customer %d: bye\n&quot;, myid);    /************************************/    sem_post(&amp;room);    sem_post(&amp;empty);    /************************************/&#125;int main()&#123;    int i, id[CUSTOMER_NUM];    pthread_t t[CUSTOMER_NUM];    srand((int)time(0));    /************************************/    sem_init(&amp;empty, 0, SEAT_NUM);    sem_init(&amp;make, 0, 0);    sem_init(&amp;room, 0, ROOM_NUM);    sem_init(&amp;finish, 0, 0);    /************************************/    for (i = 0; i &lt; CUSTOMER_NUM; i++)    &#123;        id[i] = i + 1;        pthread_create(&amp;t[i], NULL, customer, &amp;id[i]);    &#125;    barber();    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 实训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Educoder </tag>
            
            <tag> 模拟实训 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown latex的特殊符号</title>
      <link href="/2021/10/17/Markdown/MarkdownSpecialSign/"/>
      <url>/2021/10/17/Markdown/MarkdownSpecialSign/</url>
      
        <content type="html"><![CDATA[<h2 id="一，符号速查"><a href="#一，符号速查" class="headerlink" title="一，符号速查"></a>一，符号速查</h2><div class="table-container"><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">语法</th></tr></thead><tbody><tr><td style="text-align:center">$\sim$ $\textasciitilde$</td><td style="text-align:center">\sim \\textasciitilde</td></tr><tr><td style="text-align:center">$\rightarrow$</td><td style="text-align:center">\rightarrow</td></tr><tr><td style="text-align:center">$\stackrel{\text{Up}}{\underset{Down}{==}}$</td><td style="text-align:center">\stackrel{\text{Up}}{\underset{Down}{==}}</td></tr><tr><td style="text-align:center">$\rightleftharpoons$</td><td style="text-align:center">\rightleftharpoons</td></tr><tr><td style="text-align:center">$\parallel x \parallel$</td><td style="text-align:center">\parallel x \parallel</td></tr><tr><td style="text-align:center">$\sum$，$\prod$</td><td style="text-align:center">\sum \prod</td></tr></tbody></table></div><h2 id="二，输入箭头及上方字符"><a href="#二，输入箭头及上方字符" class="headerlink" title="二，输入箭头及上方字符"></a>二，输入箭头及上方字符</h2><p>大部分符号 … 变成双向只需要将首字母大写，变成长符号只需要在前面加上一个long/Long)</p><hr><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p>   效果1 : $2H_{2}O \stackrel{通电}{\rightarrow} 2H_{2} + O_{2}$</p><p>   效果2 : $2H_{2}O \stackrel{\text{通电}}{==} 2H_{2} + O_{2}$</p><p>   效果3 : $4NH_3 + 5O_2 \stackrel{\text{催化剂}}{\underset{\Delta}{\rightleftharpoons}} 4NO + 6H_2O$</p><p>   效果4 : $\stackrel{-2}{^{16}_{8}O^{2-}_2}$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-markdown">2H_&#123;2&#125;O \stackrel&#123;通电&#125;&#123;\rightarrow&#125; 2H_&#123;2&#125; + O_&#123;2&#125;2H_&#123;2&#125;O \stackrel&#123;\text&#123;通电&#125;&#125;&#123;==&#125; 2H_&#123;2&#125; + O_&#123;2&#125;4NH_3 + 5O_2 \stackrel&#123;\text&#123;催化剂&#125;&#125;&#123;\underset&#123;\Delta&#125;&#123;\rightleftharpoons&#125;&#125; 4NO + 6H_2O\stackrel&#123;-2&#125;&#123;^&#123;16&#125;_&#123;8&#125;O^&#123;2-&#125;_2&#125;</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在\stackrel中，不需要加花括号的时候不要加。</p><h3 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h3><p>   <a href="https://www.zhihu.com/question/356331842">如何用markdown写化学方程式？ - 知乎 (zhihu.com)</a></p><p>   <a href="https://www.bilibili.com/video/BV1mK4y147Lq?from=search&amp;seid=4134217629237576756">化学方程式的Markdown打法_哔哩哔哩_bilibili</a></p><p>   <a href="https://blog.csdn.net/m0_37167788/article/details/78603307">MarkDown - Latex符号(箭头)的整理</a></p><h2 id="三，输入矩阵及数字对齐"><a href="#三，输入矩阵及数字对齐" class="headerlink" title="三，输入矩阵及数字对齐"></a>三，输入矩阵及数字对齐</h2><ol><li><p>小括号/中括号矩阵，行列式，矩阵间等号</p><p>效果</p><p>$\begin{pmatrix}<br> 1 &amp; 0 &amp; 0\\<br> 0 &amp; 1 &amp; 0\\<br> 0 &amp; 0 &amp; 1\\<br>\end{pmatrix}<br>{=}<br>\begin{bmatrix}<br> 1 &amp; 0 &amp; 0\\<br> 0 &amp; 1 &amp; 0\\<br> 0 &amp; 0 &amp; 1\\<br>\end{bmatrix}<br>\quad<br>\begin{vmatrix}<br> 1 &amp; 0 &amp; 0\\<br> 0 &amp; 1 &amp; 0\\<br> 0 &amp; 0 &amp; 1\\<br>\end{vmatrix}$</p><p>代码</p><pre><code class="lang-latex">\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 1\\\end&#123;pmatrix&#125;&#123;=&#125;\begin&#123;bmatrix&#125; 1 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 1\\\end&#123;bmatrix&#125;\quad\begin&#123;vmatrix&#125; 1 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 1\\\end&#123;vmatrix&#125;</code></pre></li><li><p>实现试卷中对齐的选项效果</p><p>效果</p><p>$\begin{array}{cc}<br> (A)\quad 4 &amp; \hspace{4cm}(B)\quad 3\\<br> (C)\quad 2 &amp; \hspace{4cm}(D)\quad 1 \end{array} $</p><p>代码</p><pre><code class="lang-latex">\begin&#123;array&#125;&#123;cc&#125;        (A)\quad 4 &amp; \hspace&#123;4cm&#125;(B)\quad 3\\        (C)\quad 2 &amp; \hspace&#123;4cm&#125;(D)\quad 1\end&#123;array&#125;</code></pre></li><li><p>表格效果</p><p>效果</p><p>$\begin{array}{|c|c|}<br> \hline 0 &amp; 1 \\\hline 1 &amp; 0 \\\hline<br>\end{array}$</p><p>代码</p><pre><code class="lang-lae">\begin&#123;array&#125;&#123;|c|c|&#125;        \hline        0 &amp; 1 \\hline        1 &amp; 0 \\hline\end&#123;array&#125;</code></pre></li><li><p>大括号</p><p>效果</p><p>$\begin{cases}<br> x´=x \text{cos}\theta-y \text{sin}\theta \\<br> y´=x \text{sin}\theta+y \text{cos}\theta \\<br> \end{cases}$</p><p>代码</p><pre><code class="lang-latex">$\begin&#123;cases&#125;      x´=x \text&#123;cos&#125;\theta-y \text&#123;sin&#125;\theta \\      y´=x \text&#123;sin&#125;\theta+y \text&#123;cos&#125;\theta \\\end&#123;cases&#125;$</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows和Linux的日常琐事</title>
      <link href="/2021/10/12/Operation%20System/Windows%20%E5%92%8C%20Linux%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/10/12/Operation%20System/Windows%20%E5%92%8C%20Linux%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="Win10-清除-PowerShell-历史记录"><a href="#Win10-清除-PowerShell-历史记录" class="headerlink" title="Win10 清除 PowerShell 历史记录"></a>Win10 清除 PowerShell 历史记录</h3><pre><code class="lang-powershell">Remove-Item (Get-PSReadlineOption).HistorySavePath</code></pre><p>重启Windows terminal后生效</p><h3 id="Win10下的简繁体切换"><a href="#Win10下的简繁体切换" class="headerlink" title="Win10下的简繁体切换"></a>Win10下的简繁体切换</h3><p>快捷键：<code>ctrl</code>+<code>shift</code>+<code>F</code></p><p>这个键和Android Studio的全局搜索冲突了。。。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 平时应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Windows </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educoder 操作系统实训4.x实验</title>
      <link href="/2021/10/07/Operation%20System/Educoder%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%AE%AD4.x/"/>
      <url>/2021/10/07/Operation%20System/Educoder%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%AE%AD4.x/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览之前"><a href="#浏览之前" class="headerlink" title="浏览之前"></a>浏览之前</h1><p><a href="https://www.educoder.net/paths/2104">实训地址</a></p><font size = 5 color = blue>本文比较长，建议使用大纲视图观看文章</font><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/大纲视图.png" alt="如何使用大纲视图"></p><h1 id="实训4-1：段式内存管理"><a href="#实训4-1：段式内存管理" class="headerlink" title="实训4.1：段式内存管理"></a>实训4.1：段式内存管理</h1><h2 id="第一关，第二关：不是自己做的，略过"><a href="#第一关，第二关：不是自己做的，略过" class="headerlink" title="第一关，第二关：不是自己做的，略过"></a>第一关，第二关：不是自己做的<img src="https://tb2.bdstatic.com/tb/editor/images/face/i_f25.png?t=20140803" alt="">，略过</h2><h2 id="第三关：0号进程和1号进程的mynext变量的取值变化"><a href="#第三关：0号进程和1号进程的mynext变量的取值变化" class="headerlink" title="第三关：0号进程和1号进程的mynext变量的取值变化"></a>第三关：0号进程和1号进程的mynext变量的取值变化</h2><pre><code class="lang-sh">#终端1cp /data/workspace/myshixun/exp1/1.3.tgz ~/os/cd ~/os/linux-0.11-labtar -zxvf ../1.3.tgzrm -rf curln -s 1.3 curcd cur/linuxmakecd ../.../rungdb# 终端二b main.c:155# 连输7个cc</code></pre><p>只能查到进程一的mynext，不会查进程0的mynext</p><p>不过我搞到了答案</p><pre><code class="lang-shell">1.1 号进程的 output_char 函数调用会执行几次？(6)2.每次调用时，1 号进程和 0 号进程的 mynext 变量的值分别是多少？(1,1)(2,7)(3,7)(4,7)(5,7)(6,7)注：如果括号不够可以自行使用英文括号补充格式为(,)，如果括号数量不对评测时将会报错。</code></pre><h2 id="第四关：LDTR-寄存器"><a href="#第四关：LDTR-寄存器" class="headerlink" title="第四关：LDTR 寄存器"></a>第四关：LDTR 寄存器</h2><h3 id="实验方法"><a href="#实验方法" class="headerlink" title="实验方法"></a>实验方法</h3><p>先通过gdb找到main.c:155对应的汇编指令位置为0x6969。<br>然后找到main.c:171对应的汇编指令位置为0x69cf。<br>查看寄存器值和段描述符，查看ldtr的值，算出gdt索引为7，和对应的段起始地址。<br>再查看gdb中0，1号进程对应的ldt位置，查询命令为</p><pre><code class="lang-gdb">p &amp;current-&gt;ldt</code></pre><pre><code class="lang-sh">./rundbgb 0x6969csregx/16wx 0x5cc0b 0x69cfcsreg</code></pre><h3 id="本关答案"><a href="#本关答案" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">1.1 号进程（在用户态）运行时，LDTR 寄存器的值是多少？(0x0038)它指向 GDT 中的几号描述符？(7)该段描述符内存的段起始地址是多少？(0xfff2d0)指向哪个进程的 ldt 数组？(1)2.0 号进程（在用户态）运行时，LDTR 寄存器的值是多少？(0x0028)它指向 GDT 中的几号描述符？(5)该段描述符内存的段起始地址是多少？(0x1ed70)指向哪个进程的 ldt 数组？(0)</code></pre><h2 id="第五关：内核代码段和数据段的段基址"><a href="#第五关：内核代码段和数据段的段基址" class="headerlink" title="第五关：内核代码段和数据段的段基址"></a>第五关：内核代码段和数据段的段基址</h2><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>基地址就是段起始地址！</p><h3 id="实验方法-1"><a href="#实验方法-1" class="headerlink" title="实验方法"></a>实验方法</h3><p>以下是GDB中的操作</p><pre><code class="lang-sh">b sys_pausecinfo regx/6wx gdt# 发现cs:0x0008,ds:0x0010,说明段起始地址在gdt中索引分别为1，2，计算cs和ds基地址为0x0cinfo regx/6wx gdt</code></pre><h3 id="本关答案-1"><a href="#本关答案-1" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">1.0 号进程执行到 sys_pause 时，默认数据段（CS）和默认数据段（DS）的值分别是多少？(0x0008)(0x0010)其基地址分别是多少？(0)(0)2.1 号进程执行到 sys_pause 时，默认数据段（CS）和默认数据段（DS）的值分别是多少？(0x0008)(0x0010)其基地址分别是多少？(0)(0)</code></pre><h1 id="实训4-2-页式内存管理"><a href="#实训4-2-页式内存管理" class="headerlink" title="实训4.2 页式内存管理"></a>实训4.2 页式内存管理</h1><h2 id="第一关：1-号进程的-mynext-变量的物理地址"><a href="#第一关：1-号进程的-mynext-变量的物理地址" class="headerlink" title="第一关：1 号进程的 mynext 变量的物理地址"></a>第一关：1 号进程的 mynext 变量的物理地址</h2><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>每个目录项和页表项都是以<strong>4字节</strong> (32位机器)的长度存储的数据. 由于页面表和页面的起始地址都总是在4K字节的边界上, 这些指针的低12位都永远是0.</p><h3 id="实验方法-2"><a href="#实验方法-2" class="headerlink" title="实验方法"></a>实验方法</h3><pre><code class="lang-sh">b 0x6969ccreg # 页表起始地址CR3为0x/wx 0x17:0x2282c# 线性地址为0x402282c# 页目录项索引0x10(在页目录的第16号)，页表索引0x22(在页表的第34号)x/17wx 0 # 这里的0是CR3的值，发现页表基址为0xffe000(页表项的后12位都是0)x/35wx 0xffe000 # 页帧起始地址0x00022(页表元素的前12位)ccregx/wx 0x17:0x2282cx/17wx 0x/35wx 0xffe000</code></pre><h3 id="实验答案"><a href="#实验答案" class="headerlink" title="实验答案"></a>实验答案</h3><pre><code class="lang-sh">1.1 号进程第 1 次调用函数 output_char 时，它的 mynext 变量的物理地址是多少？(0x2282c)2.1 号进程第 2 次调用函数 output_char 时，它的 mynext 变量的物理地址是多少？(0xffc82c)</code></pre><h2 id="第二关：0-号进程的-mynext-变量的物理地址"><a href="#第二关：0-号进程的-mynext-变量的物理地址" class="headerlink" title="第二关：0 号进程的 mynext 变量的物理地址"></a>第二关：0 号进程的 mynext 变量的物理地址</h2><h3 id="实验方法-3"><a href="#实验方法-3" class="headerlink" title="实验方法"></a>实验方法</h3><pre><code class="lang-sh">./rundbgb 0x69d9cx/wx 0x17:0x2282c# 线性地址为0x402282c# 页目录项索引0x0(在页目录的第0号)，页表索引0x22(在页表的第34号)x/17wx 0x/35wx 0x00001000cx/17wx 0x/35wx 0x00001000</code></pre><h3 id="本关答案-2"><a href="#本关答案-2" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">都是0x2282c</code></pre><h2 id="第三关：页目录和页表的变化"><a href="#第三关：页目录和页表的变化" class="headerlink" title="第三关：页目录和页表的变化"></a>第三关：页目录和页表的变化</h2><h3 id="实验方法-4"><a href="#实验方法-4" class="headerlink" title="实验方法"></a>实验方法</h3><pre><code class="lang-sh">b 0x6969ccregx/17wx 0x/35wx 0xffe000info tabccregx/17wx 0x/35wx 0xffe000info tab</code></pre><p>本关答案</p><pre><code class="lang-sh">在 1 号进程第 1 次开始执行 output_char 函数调用时，线性地址空间到物理地址空间的映射关系是怎样的？1.(0x00000000-0x00ffffff-&gt;0x00000000-0x00ffffff)2.(0x04000000-0x04024fff-&gt;0x00000000-0x00024fff)3.(0x04025000-0x04025fff-&gt;0x00ffd000-0x00ffdfff)4.(0x04026000-0x0409ffff-&gt;0x00026000-0x0009ffff)在 1 号进程第 2 次开始执行 output_char 函数调用时，线性地址空间到物理地址空间的映射关系是怎样的？5.(0x00000000-0x00ffffff-&gt;0x00000000-0x00ffffff)6.(0x04000000-0x04021fff-&gt;0x00000000-0x00021fff)7.(0x04022000-0x04022fff-&gt;0x00ffc000-0x00ffcfff)8.(0x04023000-0x04024fff-&gt;0x00023000-0x00024fff)9.(0x04025000-0x04025fff-&gt;0x00ffd000-0x00ffdfff)10.(0x04026000-0x0409ffff-&gt;0x00026000-0x0009ffff)在 1 号进程的第 1、2 次 output_char 函数调用之间，页目录和页表发生了怎样的变化？11.页表项(0x00ffe088)的值由原来的(0x00022065)变为了(0x00ffc067)</code></pre><h2 id="第四关：用户栈和核心栈的物理位置"><a href="#第四关：用户栈和核心栈的物理位置" class="headerlink" title="第四关：用户栈和核心栈的物理位置"></a>第四关：用户栈和核心栈的物理位置</h2><h3 id="实验方法-5"><a href="#实验方法-5" class="headerlink" title="实验方法"></a>实验方法</h3><pre><code class="lang-sh"># 终端一，这次1环境跑到exp4里了。。。cp /data/workspace/myshixun/exp4/1.tgz ~/os/cd ~/os/linux-0.11-labtar -zxvf ../1.tgzrm -rf curln -s 1 curcd cur/linuxmakecd ../.../rungdb</code></pre><pre><code class="lang-sh">./mygdbb schedulecccp/x task[0]p/x task[1]b task0c# 打开dbg# 今后再用GDB，就是查询寄存器变量了</code></pre><pre><code class="lang-sh">./rundbgb 0x7963cx/wx 0x1fa20 #查看当前进程地址sregx/wx 0x17:0x2573ccregx/wx 0x/38wx 0x1000b 0x6f46cx/wx 0x1fa20sreg# sreg查不到寄存器具体的值，我是用gdb查的，有谁能告诉我# 怎么再bochs查寄存器的值吗，发个邮件如何？x/wx 0x8:0x1f9f0cregx/wx 0x/32wx 0x1000b 0x7985cx/wx 0x1fa20sregx/wx 0x17:0x2573ccregx/17wx 0x/38wx 0xffe000csregx/wx 0x1fa20sregx/wx 0x10:0xffffd0cregx/4wx 0x/1024wx 0x4000</code></pre><h3 id="本关答案-3"><a href="#本关答案-3" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">使用版本 1 内核时，在第 2 次进程调度后：1.0 号进程和 1 号进程的进程控制块的地址分别是多少？(0x1ea20)(0xfff000)2.执行到函数 task0 时，0 号进程的用户栈栈顶位于物理内存何处？(0x2573c)3.0 号进程执行到函数 sys_pause 时，核心栈栈顶位于物理内存何处？(0x1f9f0)4.执行到函数 task1 时，1 号进程的用户栈栈顶位于物理内存何处？(0xffd73c)5.1 号进程执行到函数 sys_pause 时，核心栈栈顶位于物理内存何处？(0xffffd0)</code></pre><h1 id="实训4-3：段页式内存管理"><a href="#实训4-3：段页式内存管理" class="headerlink" title="实训4.3：段页式内存管理"></a>实训4.3：段页式内存管理</h1><h2 id="第一关：进程创建前后页目录和页表的变化"><a href="#第一关：进程创建前后页目录和页表的变化" class="headerlink" title="第一关：进程创建前后页目录和页表的变化"></a>第一关：进程创建前后页目录和页表的变化</h2><h3 id="实验方法-6"><a href="#实验方法-6" class="headerlink" title="实验方法"></a>实验方法</h3><blockquote><p>作者：富平理查德</p><p>不是RedLeaves自己做的~<img src="https://tb2.bdstatic.com/tb/editor/images/face/i_f25.png?t=20140803" alt="">)，讲解以后再补</p></blockquote><pre><code class="lang-sh">./rundbgb 0x6908 # (gdb操作中可知)cinfo tabnextnextb 0x690acinfo tabx/35wx 0</code></pre><h3 id="本关答案-4"><a href="#本关答案-4" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">在 0 号进程执行 fork 系统调用之前，线性地址空间到物理地址空间的映射关系是怎样的？1.(0x00000000-0x00ffffff-&gt;0x00000000-0x00ffffff)在 0 号进程刚执行完 fork 系统调用时，线性地址空间到物理地址空间的映射关系是怎样的？2.(0x00000000-0x00ffffff-&gt;0x00000000-0x00ffffff)(0x04000000-0x0409ffff-&gt;0x00000000-0x0009ffff)在 0 号进程执行 fork 系统调用前后，页目录发生了怎样的变化？3.页目录项(0x0000000c)的值由原来的(0x00004007)变为了(0x00004027)4.页目录项(0x00000040)的值由原来的(0x00000000)变为了(0x00ffe007)</code></pre><h2 id="第二关：1-号进程对-mynext-变量的第一次修改"><a href="#第二关：1-号进程对-mynext-变量的第一次修改" class="headerlink" title="第二关：1 号进程对 mynext 变量的第一次修改"></a>第二关：1 号进程对 mynext 变量的第一次修改</h2><blockquote><p>作者：富平理查德</p><p>不是RedLeaves自己做的~<img src="https://tb2.bdstatic.com/tb/editor/images/face/i_f25.png?t=20140803" alt="">，但是做了一些完善，讲解以后再补</p></blockquote><h3 id="实验方法-7"><a href="#实验方法-7" class="headerlink" title="实验方法"></a>实验方法</h3><pre><code class="lang-sh"># 这次的1.3怎么放在exp2里了。。。cp /data/workspace/myshixun/exp2/1.3.tgz ~/os/cd ~/os/linux-0.11-labtar -zxvf ../1.3.tgzrm -rf curln -s 1.3 curcd cur/linuxmakecd ../.../rungdb</code></pre><pre><code class="lang-sh">./rundbgb 0x6980 # 注意：这里是评分点，必须亲自用GDB下断点再disas查一下cx/wx 0x17:0x2282cx/17wx 0x/35wx 0xffe000scregu/35b 0xb1d6ccregx/35wx 0xffe000sxp/wx 0x2282csxp/wx 0xffc82c</code></pre><h3 id="本关答案-5"><a href="#本关答案-5" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">1.1 号进程修改 mynext 变量的指令地址是多少？(0x6988)2.1 号进程的 mynext 变量的线性地址是多少？(0x402282c)3.在 1 号进程第一次修改 mynext 变量之前，上述线性地址对应的页表项的值是多少？(0x22065)该线性地址被映射到的物理地址（旧物理地址）是多少？(0x2282c)4.在 1 号进程第一次修改 mynext 变量时，会引发页故障，在页故障处理程序刚开始执行时，CR2 寄存器的值是多少？(0x402282c)5.在此页故障处理完回到恢复点时，恢复点的地址是什么？(0xb1d6)此时上述线性地址对应的页表项的值是多少？(0x00ffc007)该线性地址被映射到的物理地址（新物理地址）是多少？(0x00ffc82c)6.在恢复点指令执行后，上述新物理地址处的值是多少？(0x00000002)上述旧物理地址处的值是多少？(0x00000001)</code></pre><h2 id="第三关-第一次页故障"><a href="#第三关-第一次页故障" class="headerlink" title="第三关 第一次页故障"></a>第三关 第一次页故障</h2><h3 id="实验方法-8"><a href="#实验方法-8" class="headerlink" title="实验方法"></a>实验方法</h3><pre><code class="lang-sh"># 打开GDB，查询page_fault地址为0xb124./rundbgb 0xb124cx/wx 0x1fa20cregx/17wx 0x/38wx 0xffe000b 0x690acx/17wx 0x/38wx 0xffe000# 在已经开启的GDB中输入b main.c:145cnsidisasb *0x6908</code></pre><h3 id="本关答案-6"><a href="#本关答案-6" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">系统的第一次页故障发生时：1.当时正在执行几号进程？(1)正在访问的线性地址是多少？(0x0402574c)2.该线性地址当时对应的页表项是什么？(0x00025065)被映射到的物理地址是什么？(0x0002574c)3.该页故障处理完后，该线性地址对应的页表项是什么？(0x00ffd007)被映射到的物理地址是什么？(0x00ffd74c)4.引发这次页故障的指令地址是什么？(0x690a)5. main 函数中的 fork 系统调用的陷入指令的地址是多少？(0x6908)</code></pre><h2 id="第四关：父子进程间的共享内存通信实现"><a href="#第四关：父子进程间的共享内存通信实现" class="headerlink" title="第四关：父子进程间的共享内存通信实现"></a>第四关：父子进程间的共享内存通信实现</h2><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>现在还没弄懂<img src="https://tb2.bdstatic.com/tb/editor/images/face/i_f35.png?t=20140803" alt=""></p><h3 id="实验方法-9"><a href="#实验方法-9" class="headerlink" title="实验方法"></a>实验方法</h3><p>修改memory.c的for循环</p><pre><code class="lang-c">for ( ; nr-- &gt; 0 ; from_page_table++,to_page_table++) &#123;    this_page = *from_page_table;    if (!(1 &amp; this_page))        continue;    if (to_page_table == 0xffe088) this_page |= 2;    else this_page &amp;= ~2;    *to_page_table = this_page;    if (this_page &gt; LOW_MEM) &#123;        *from_page_table = this_page;        this_page -= LOW_MEM;        this_page &gt;&gt;= 12;        mem_map[this_page]++;    &#125;&#125;</code></pre><p>修改main.c的如下两个片段</p><p>151行左右</p><pre><code class="lang-c">if (!fork()) &#123;        /* we count on this going ok */    (void)mysignal(SIGALRM, SIG_IGN);    int flag = 0;    for(;;) &#123;        if (flag == 0) &#123;            flag = 1;            output_char(&#39;A&#39; + mynext);            mynext++;        &#125;        else &#123;            mynext ++;            mynext %= 26;            output_char(&#39;A&#39; + mynext);        &#125;        alarm(1);        pause();     &#125;    //  init();&#125;</code></pre><p>第170行左右</p><pre><code class="lang-c">for(;;) &#123;            /* wyj */    output_char(&#39;a&#39; + mynext);    mynext++;    mynext %= 26;    pause(); &#125;</code></pre><p>别忘了<font size = 6 color = "red">编译！</font></p><h1 id="实训4-4：页式虚存"><a href="#实训4-4：页式虚存" class="headerlink" title="实训4.4：页式虚存"></a>实训4.4：页式虚存</h1><h2 id="第一关：版本-0-内核的第一次缺页页故障"><a href="#第一关：版本-0-内核的第一次缺页页故障" class="headerlink" title="第一关：版本 0 内核的第一次缺页页故障"></a>第一关：版本 0 内核的第一次缺页页故障</h2><h3 id="实验方法-10"><a href="#实验方法-10" class="headerlink" title="实验方法"></a>实验方法</h3><pre><code class="lang-bash">b do_no_pagecp/x addressp/x current-&gt;start_codex/32wx 0p 0x8000000 &gt;&gt; 22p (unsigned)0x8000000&lt;&lt;10&gt;&gt;22p/x current-&gt;start_codeb memory.c:381b memory.c:387b memory.c:394cp/x pagenp/x pagex/4wx 0xffa000cnx/4wx 0xffa000p/x pagecnp/x pagep/x 0xffa000x/33wx 0x/33wx 0xff7000</code></pre><h3 id="本关答案-7"><a href="#本关答案-7" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">1.该页故障由几号进程引发？(2)2.在该故障发生前，该进程执行的最后一个可执行文件是什么？(/bin/sh)该可执行文件的第2块（每块1KB）的头16字节的内容是什么？(8b 44 24 08 a3 00 f0 02 00 e8 26 01 00 00 6a 00)头16字节的内容按照(00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00)这种格式填写。3.引发该页故障的线性地址是什么？(0x8000000)该进程的代码段起始地址是多少？(0x8000000)4.该页故障处理前，该线性地址对应的页目录项的地址和值分别是什么？(0x80)(0)5.该页故障处理时，申请到的空闲页帧的起始地址是什么？(0xffa000)该页帧的头16字节的内容是什么？(00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00)6.该页故障处理过程中、读入硬盘数据后，上述页帧的头16字节的内容是什么？(8b 44 24 08 a3 00 f0 02 00 e8 26 01 00 00 6a 00)7.该页故障处理过程中、修改对应的页表项后，上述线性地址对应的页表项的值是什么？(0x00ffa007)</code></pre><h2 id="第二关：第一次使用零页的缺页页故障"><a href="#第二关：第一次使用零页的缺页页故障" class="headerlink" title="第二关：第一次使用零页的缺页页故障"></a>第二关：第一次使用零页的缺页页故障</h2><h3 id="补充：mcopy命令"><a href="#补充：mcopy命令" class="headerlink" title="补充：mcopy命令"></a>补充：mcopy命令</h3><p>Linux mcopy命令用来复制 MSDOS 格式文件到 Linux 中，或是由 Linux 中复制 MSDOS 文件到磁片上。</p><p>mcopy 可复制单一的文件到所指定的文件名称，或是复制数个文件到所指定的目录之中。来源与目的文件可为 MSDOS 或是 Linux 文件。</p><p>mcopy指令是一种mtools工具指令，可以在DOS系统中复制文件或者在DOS与Linux操作系统之间进行文件复制。</p><h4 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h4><pre><code class="lang-sh">mcopy [-bspanvmQT] [-D clash_option] sourcefile targetfilemcopy [-bspanvmQT] [-D clash_option] sourcefile [ sourcefiles... ] targetdirectorymcopy [-tnvm] MSDOSsourcefile</code></pre><h4 id="实例：将虚拟机中-bin-sh文件复制到”b盘“中"><a href="#实例：将虚拟机中-bin-sh文件复制到”b盘“中" class="headerlink" title="实例：将虚拟机中/bin/sh文件复制到”b盘“中"></a>实例：将虚拟机中/bin/sh文件复制到”b盘“中</h4><pre><code class="lang-sh">mcopy /bin/sh b:</code></pre><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>mcopy命令在<strong>关机后</strong>才会生效，当复制的内容包括子目录和文件时，必须使用参数”-/“递归操作。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.gnu.org/software/mtools/manual/html_node/mcopy.html">Mtools 4.0.20: mcopy (gnu.org)</a></p><p><a href="https://www.runoob.com/linux/linux-comm-mcopy.html">Linux mcopy命令 | 菜鸟教程 (runoob.com)</a></p><h3 id="实验方法-11"><a href="#实验方法-11" class="headerlink" title="实验方法"></a>实验方法</h3><p>本次实验分为两步</p><h4 id="第一步：查看sh文件的VMA"><a href="#第一步：查看sh文件的VMA" class="headerlink" title="第一步：查看sh文件的VMA"></a>第一步：查看sh文件的VMA</h4><p>将/bin/sh文件从虚拟机复制到~/os/linux-0.11-lab/b目录下</p><p>使用objdump命令查看VMA(起始虚拟地址)</p><pre><code class="lang-sh">objdump -dlx sh | less</code></pre><p>查看结果如下</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/shixun/实训4.4-L2-objdump.png" alt="objdump查看结果"></p><h4 id="第二步：在GDB中调试"><a href="#第二步：在GDB中调试" class="headerlink" title="第二步：在GDB中调试"></a>第二步：在GDB中调试</h4><pre><code class="lang-bash">b do_no_pageb do_execvecommands 2p curent-&gt;start_code + filenameendccb memory.c:376ccccccp/x addressx/33wx 0x/51wx 0xff7000nx/33wx 0x/51wx 0xff7000x/4wx 0xff2000</code></pre><h3 id="本关答案-8"><a href="#本关答案-8" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">1.该页故障由几号进程引发？(2)2.在该故障发生前，该进程执行的最后一个可执行文件是什么？(/bin/sh)该可执行文件的未初始化数据段（BSS）的起始虚拟地址（VMA）是什么？(0x32000)3.引发该页故障的线性地址是什么？(0x8032000)4.该页故障处理前，该线性地址对应的页表项的地址和值分别是什么？(0xff70c8)(0)5.该页故障处理后，上述线性地址对应的页表项的值是什么？(0x00ff2007)该线性地址被映射到的零页（新页帧）的起始地址是什么？(0xff2000)6.该新页帧的头 16 个字节是什么？(00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00)头 16 个字节按照(00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00)</code></pre><h2 id="第三关：可执行文件的执行"><a href="#第三关：可执行文件的执行" class="headerlink" title="第三关：可执行文件的执行"></a>第三关：可执行文件的执行</h2><h3 id="实验方法-12"><a href="#实验方法-12" class="headerlink" title="实验方法"></a>实验方法</h3><p>在Ubuntu</p><pre><code class="lang-bash">cp /data/workspace/myshixun/exp1/01.c ~/os/linux-0.11-lab/b</code></pre><p>在Bochs虚拟机内输入以下命令，然后关闭虚拟机</p><pre><code class="lang-ba">mcopy b:01.c /usr/rootgcc 01.c -o 01sync</code></pre><p>打开GDB调试</p><pre><code class="lang-sh">b do_execvecommands 2p current-&gt;start_code + filenameendc# 一直c到continuing.</code></pre><p>在Bochs中输入</p><pre><code class="lang-sh">/usr/root/01</code></pre><p>回到GDB，可以看到打印出了当前运行的程序，然后进行下列操作</p><pre><code class="lang-sh">p/x current-&gt;start_codep/x current-&gt;brkx/65wx 0x/68wx 0xfb5000nfinishp/x current-&gt;start_codep/x current-&gt;brkx/65wx 0x/wx 0x100</code></pre><h3 id="本关答案-9"><a href="#本关答案-9" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">1.执行该文件的execve系统调用刚开始执行时，该进程的用户虚空间是什么？(0x10000000~0x10043fff)该空间的第一个页表项和最后一个页表项分别是什么？(0x00ff9025)(0x00fea065)2.执行该文件的execve系统调用执行结束时，该进程的用户虚空间是什么？(0x10000000~0x10004fff)该空间占据几个页目录项？(1)第一个页目录项的地址和值分别是什么？(0x100)(0x00000000)3.该可执行文件的代码段和数据段的长度之和是多少？(0x5000)</code></pre><h2 id="第四关：可执行文件的加载"><a href="#第四关：可执行文件的加载" class="headerlink" title="第四关：可执行文件的加载"></a>第四关：可执行文件的加载</h2><p>未完待续</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 实训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Educoder </tag>
            
            <tag> 模拟实训 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educoder 编译原理实训1</title>
      <link href="/2021/10/06/Compiler/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E8%AE%AD1/"/>
      <url>/2021/10/06/Compiler/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E8%AE%AD1/</url>
      
        <content type="html"><![CDATA[<h2 id="用LEX-FLEX-生成PL语言的词法分析器-2021-09"><a href="#用LEX-FLEX-生成PL语言的词法分析器-2021-09" class="headerlink" title="用LEX(FLEX)生成PL语言的词法分析器(2021.09)"></a>用LEX(FLEX)生成PL语言的词法分析器(2021.09)</h2><h3 id="第1关-什么是lex-flex？"><a href="#第1关-什么是lex-flex？" class="headerlink" title="第1关 什么是lex/flex？"></a>第1关 什么是lex/flex？</h3><pre><code class="lang-c">/* 简单词法分析器 *//* 功能：能够识别出以小写字母ab结尾的所有字符串（仅含大小写字母）并给打印&#39;Hit!&#39; *//* 说明：在下面的begin和end之间添加代码，已经实现了标识符和整常量的识别，你需要完成剩下的部分，加油吧！ *//* 提示：你只需要保证合法的输入（以字符双引号开头和结尾的字符串、中间是若干(可空)英文大小写字母的符号串的识别）*/%&#123;#include &lt;stdio.h&gt;%&#125;%% /* begin */\&quot;[a-zA-Z]*\&quot; &#123;printf(&quot;%s: Hit!\n&quot;, yytext);&#125; /* end */\n    &#123;&#125;.    &#123;&#125;%%int yywrap() &#123; return 1; &#125;int main(int argc, char **argv)&#123; if (argc &gt; 1) &#123;  if (!(yyin = fopen(argv[1], &quot;r&quot;))) &#123;   perror(argv[1]);   return 1;  &#125; &#125; while (yylex()); return 0;&#125;</code></pre><h3 id="第2关-用flex生成PL语言的词法分析器"><a href="#第2关-用flex生成PL语言的词法分析器" class="headerlink" title="第2关 用flex生成PL语言的词法分析器"></a>第2关 用flex生成PL语言的词法分析器</h3><pre><code class="lang-c">/* PL词法分析器 *//* 功能：能够识别出PL支持的所有单词符号并给出种别值 *//* 说明：在下面的begin和end之间添加代码，已经实现了标识符和整常量的识别，你需要完成剩下的部分，加油吧！ *//* 提示：因为是顺序匹配，即从上至下依次匹配规则，所以需要合理安排顺序～ */%&#123;#include &lt;stdio.h&gt;%&#125; /* begin */INTCON   [\-]?[1-9][0-9]*|0IDENT   [A-Za-z][A-Za-z0-9]*CHARCON \&#39;[^&#39;]*\&#39;PLUS    \+MINUS   \-TIMES   \*DIVSYM  \/EQL     \=NEQ     \&lt;\&gt;LEQ     \&lt;\= GEQ     \&gt;\=LSS     \&lt;GTR     \&gt;LBRACK  \[RBRACK  \]LPAREN  \(RPAREN  \)COMMA   \,SEMICOLON \;PERIOD  \.BECOME  \:\=COLON   \:ERROR   [~!@#$%^&amp;_\\] /* end */%% /* begin */of               &#123;printf(&quot;%s: OFSYM NULL\n&quot;, yytext);&#125;array        &#123;printf(&quot;%s: ARRAYSYM NULL\n&quot;, yytext);&#125;program        &#123;printf(&quot;%s: PROGRAMSYM NULL\n&quot;, yytext);&#125;mod            &#123;printf(&quot;%s: MODSYM NULL\n&quot;, yytext);&#125;and            &#123;printf(&quot;%s: ANDSYM NULL\n&quot;, yytext);&#125;or            &#123;printf(&quot;%s: ORSYM NULL\n&quot;, yytext);&#125;not            &#123;printf(&quot;%s: NOTSYM NULL\n&quot;, yytext);&#125;begin        &#123;printf(&quot;%s: BEGINSYM NULL\n&quot;, yytext);&#125;end            &#123;printf(&quot;%s: ENDSYM NULL\n&quot;, yytext);&#125;if            &#123;printf(&quot;%s: IFSYM NULL\n&quot;, yytext);&#125;then        &#123;printf(&quot;%s: THENSYM NULL\n&quot;, yytext);&#125;else        &#123;printf(&quot;%s: ELSESYM NULL\n&quot;, yytext);&#125;while        &#123;printf(&quot;%s: WHILESYM NULL\n&quot;, yytext);&#125;do            &#123;printf(&quot;%s: DOSYM NULL\n&quot;, yytext);&#125;call        &#123;printf(&quot;%s: CALLSYM NULL\n&quot;, yytext);&#125;const        &#123;printf(&quot;%s: CONSTSYM NULL\n&quot;, yytext);&#125;type        &#123;printf(&quot;%s: TYPESYM NULL\n&quot;, yytext);&#125;var            &#123;printf(&quot;%s: VARSYM NULL\n&quot;, yytext);&#125;procedure    &#123;printf(&quot;%s: PROCSYM NULL\n&quot;, yytext);&#125;&#123;INTCON&#125;    &#123;printf(&quot;%s: INTCON %s\n&quot;, yytext, yytext);&#125;&#123;IDENT&#125;      &#123;printf(&quot;%s: IDENT %s\n&quot;, yytext, yytext);&#125;&#123;CHARCON&#125;    &#123;printf(&quot;%s: CHARCON %s\n&quot;, yytext, yytext);&#125;&#123;PLUS&#125;      &#123;printf(&quot;%s: PLUS NULL\n&quot;, yytext);&#125;&#123;MINUS&#125;      &#123;printf(&quot;%s: MINUS %s\n&quot;, yytext, yytext);&#125;&#123;TIMES&#125;      &#123;printf(&quot;%s: TIMES NULL\n&quot;, yytext);&#125;&#123;DIVSYM&#125;    &#123;printf(&quot;%s: DIVSYM NULL\n&quot;, yytext);&#125;&#123;EQL&#125;      &#123;printf(&quot;%s: EQL NULL\n&quot;, yytext);&#125;&#123;NEQ&#125;      &#123;printf(&quot;%s: NEQ NULL\n&quot;, yytext);&#125;&#123;LEQ&#125;      &#123;printf(&quot;%s: LEQ NULL\n&quot;, yytext);&#125;&#123;GEQ&#125;      &#123;printf(&quot;%s: GEQ NULL\n&quot;, yytext);&#125;&#123;LSS&#125;      &#123;printf(&quot;%s: LSS NULL\n&quot;, yytext);&#125;&#123;GTR&#125;      &#123;printf(&quot;%s: GTR NULL\n&quot;, yytext);&#125;&#123;LBRACK&#125;    &#123;printf(&quot;%s: LBRACK NULL\n&quot;, yytext);&#125;&#123;RBRACK&#125;    &#123;printf(&quot;%s: RBRACK NULL\n&quot;, yytext);&#125;&#123;LPAREN&#125;    &#123;printf(&quot;%s: LPAREN NULL\n&quot;, yytext);&#125;&#123;RPAREN&#125;    &#123;printf(&quot;%s: RPAREN NULL\n&quot;, yytext);&#125;&#123;COMMA&#125;      &#123;printf(&quot;%s: COMMA NULL\n&quot;, yytext);&#125;&#123;SEMICOLON&#125;    &#123;printf(&quot;%s: SEMICOLON NULL\n&quot;, yytext);&#125;&#123;PERIOD&#125;    &#123;printf(&quot;%s: PERIOD NULL\n&quot;, yytext);&#125;&#123;BECOME&#125;      &#123;printf(&quot;%s: BECOME NULL\n&quot;, yytext);&#125;&#123;COLON&#125;      &#123;printf(&quot;%s: COLON NULL\n&quot;, yytext);&#125;&#123;ERROR&#125;      &#123;printf(&quot;%s: ERROR\n&quot;, yytext);&#125; /* end */\n    &#123;&#125;.    &#123;&#125;%%int yywrap() &#123; return 1; &#125;int main(int argc, char **argv)&#123; if (argc &gt; 1) &#123;  if (!(yyin = fopen(argv[1], &quot;r&quot;))) &#123;   perror(argv[1]);   return 1;  &#125; &#125; while (yylex()); return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 编译器前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Educoder </tag>
            
            <tag> 编译原理 </tag>
            
            <tag> 模拟实训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机基本概念</title>
      <link href="/2021/10/03/Programming%20Language/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2021/10/03/Programming%20Language/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="概念一：逻辑移位和算数移位"><a href="#概念一：逻辑移位和算数移位" class="headerlink" title="概念一：逻辑移位和算数移位"></a>概念一：逻辑移位和算数移位</h2><p>在左移的情况下，逻辑移位和算数移位概念不必区分。</p><p>在右移的情况下：</p><ol><li><p>逻辑移位：</p><p>在C语言中，无符号数使用逻辑移位，左面的位用0补齐，例子中的数为一个8位二进制数</p><p>举例 </p><p>$(01100011)_2  \stackrel{\text{逻辑右移一位}}{\rightarrow} (00110001)_2$</p><p>$(11100011)_2  \stackrel{\text{逻辑右移一位}}{\rightarrow} (01110001)_2$</p><pre><code class="lang-c">unsigned int a;</code></pre></li><li><p>算数移位：</p><p>在C语言中，有符号数使用算数移位，左面的位用高位补齐，例子中的数为一个8位二进制数</p><p>举例</p><p>$(01100011)_2  \stackrel{逻辑右移一位}{\rightarrow} (00110001)_2$</p><p>$(11100011)_2  \stackrel{逻辑右移一位}{\rightarrow} (11110001)_2$</p><pre><code class="lang-c">int a;</code></pre></li><li><p>示例</p><p>试说明以下程序的输出：</p><pre><code class="lang-c">#include &lt;stdio.h&gt;int main() &#123;    int x = -1;    unsigned int xx = 0xffffffff;    printf(&quot;%d\n&quot;, (int)(x &gt;&gt; 1));//将结果强制以整形输出，-1，即0xffffffff    printf(&quot;%d\n&quot;, (int)(xx &gt;&gt; 1));//输出2147483647，即0x7fffffff    return 0;&#125;</code></pre></li></ol><h2 id="概念二：补码"><a href="#概念二：补码" class="headerlink" title="概念二：补码"></a>概念二：补码</h2><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/362265365">什么是补码？这是地球上最通俗易懂的补码阐述</a></p><p>补码的思想：一个钟表，当前指向19点，问5个小时前是几点？</p><p>看起来很容易，做一个减法，肯定是14点。</p><p>但是，如果我们现在不会减法，该怎么办？</p><p>5个小时前，在表盘上指针指向的位置，和19小时之后表盘上指针指向的位置相同。</p><p>下图是一个与钟表相近的例子</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/bit_circle.png" alt="补码"></p><p>推广理解一下，在计算机中，对于有限的c个数位，一个数x减去一个值a与加上一个值b的结果相同。</p><p>此时a + b应该满足互补关系，即a + b的进位超出了c个数位表示的范围，进位被忽略，此时a + b的值刚好为0。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
            <tag> 中间层 </tag>
            
            <tag> 计算机系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序实现方法</title>
      <link href="/2021/09/29/Programming%20Language/%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
      <url>/2021/09/29/Programming%20Language/%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一，如何实现多组数据的输入输出"><a href="#一，如何实现多组数据的输入输出" class="headerlink" title="一，如何实现多组数据的输入输出"></a>一，如何实现多组数据的输入输出</h2><p>Python中使用异常来完成多组数据的输入输出</p><p>举例：计算a + b的多组输入</p><pre><code class="lang-python">    def calc(a, b) :        return a + b    if __name__ == &quot;__main__&quot;:        while (True) :            try :                a = eval(input())                b = eval(input())                print(calc(a, b))            except EOFError:                break</code></pre><h2 id="二，C语言二维数组如何作为函数的参数"><a href="#二，C语言二维数组如何作为函数的参数" class="headerlink" title="二，C语言二维数组如何作为函数的参数"></a>二，C语言二维数组如何作为函数的参数</h2><p>C语言函数调用二维数组时，为了能找到每一行函数的头指针，要填入列数，多维数组原理与之类似</p><pre><code class="lang-cpp">int toposort(int G[][MAXN], int n, int *in, int *out) &#123;    std::queue &lt;int&gt; q;    for (int p = 1; p &lt;= n &amp;&amp; in[p]; q.push(p), ++p);    ...&#125;</code></pre><h2 id="三，Python文件操作"><a href="#三，Python文件操作" class="headerlink" title="三，Python文件操作"></a>三，Python文件操作</h2><pre><code class="lang-python"># 1.打开文件file = open(&quot;read.txt&quot;)# 2. 读取文件内容text = file.read()print(text)# 3.关闭文件file.close()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> 技巧 </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.gitignore的使用</title>
      <link href="/2021/09/29/Git/Gitignore/"/>
      <url>/2021/09/29/Git/Gitignore/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要-gitignore文件"><a href="#为什么需要-gitignore文件" class="headerlink" title="为什么需要.gitignore文件"></a>为什么需要.gitignore文件</h2><pre><code class="lang-bash">git add .git commit -m &quot;0.1&quot;</code></pre><p>上面这两段语句十分简洁，大大方便了代码的提交。</p><p>但有时，一些不必要的文件也会被提交上去。比如可执行文件，或者用户本地配置文件等。人类是懒惰的，我绝不会手动对逐个文件进行添加或删除。这该怎么办？</p><p>这时，我们就需要.gitignore，它会让git我们忽略不必要的文件。</p><h2 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h2><p>举例</p><p>.gitignore支持通配符，支持忽略目录</p><pre><code class="lang-gitignore">*.class# Mobile Tools for Java (J2ME).mtj.tmp/# Package Files #*.jar*.war*.ear# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xmlhs_err_pid*!/foo/foo/*!/foo/bar</code></pre><h2 id="详细的使用文档-英文"><a href="#详细的使用文档-英文" class="headerlink" title="详细的使用文档(英文)"></a>详细的使用文档(英文)</h2><p><a href="https://git-scm.com/docs/gitignore">Git - gitignore Documentation (git-scm.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educoder 操作系统实训3.x实验</title>
      <link href="/2021/09/17/Operation%20System/Educoder%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%AE%AD3.x/"/>
      <url>/2021/09/17/Operation%20System/Educoder%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%AE%AD3.x/</url>
      
        <content type="html"><![CDATA[<h1 id="3-1：进程描述"><a href="#3-1：进程描述" class="headerlink" title="3.1：进程描述"></a>3.1：进程描述</h1><h2 id="实训地址"><a href="#实训地址" class="headerlink" title="实训地址"></a>实训地址</h2><p><a href="https://www.educoder.net/paths/2104">操作系统 (educoder.net)</a></p><h2 id="第一关：任务寄存器（TR）的分析"><a href="#第一关：任务寄存器（TR）的分析" class="headerlink" title="第一关：任务寄存器（TR）的分析"></a>第一关：任务寄存器（TR）的分析</h2><h3 id="实验方法"><a href="#实验方法" class="headerlink" title="实验方法"></a>实验方法</h3><pre><code class="lang-sh"># 跟踪到1号进行运行时，例如函数task1的入口处b task1c# 此时current指向1号进程的进程控制块，可以查看该进程控制块的内容p *currentp &amp;current-&gt;tss</code></pre><p>进程控制块的类型为 struct task_struct ，定义如下：</p><p><img src="https://data.educoder.net/api/attachments/1161827" alt="进程控制块"></p><pre><code class="lang-sh"># 其中最后一个成员tss即为进程的任务状态段，可以直接查看其地址:p current-&gt;tss-&gt;esp0# tss的值为0xfff2e8,esp0记录的核心栈栈底位置为16777216</code></pre><p>任务状态段的类型定义如下：</p><p><img src="https://data.educoder.net/api/attachments/1161830" alt="任务状态段"></p><p>其中成员 esp0 记录的即为进程的核心栈栈底位置。</p><pre><code class="lang-sh"># 退出gdb，使用bochsdbg调试quit</code></pre><pre><code class="lang-sh"># 终端1./rundbg# 跟踪到函数 task1 的入口b 0x7985c# 使用命令 sreg 查看所有的段寄存器：sreg# TR寄存器的值为 0x0030# 终端一操作暂时结束# 查看 TR 寄存器指向的任务状态段描述符的值# 计算描述符在GDT中的索引，另开一个命令行，用python算0x30&gt;&gt;3# 索引值为6# 查看GDT地址，存放在gdtr中sreg# 找到GDT的地址为0x5cc0# 查看GDT中的描述符x/14wx 0x5cc0# 1号进程的地址0x00008bfff2e80068# 起始地址0x00fff2e8</code></pre><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="如何查看-TR-寄存器指向的任务状态段描述符的值"><a href="#如何查看-TR-寄存器指向的任务状态段描述符的值" class="headerlink" title="如何查看 TR 寄存器指向的任务状态段描述符的值"></a>如何查看 TR 寄存器指向的任务状态段描述符的值</h4><ul><li><p>a.计算描述符在 GDT 中的索引。 TR寄存器（共16位）的高13位是所指向的任务状态段在全局描述符表（GDT）中的索引，因此将TR寄存器右移3位即可得到此索引，可以单独打开一个终端来运行 gdb ，就可以在其中进行计算。</p></li><li><p>b.查看 GDT 中该索引下的段描述符</p><p>首先查看 GDT 的地址，该地址记录在寄存器 gdtr 中，可见GDT地址为0x00005cc0</p><p>现在可以查看 GDT 中的描述符了，例如 0~4 号描述符的内容如下：</p><p><img src="https://data.educoder.net/api/attachments/1161866" alt="GDT中的描述符"></p><p>其中 4 号描述符的值为 0x00008901ed080068 。</p></li></ul><h4 id="如何从段描述符的值计算出段的起始地址"><a href="#如何从段描述符的值计算出段的起始地址" class="headerlink" title="如何从段描述符的值计算出段的起始地址"></a>如何从段描述符的值计算出段的起始地址</h4><p>一个段描述符占 64 位，其中段的起始地址由 3 部分拼接而成，如下图中的红色部分所示：</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/shixun/1161871.jpg" alt=""></p><p>可见前面的 4 号描述符 0x00008901ed080068 里记录的段起始地址是 0x0001ed08 。</p><h3 id="本关答案"><a href="#本关答案" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">1.1 号进程的任务状态段 TSS 的地址是多少？(0xfff2e8)2.1 号进程的核心栈栈底的位置是多少？(16777216)3.1 号进程运行时，任务寄存器 TR 的值是多少？(0x0030)4.它指向的任务状态段描述符的值是多少？(0x00008bfff2e80068)5.该描述符里记录的任务状态段起始地址是多少？(0x00fff2e8)</code></pre><h2 id="第二关：1-号进程的状态变化"><a href="#第二关：1-号进程的状态变化" class="headerlink" title="第二关：1 号进程的状态变化"></a>第二关：1 号进程的状态变化</h2><h3 id="实验方法-1"><a href="#实验方法-1" class="headerlink" title="实验方法"></a>实验方法</h3><pre><code class="lang-sh">#终端1cp /data/workspace/myshixun/exp1/1.tgz ~/os/cd ~/os/linux-0.11-labtar -zxvf ../1.tgzrm -rf curln -s 1 curcd cur/linuxmakecd ../.../rungdb# 终端1结束# 终端2b sys_pause if current-&gt;pid == 1b sched.c:120 if p-&gt;pid==1ccbt# 此时看到调用栈，控制流信息，栈底层函数为timer_interrupt，注意bt命令0~0x5000的误报# 以下操作和2.2关完全一样info reg# 观察到此时$cx不为0，说明loop指令不是刚开始执行，loop的上一条指令还是loopdisable 2disable 3finishsisisisisidisasb *0x77ddcdisassidisas</code></pre><h3 id="补充：x86-loop指令"><a href="#补充：x86-loop指令" class="headerlink" title="补充：x86 loop指令"></a>补充：x86 loop指令</h3><blockquote><p><strong>Loop指令</strong>执行流程:<br>步骤1. 将cx寄存器的值 - 1, cx = cx - 1;<br>步骤2. 判断cx的值 ;</p></blockquote><h3 id="本关答案-1"><a href="#本关答案-1" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">1.系统处于几号进程的上下文（或者说，当前进程是几号进程）？(0)2.内核的函数调用栈中的顶层函数是什么？(timer_interrupt)3.内核处于哪种控制流？(B)A.(系统调用)B.(中断)C.(异常)4.后续回到用户态时，恢复点的位置是什么？(0x796c)5.以前的断点位置是什么？(0x796c)</code></pre><h2 id="第三关：1-号进程的核心栈内容分析"><a href="#第三关：1-号进程的核心栈内容分析" class="headerlink" title="第三关：1 号进程的核心栈内容分析"></a>第三关：1 号进程的核心栈内容分析</h2><h3 id="实验方法-2"><a href="#实验方法-2" class="headerlink" title="实验方法"></a>实验方法</h3><pre><code class="lang-sh">b task1cp current-&gt;tss-&gt;esp0# 核心栈栈底16777216(Dec)，题目中必须要填0x1000000(Hex)sisiinfo regbt# 核心栈栈顶0x00007948x/5wx $esp</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>本关第一题不填hex值不给过，真的不想说什么了。。。</p><p>打印16进制数的命令<code>p/x &lt;var&gt;</code></p><h3 id="本关答案-2"><a href="#本关答案-2" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">1.1号进程的核心栈栈底的位置是多少？(0x1000000)2.1号进程执行函数 task1 中的第一个 int 0x81 指令后，核心栈栈顶的位置是多少？(0xffffec)3.从栈底到栈顶依次放了哪些内容？(0x00000017)(0x0002573c)(0x00000246)(0x0000000f)(0x00007989)</code></pre><h2 id="第四关：0-号进程的核心栈内容分析"><a href="#第四关：0-号进程的核心栈内容分析" class="headerlink" title="第四关：0 号进程的核心栈内容分析"></a>第四关：0 号进程的核心栈内容分析</h2><h3 id="实验方法-3"><a href="#实验方法-3" class="headerlink" title="实验方法"></a>实验方法</h3><pre><code class="lang-sh">b main.c:145cp/x current-&gt;tss-&gt;esp0nsisix/5wx $esp</code></pre><h3 id="本关答案-3"><a href="#本关答案-3" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">1.0号进程的核心栈栈底的位置是多少？(0x1fa20)2.0号进程执行 fork 系统调用中的陷入指令后，核心栈栈顶的位置是多少？(0x1fa0c)3.从栈底到栈顶依次放了哪些内容？(0x00000017)(0x00025740)(0x00000202)(0x0000000f)(0x0000690a)</code></pre><h1 id="3-2：进程的创建"><a href="#3-2：进程的创建" class="headerlink" title="3.2：进程的创建"></a>3.2：进程的创建</h1><h2 id="第一关：进程创建前后TR寄存器值的分析"><a href="#第一关：进程创建前后TR寄存器值的分析" class="headerlink" title="第一关：进程创建前后TR寄存器值的分析"></a>第一关：进程创建前后TR寄存器值的分析</h2><h3 id="实验方法-4"><a href="#实验方法-4" class="headerlink" title="实验方法"></a>实验方法</h3><pre><code class="lang-sh"># 终端一cp /data/workspace/myshixun/exp1/1.tgz ~/os/cd ~/os/linux-0.11-labtar -zxvf ../1.tgzrm -rf curln -s 1 curcd cur/linuxmakecd ../.../rungdb# 终端一结束</code></pre><pre><code class="lang-sh"># 终端二cd ~/os/linux-0.11-lab/./mygdbb main.c:145c# 使用n指令，跳过将要执行的move_to_user_mode();函数nsidisas# 观察到陷入指令位置 0x6908# 使用n直接跳到fork的下一条指令n# 执行完陷入指令位置 0x6927# 终端二结束</code></pre><pre><code class="lang-sh"># 在终端二退出gdb，打开dbgb 0x6908csregb 0x6927csreg# 终端二结束</code></pre><h3 id="本关答案-4"><a href="#本关答案-4" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">1.0号进程的fork系统调用中的陷入指令的地址是多少？(0x6908)2.0号进程执行fork系统调用之前，TR寄存器的值为多少？(0x20)3.0号进程刚执行完fork系统调用时，TR寄存器的值为多少？(0x20)</code></pre><h2 id="第二关：1-号进程创建前后的GDT和PCB分析"><a href="#第二关：1-号进程创建前后的GDT和PCB分析" class="headerlink" title="第二关：1 号进程创建前后的GDT和PCB分析"></a>第二关：1 号进程创建前后的GDT和PCB分析</h2><h3 id="实验方法-5"><a href="#实验方法-5" class="headerlink" title="实验方法"></a>实验方法</h3><pre><code class="lang-sh"># 终端一的操作与上一关相同</code></pre><pre><code class="lang-sh"># 终端二cd ~/os/linux-0.11-lab/./mygdb# 查看0号进程的进程控制块起始地址，注意task[0]本来就是一个地址p task[0]# 查看0号进程的进程控制块tss地址p &amp;task[0]-&gt;tss# 查看1号进程创建前task的前两项p task[1]# 在fork处设置断点，执行b main.c:145cnsifinishsi# 记住0x6927是执行完进程一的恢复点# tss-&gt;eip现在存放进程第一条语句的地址，要输出16进制，不然过不了评测p/x task[1]-&gt;tss-&gt;eip# 解决第五题p task[0]p task[1]p &amp;task[1]-&gt;tss# 解决第八题p/x task[1]-&gt;tss-&gt;eip# 解决第九题p task[1]p/x task[1]-&gt;tss-&gt;esp0quit</code></pre><pre><code class="lang-sh"># 终端二./rundbgb 0x6908#断点打在0x6927后的近处b 0x6929csreg# 接下来应该输入 x/?wx &lt;gdtr的值&gt; 来查看GDT表# 0x20&gt;&gt;3 = 4，说明tr指向4号描述符# 起始段地址按照3.1第一关来计算x/16wx 0x5cc0csregx/16wx 0x5cc0</code></pre><h3 id="本关答案-5"><a href="#本关答案-5" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">1.0号进程的进程控制块的起始地址是多少？0号进程的TSS的地址是多少？(0x1ea20)(0x1ed08)2.在1号进程创建前，task数组的前2项是多少？(0x1ea20)(0x0)3.GDT的4~7号描述符是多少？(0x00008b01ed080068)(0x00008201ecf00068)(0x0000000000000000)(0x0000000000000000)4.其中存储的段起始地址分别是多少？(0x0001ed08)(0x0001ecf0)(0x00000000)(0x00000000)5.在1号进程创建后，task数组的前2项是多少？(0x1ea20)(0xfff000)6.GDT的4~7号描述符是（64位）多少？(0x00008b01ed080068)(0x00008201ecf00068)(0x000089fff2e80068)(0x000082fff2d00068)7.其中存储的段起始地址分别是多少？(0x0001ed08)(0x0001ecf0)(0x00fff2e8)(0x00fff2d0)8.1号进程的进程控制块的起始地址是多少？1号进程的TSS的地址是多少？1号进程执行的第一条语句的地址是多少？(0xfff000)(0xfff2e8)(0x690a)9.1号进程的核心栈栈底的位置是多少？该位置距离1号进程的进程控制块的起始位置有多远（字节数）？(0x1000000)(4096)</code></pre><h3 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h3><h4 id="GDB可以查看gdtr吗"><a href="#GDB可以查看gdtr吗" class="headerlink" title="GDB可以查看gdtr吗"></a>GDB可以查看gdtr吗</h4><p>这篇回答很有用：<a href="https://stackoverflow.com/questions/28263624/can-i-print-the-gdtr-and-gdt-descriptor-under-gdb">assembly - Can I print the gdtr and gdt descriptor under gdb? - Stack Overflow</a></p><h4 id="TR-寄存器的作用"><a href="#TR-寄存器的作用" class="headerlink" title="TR 寄存器的作用"></a>TR 寄存器的作用</h4><p>CPU 通过 TR 寄存器可以找到当前进程的任务状态段，任务状态段里记录了（以前保存的）进程 CPU 现场和核心栈位置等信息,整体结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/shixun/1162832.jpg" alt=""></p><p>可见，TR 寄存器通过 GDT 中的描述符间接指向了当前进程的任务状态段。GDT 的位置是根据 GDTR 寄存器的值来确定的。</p><h2 id="第三关：系统调用fork和execve的跟踪分析"><a href="#第三关：系统调用fork和execve的跟踪分析" class="headerlink" title="第三关：系统调用fork和execve的跟踪分析"></a>第三关：系统调用fork和execve的跟踪分析</h2><h3 id="实验方法-6"><a href="#实验方法-6" class="headerlink" title="实验方法"></a>实验方法</h3><p>在exec.c的do_execve中添加</p><pre><code class="lang-c">char ans[1001];for (int i = 0; i &lt; 1001; ++i) ans[i] = 0;for (int i = 0; ; ++i) &#123;    char c = get_fs_byte(filename + i);    if (!c) break;    else &#123;        ans[i] = c;    &#125;&#125;printk(&quot;Exec %s(%d)\n&quot;, ans, current-&gt;pid);</code></pre><p>在fork.c的copy_process靠近return的地方添加</p><pre><code class="lang-c">printk(&quot;Fork %d-&gt;%d\n&quot;, current-&gt;pid, p-&gt;pid);</code></pre><p>make编译即可</p><p>发现系统启动时，执行了/bin/sh 和 /etc/update 文件</p><h3 id="补充-2"><a href="#补充-2" class="headerlink" title="补充"></a>补充</h3><p><a href="https://www.runoob.com/cprogramming/c-strings.html">C语言字符串</a></p><h2 id="第四关：构建一个最小的可用操作系统"><a href="#第四关：构建一个最小的可用操作系统" class="headerlink" title="第四关：构建一个最小的可用操作系统"></a>第四关：构建一个最小的可用操作系统</h2><ol><li><p>进入虚拟机，修改/etc/rc文件</p><p>删去原有内容，在rc添加两行(在终端操作)</p><pre><code class="lang-sh">echo &quot;set&quot; &gt; rcecho &quot;ls -l /&quot; &gt;&gt; rc</code></pre></li><li><p>删除hello.c，a.out，把虚拟机中所有文件用mv命令移到根目录，然后删除原目录，记住要最后移动/usr/bin/里的的文件(否则就会<del>~重置实训</del>~)，usr中不是bin的文件和目录统统删除。</p></li><li><p>然后修改全局变量，先修改</p><pre><code class="lang-c">static char * argv_rc[] = &#123; &quot;/sh&quot;, NULL &#125;;static char * envp_rc[] = &#123; &quot;HOME=/&quot;, &quot;PATH=.&quot;, NULL &#125;;static char * argv[] = &#123; &quot;-/sh&quot;,NULL &#125;;static char * envp[] = &#123; &quot;HOME=/&quot;, &quot;PATH=.&quot;, NULL &#125;;</code></pre></li><li><p>然后修改启动需要的文件</p><pre><code class="lang-c">int pid,i;    setup((void *) &amp;drive_info);    (void) open(&quot;/tty0&quot;,O_RDWR,0);    (void) dup(0);    (void) dup(0);    printf(&quot;%d buffers = %d bytes buffer space\n\r&quot;,NR_BUFFERS,        NR_BUFFERS*BLOCK_SIZE);    printf(&quot;Free mem: %d bytes\n\r&quot;,memory_end-main_memory_start);    if (!(pid=fork())) &#123;        close(0);        if (open(&quot;/rc&quot;,O_RDONLY,0))            _exit(1);        execve(&quot;/sh&quot;,argv_rc,envp_rc);        _exit(2);    &#125;    if (pid&gt;0)        while (pid != wait(&amp;i))            /* nothing */;    while (1) &#123;        if ((pid=fork())&lt;0) &#123;            printf(&quot;Fork failed in init\r\n&quot;);            continue;        &#125;        if (!pid) &#123;            close(0);close(1);close(2);            setsid();            (void) open(&quot;/tty0&quot;,O_RDWR,0);            (void) dup(0);            (void) dup(0);            _exit(execve(&quot;/sh&quot;,argv,envp));        &#125;</code></pre><p>别忘了<font size = 6 color = "red">编译！编译！编译！</font></p></li><li><p>删除多余文件和文件夹，只留下tty0, sh, rc, ls, cat, rm, sync七个文件。</p><p>当然有删除好的硬盘文件，在<a href="http://redleaves.ys168.com/">这里</a><img src="https://tb2.bdstatic.com/tb/editor/images/face/i_f25.png?t=20140803" alt=""></p></li><li><p>点击评测</p></li></ol><h1 id="3-3-进程的调度"><a href="#3-3-进程的调度" class="headerlink" title="3.3 进程的调度"></a>3.3 进程的调度</h1><h2 id="第一关：第一次由时钟中断引发的进程调度"><a href="#第一关：第一次由时钟中断引发的进程调度" class="headerlink" title="第一关：第一次由时钟中断引发的进程调度"></a>第一关：第一次由时钟中断引发的进程调度</h2><h3 id="实验方法-7"><a href="#实验方法-7" class="headerlink" title="实验方法"></a>实验方法</h3><pre><code class="lang-sh"># 终端一与3.2第一关相同</code></pre><pre><code class="lang-sh"># 终端二./mygdbb sched.c:336cdisasp *task[1]p task[1]-&gt;statep current-&gt;counterp jiffiesquit</code></pre><h3 id="本关答案-6"><a href="#本关答案-6" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">1.当时bochs虚拟机输出的0/1字符串是什么？（忽略空格）(010000000000)2.该次中断是第几次时钟中断？(16)当时处于几号进程的上下文？(0)该进程的剩余时间片是多少？(0)3.1号进程当时处于什么状态？(1)1号进程控制块的alarm成员的值是多少？(103)该定时器截止时间到了吗？（填到了或没到）(没到)</code></pre><h2 id="第二关：前三次进程调度"><a href="#第二关：前三次进程调度" class="headerlink" title="第二关：前三次进程调度"></a>第二关：前三次进程调度</h2><h3 id="实验方法-8"><a href="#实验方法-8" class="headerlink" title="实验方法"></a>实验方法</h3><pre><code class="lang-sh">./mygdbb schedulecp current-&gt;pid## 以下代码重复三遍btp task[0]-&gt;statep task[1]-&gt;stateb sched.c:142cp nextc## 重复段结束</code></pre><h3 id="本关答案-7"><a href="#本关答案-7" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">1.第一次进程调度时，当前进程是几号进程？(0)内核函数调用栈的栈底函数是什么？(system_call)其上一层函数是什么？(sys_pause)0号进程处于什么状态？(1)1号进程处于什么状态？(0)选中了几号进程？(1)2.第二次进程调度时，当前进程是几号进程？(1)内核函数调用栈的栈底函数是什么？(system_call)其上一层函数是什么？(sys_pause)0号进程处于什么状态？(1)1号进程处于什么状态？(1)选中了几号进程？(0)3.第三次进程调度时，当前进程是几号进程？(0)内核函数调用栈的栈底函数是什么？(system_call)其上一层函数是什么？(schedule)0号进程处于什么状态？(1)1号进程处于什么状态？(1)选中了几号进程？(0)</code></pre><h2 id="第三关-版本1-2内核的进程调度过程分析"><a href="#第三关-版本1-2内核的进程调度过程分析" class="headerlink" title="第三关 版本1.2内核的进程调度过程分析"></a>第三关 版本1.2内核的进程调度过程分析</h2><h2 id="第四关-两个进程的严格交替输出"><a href="#第四关-两个进程的严格交替输出" class="headerlink" title="第四关 两个进程的严格交替输出"></a>第四关 两个进程的严格交替输出</h2><h1 id="3-4-进程的切换"><a href="#3-4-进程的切换" class="headerlink" title="3.4 进程的切换"></a>3.4 进程的切换</h1><h2 id="第一关：第一次进程切换过程分析"><a href="#第一关：第一次进程切换过程分析" class="headerlink" title="第一关：第一次进程切换过程分析"></a>第一关：第一次进程切换过程分析</h2><h3 id="实验方法-9"><a href="#实验方法-9" class="headerlink" title="实验方法"></a>实验方法</h3><pre><code class="lang-sh"># 在gdb中b sched.c:142c# 后面四句解决前两问p current-&gt;pidp nextp task[0]-&gt;counterp task[1]-&gt;countersib *0x6f33c# 后面十句解决第三问，查看各个字段disasinfo regp/x task[0]-&gt;tss-&gt;csp/x task[0]-&gt;tss-&gt;ssp/x task[0]-&gt;tss-&gt;eipp/x task[0]-&gt;tss-&gt;espp/x task[1]-&gt;tss-&gt;csp/x task[1]-&gt;tss-&gt;ssp/x task[1]-&gt;tss-&gt;eipp/x task[1]-&gt;tss-&gt;espni# 后面十句解决第四问，查看各个字段disasinfo regp/x task[0]-&gt;tss-&gt;csp/x task[0]-&gt;tss-&gt;ssp/x task[0]-&gt;tss-&gt;eipp/x task[0]-&gt;tss-&gt;espp/x task[1]-&gt;tss-&gt;csp/x task[1]-&gt;tss-&gt;ssp/x task[1]-&gt;tss-&gt;eipp/x task[1]-&gt;tss-&gt;esp</code></pre><h3 id="本关答案-8"><a href="#本关答案-8" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">第一次进程切换时：1.是从几号进程切换到几号进程？(0)(1)2.0号进程和1号进程的剩余时间片分别是多少？(13)(15)3.在（ljmp）切换前，寄存器对 CS:EIP 和 SS:ESP 的值是多少？(0x8:0x6f33)(0x10:0x1f9cc)其下一条指令的地址是多少？(0x6f37)0 号进程的 TSS 中的字段对 cs:eip 和 ss:esp 的值是多少？(0x17:0x0)(0x17:0x0)1 号进程的 TSS 中的字段对 cs:eip 和 ss:esp 的值是多少？(0xf:0x690a)(0x17:0x25740)4.在（ljmp）切换后，寄存器对 CS:EIP 和 SS:ESP 的值是多少？(0xf:0x690a)(0x17:0x25740)0 号进程的 TSS 中的字段对 cs:eip 和 ss:esp 的值是多少？(0x8:0x6f37)(0x10:0x1f9cc)1 号进程的 TSS 中的字段对 cs:eip 和 ss:esp 的值是多少？(0xf:0x690a)(0x17:0x25740)</code></pre><h2 id="第二关：第一进程切换时TR寄存器的变化分析"><a href="#第二关：第一进程切换时TR寄存器的变化分析" class="headerlink" title="第二关：第一进程切换时TR寄存器的变化分析"></a>第二关：第一进程切换时TR寄存器的变化分析</h2><h3 id="实验方法-10"><a href="#实验方法-10" class="headerlink" title="实验方法"></a>实验方法</h3><p>先打开dbg，然后打开gdb。gdb挂着就行，用不上。<br>遇到panic就点continue</p><pre><code class="lang-sh"># 在dbg中b 0x6f33c# 按3.1的方法，查出段起始地址，由上一关，知道是0号进程的tsssreg# x/10wx 0x5cc0注意不要用这个，不然切换后起始地址会错误，一个烦人的bugx/14wx 0x5cc0# 按3.1的方法，查出段起始地址，由上一关，知道是1号进程的tssssregx/14wx 0x5cc0</code></pre><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p><font size = 6 color = "red">第一次进程切换前</font>，要用<font size = 6 color = "blue">x/14wx 0x5cc0</font>查看，虽然使用<font size = 6 color = "gray">x/10wx 0x5cc0</font>也可以。</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/shixun/image-20210917103836830.png" alt="感谢这位兄弟"></p><h3 id="本关答案-9"><a href="#本关答案-9" class="headerlink" title="本关答案"></a>本关答案</h3><pre><code class="lang-sh">1.第一次进程切换前，CPU 中 TR 寄存器的值是多少？(0x0020)它所指向的 GDT 描述符中的段起始地址是多少？(0x0001ed08)是几号进程的 TSS 地址？(0)2.第一次进程切换后，CPU 中 TR 寄存器的值是多少？(0x0030)它所指向的 GDT 描述符中的段起始地址是多少？(0x00fff2e8)是几号进程的 TSS 地址？(1)</code></pre><h2 id="后面几关：不是自己做的，略过"><a href="#后面几关：不是自己做的，略过" class="headerlink" title="后面几关：不是自己做的，略过"></a>后面几关：不是自己做的<img src="https://img.moegirl.org.cn/common/thumb/9/9c/滑稽表情.png/30px-滑稽表情.png" alt="">，略过</h2>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 实训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Educoder </tag>
            
            <tag> 模拟实训 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在本地部署LearnGitBranch</title>
      <link href="/2021/09/14/Git/%E5%9C%A8%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2LearnGitBranch/"/>
      <url>/2021/09/14/Git/%E5%9C%A8%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2LearnGitBranch/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是LearnGitBranch"><a href="#什么是LearnGitBranch" class="headerlink" title="什么是LearnGitBranch"></a>什么是LearnGitBranch</h2><p>LearnGitBranch是一款基于javascript开发的Git学习平台，平台以生动的图形化界面和闯关的方式，帮助我们学习Git的使用。大大降低了Git学习的门槛。</p><h2 id="为什么在本地部署？"><a href="#为什么在本地部署？" class="headerlink" title="为什么在本地部署？"></a>为什么在本地部署？</h2><p>网络版本在这里，方便快捷。</p><p>网络版：</p><p><a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching中文</a></p><p><a href="https://learngitbranching.js.org/?locale=en_US">Learn Git Branching英文</a></p><p>众所周知，有计算机的地方，不一定就有网络，有时候，网络信号不好，1KB/s的网速，让人无法忍受。我们能不能在本地部署LearnGitBranch，随时随地方便的练习和复习呢？当然可以！</p><h2 id="如何在本地部署"><a href="#如何在本地部署" class="headerlink" title="如何在本地部署"></a>如何在本地部署</h2><p>在<a href="https://github.com/pcottle/learnGitBranching">这里</a>的README文件可以看到作者对于部署方法的建议，这里我只是把它实现了一遍，在<a href="https://redleaves699.github.io/2021/09/02/使用hexo和node.js搭建博客/">这篇博客</a>里，我配置了node.js环境，所以有些步骤可以省略。</p><pre><code class="lang-bash"># 以下命令均在git bash内执行，执行前，先进入源代码所在目录# 检查相关组件版本node --versionnpm --versionnpx --version# 安装gulp相关组件npm rm --global gulpnpm install --global gulp-cli# 查看gulp是否安装成功gulp --version# 安装yarnnpm i -g yarnyarn --version# 运行gulp，安装依赖组件并生成相关文件gulp# 最后，打开目录下的index.html即可</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网页前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Git </tag>
            
            <tag> LearnGitBranch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针的活用</title>
      <link href="/2021/09/12/Programming%20Language/%E6%8C%87%E9%92%88%E7%9A%84%E6%B4%BB%E7%94%A8/"/>
      <url>/2021/09/12/Programming%20Language/%E6%8C%87%E9%92%88%E7%9A%84%E6%B4%BB%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>传入一个单向链表，如何删除其中的某个节点？</p><p><a href="http://wordaligned.org/articles/two-star-programming">问题来源与英文解答</a></p><h2 id="常规思路"><a href="#常规思路" class="headerlink" title="常规思路"></a>常规思路</h2><p>我肯定会这么写：维护两个结点指针prev，curr，删除节点时，判断curr是否是链表头。删除节点时，需要将prev-&gt;next指向curr-&gt;next。</p><pre><code class="lang-c">typedef struct node&#123;    struct node * next;    ....&#125; node;typedef bool (* remove_fn)(node const * v);// Remove all nodes from the supplied list for which the // supplied remove function returns true.// Returns the new head of the list.node * remove_if(node * head, remove_fn rm)&#123;    for (node * prev = NULL, * curr = head; curr != NULL; )    &#123;        node * const next = curr-&gt;next;        if (rm(curr))        &#123;            if (prev)                prev-&gt;next = next;            else                head = next;            free(curr);        &#125;        else            prev = curr;        curr = next;    &#125;    return head;&#125;</code></pre><h2 id="二级指针巧妙实现"><a href="#二级指针巧妙实现" class="headerlink" title="二级指针巧妙实现"></a>二级指针巧妙实现</h2><p>但在Linus看来，这样的写法太繁琐。Linus使用二级指针对链表进行操作</p><pre><code class="lang-c">void remove_if(node ** head, remove_fn rm)&#123;    for (node** curr = head; *curr; )    &#123;        node * entry = *curr;        if (rm(entry))        &#123;            *curr = entry-&gt;next;            free(entry);        &#125;        else            curr = &amp;entry-&gt;next;    &#125;&#125;</code></pre><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>图解</p><p>图一是*curr指向头指针时，执行删除entry和不删除entry后的指针状态</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/point01.png" alt="图一"></p><p>图二是*curr指针指向链表中间指针时，执行删除entry和不删除entry后的指针状态，<strong>循环执行后</strong>都指一次循环执行后。</p><p><strong>注意</strong>：for循环中第一条赋值语句<code>node *entry = *curr;</code>执行后，entry就到了下一个节点。</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/point02.png" alt="图二"></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 指针 </tag>
            
            <tag> 高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android项目的阅读 - 让项目运行起来（总第一篇）</title>
      <link href="/2021/09/11/Android/Andorid%20%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/09/11/Android/Andorid%20%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="第一部分：安装Android-Studio"><a href="#第一部分：安装Android-Studio" class="headerlink" title="第一部分：安装Android Studio"></a>第一部分：安装Android Studio</h1><h2 id="第一步：首先先安装Android-Studio"><a href="#第一步：首先先安装Android-Studio" class="headerlink" title="第一步：首先先安装Android Studio"></a>第一步：首先先安装Android Studio</h2><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/Android/image-20210910040114976.png" alt="安装Android"></p><h2 id="第二步：安装JDK"><a href="#第二步：安装JDK" class="headerlink" title="第二步：安装JDK"></a>第二步：安装JDK</h2><p>如果已经安装了JDK，并配置环境变量，可以忽略这一步。</p><p>如果仍未安装，去网上下载<a href="http://openjdk.java.net/">OpenJDK</a>，或Oracle的JDK，然后配置环境变量即可。</p><p>如何配置java环境变量？</p><blockquote><p>1.在系统变量中建立JAVA_HOME变量</p><p>2.在系统变量的path变量中建立%JAVA_HOME%\bin</p></blockquote><h2 id="第三步：安装SDK"><a href="#第三步：安装SDK" class="headerlink" title="第三步：安装SDK"></a>第三步：安装SDK</h2><p>刚开始时，系统可能会出现这个画面</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/Android/image-20210910040538835.png" alt="安装SDK的问题"></p><p>这时点击Setup Proxy，选择Manual proxy configuration，再Host name中填入mirrors.ustc.edu.cn，继续。</p><p>Install Type选择Custom，之后填写JDK和SDK的目录。</p><p>之后会发生这样的问题，找不到SDK</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/Android/image-20210910041431443.png" alt="找不到SDK"></p><p>不必着急，这是因为SDK并没有成功安装。</p><p>先Finish，打开SDK Manager</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/Android/image-20210910041809732.png" alt="SDK Manager"></p><p>选择Auto-detect proxy settings，勾选Automatic proxy configuration URL，在其中填入socks5h://127.0.0.1:1080(本地)或mirrors.neusoft.edu.cn:80(镜像源)。</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/Android/image-20210910042256100.png" alt="代理设置"></p><p>之后选择System Setting中的Android SDK，点击edit，在弹出窗口填写SDK下载位置（最好选择自己新建的一个非系统盘的空文件夹，注意<strong>文件夹不能包含汉字和空格</strong>），点击next，如果你的网络比较好，这时会弹出如下内容：</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/Android/image-20210910042726427.png" alt="代理和SDK安装目录设置成功"></p><p>下一步，然后静等所有项目安装完毕。</p><p>接下来就可以打开工程了。</p><p>如果网络比较差，就会这样</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/Android/image-20210910092236896.png" alt="网络不好"></p><p>需要多试几次。</p><h1 id="第二部分：运行小米便签程序"><a href="#第二部分：运行小米便签程序" class="headerlink" title="第二部分：运行小米便签程序"></a>第二部分：运行小米便签程序</h1><h2 id="第一步：导入源代码"><a href="#第一步：导入源代码" class="headerlink" title="第一步：导入源代码"></a>第一步：导入源代码</h2><p>直接导入工程(File-&gt;new-&gt;import project)，然后为新工程取个名字<name>，然后AS就会帮你建立一个名字为<name>的工程文件。</p><h2 id="第二步：设置gradle和SDK"><a href="#第二步：设置gradle和SDK" class="headerlink" title="第二步：设置gradle和SDK"></a>第二步：设置gradle和SDK</h2><p>接着，进入工程结构设置(File-&gt;project structure)，进入project选项。设置gradle插件和gradle版本。</p><blockquote><p><strong>注意</strong>：小米便签是一个很古老的项目，现代的gradle（7.0以上）和SDK（31）与以前相比变化很大，当时能用很多的包因为过时被废弃，所以要用SDK23以下的版本。</p></blockquote><p>然后，进入Dependencies，设置依赖包存储位置（为未来导入包做准备），ok，设置完成。</p><p>然后可能会报如下错误</p><blockquote><p>Unknown host ‘不知道这样的主机。 (<a href="https://mirrors.neusoft.edu.cn/">https://mirrors.neusoft.edu.cn/</a>)’. You may need to adjust the proxy settings in Gradle.</p></blockquote><p>这时要关闭系统默认设置grandle的代理，方法是进入Gradle Scripts打开gradle.propertities，删除原来未注释内容，添加</p><pre><code class="lang-she">systemProp.http.proxyHost=systemProp.http.proxyPort=80systemProp.https.proxyHost=systemProp.https.proxyPort=80</code></pre><p>关闭代理，然后设置build.gradle</p><pre><code class="lang-sh">// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123;    repositories &#123;        google()        maven &#123; url &#39;https://maven.aliyun.com/repository/public&#39; &#125;    &#125;    dependencies &#123;        classpath &#39;com.android.tools.build:gradle:4.1.3&#39;    &#125;&#125;allprojects &#123;    repositories &#123;        google()        maven &#123; url &#39;https://maven.aliyun.com/repository/public&#39; &#125;    &#125;&#125;</code></pre><p>重启Android Studio。</p><p>更换sdk为22版本，(File-&gt;project structure-&gt;module)</p><p>运行代码，在模拟器上出现小米便签程序。</p><blockquote><p>运行时可能会出现问题，比如编译时间过长，没关系，重新编译即可，这是网络问题。</p><p>最后可能会报一个有关线程的错误，不过不用理会。只要看到IDE最下方的run那里显示Launched succeed，就表示程序编译成功，这时直接打开手机模拟器即可。</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/Android/image-20210911111506040.png" alt="Launch succeed"></p></blockquote><h2 id="第三步：运行结果"><a href="#第三步：运行结果" class="headerlink" title="第三步：运行结果"></a>第三步：运行结果</h2><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/Android/image-20210911111013765.png" alt="运行结果"></p><blockquote><p><strong>补充</strong>：如果设置SDK版本为23以上，则会出现SDK不认代码的情况</p><p>也会出现找不到setLatestEventInfo方法的情况</p><p><img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/Android/image-20210911101348762.png" alt="被删除的代码为灰色和红色，未删除的为正常颜色"></p></blockquote><h1 id="第三部分：未来的工作"><a href="#第三部分：未来的工作" class="headerlink" title="第三部分：未来的工作"></a>第三部分：未来的工作</h1><p>至此，我们完成了运行小米便签的目标，接下来，就可以阅读小米便签的相关代码，并进行以后的代码标注工作。</p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件开发 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educoder 操作系统实训2.x实验</title>
      <link href="/2021/09/09/Operation%20System/Educoder%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%AE%AD2.x/"/>
      <url>/2021/09/09/Operation%20System/Educoder%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%AE%AD2.x/</url>
      
        <content type="html"><![CDATA[<h1 id="实训2-1：外部中断"><a href="#实训2-1：外部中断" class="headerlink" title="实训2.1：外部中断"></a>实训2.1：外部中断</h1><h2 id="实训地址"><a href="#实训地址" class="headerlink" title="实训地址"></a>实训地址</h2><p><a href="https://www.educoder.net/paths/2104">操作系统 (educoder.net)</a></p><h2 id="第一关：时钟中断的发生"><a href="#第一关：时钟中断的发生" class="headerlink" title="第一关：时钟中断的发生"></a>第一关：时钟中断的发生</h2><p>方法详见左侧说明，这里直接放出答案</p><pre><code class="lang-sh">#终端1cp /data/workspace/myshixun/exp1/1.tgz ~/os/cd ~/os/linux-0.11-labtar -zxvf ../1.tgzrm -rf curln -s 1 curcd cur/linuxmakecd ../.../run./rungdb#操作暂时结束#开启终端2cd ~/os/linux-0.11-lab/./mygdbdisplay jiffiesb do_timerccc...#直到0/1填满第一行#操作结束</code></pre><h3 id="补充：-GDB设置断点的方式"><a href="#补充：-GDB设置断点的方式" class="headerlink" title="补充： GDB设置断点的方式"></a>补充： GDB设置断点的方式</h3><p>​    1.普通断点</p><p>当程序执行到<code>main.cpp</code>文件的第5行时触发断点</p><pre><code class="lang-sh">(gdb) b src/main.cpp:5</code></pre><ol><li>条件断点</li></ol><p>满足一定条件触发断点</p><pre><code class="lang-sh">(gdb) b src/main.cpp:5 if cnt==10</code></pre><p>​    3.数据断点</p><p>根据地址数据来进行设置断点，当该地址上的内容发生改变时就会触发断点。<br>设置数据断点有两种方式，</p><p>一种是直接指出地址值</p><pre><code class="lang-sh">(gdb) b *0x400522</code></pre><p>在断点处<code>print &amp;变量名</code> 就能获取该变量的地址。<br>另一种是直接设置变量名</p><pre><code class="lang-sh">(gdb) b &amp;变量名</code></pre><ol><li>函数断点</li></ol><p>当程序执行到某个函数模块时触发断点</p><pre><code class="lang-sh">(gdb) b funcName</code></pre><hr><h2 id="第二关-第一次时钟中断"><a href="#第二关-第一次时钟中断" class="headerlink" title="第二关 第一次时钟中断"></a>第二关 第一次时钟中断</h2><h3 id="补充：GDB命令"><a href="#补充：GDB命令" class="headerlink" title="补充：GDB命令"></a>补充：GDB命令</h3><ol><li><p><strong>c</strong><br>Continue的简写，继续执行被调试程序，直至下一个断点或程序结束。</p></li><li><p><strong>b</strong></p><p>设置断点，上面已经介绍</p></li><li><p><strong>bt</strong></p><p>backtrace的简写，列出调用栈</p></li><li><p><strong>s</strong></p><p>相当于IDE中的<strong>step into</strong>，单步运行源代码语句</p><p>这个命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）</p></li><li><p><strong>si</strong></p><p>和s指令类似，单步运行汇编指令</p></li><li><p><strong>n</strong></p><p>相当于IDE中的<strong>step over</strong>，单步运行源代码语句</p><p>其余同<strong>s</strong></p></li><li><p><strong>ni</strong></p><p>和n指令类似，单步运行汇编指令</p></li></ol><pre><code class="lang-sh">#终端1cd os/linux-0.11-lab/#终端2./rungdb#终端2操作结束./mygdbb do_timercbtfinishdisassisib *0x77ddcdisassidisas#发现恢复点地址为0x0000796c</code></pre><hr><h2 id="第三关-第六次时钟中断"><a href="#第三关-第六次时钟中断" class="headerlink" title="第三关 第六次时钟中断"></a>第三关 第六次时钟中断</h2><p>这一关要注意，<strong>对于外部中断而言，恢复点指令是断点指令的后一条。</strong></p><p><strong>loop 指令</strong>的功能是先将 ecx 寄存器减一，然后检查其值，如果其值非 0 ，则继续循环，否则中止循环，执行下一条指令。</p><p>loop指令的<strong>上一条指令</strong>是谁？</p><p>通过第二条info reg命令，可以观察<strong>ecx</strong>的值，为0x8440，非0，再回忆下第一条info reg，回忆<strong>ecx</strong>的值，仍为非0，得出结论，<strong>loop</strong>的上一条指令还是<strong>loop</strong>，断点指令位置仍为0x00007982</p><pre><code class="lang-sh">#延续第一关的配置#终端一./rungdb#终端一操作结束#终端二./mygdbdisplay jiffiesb do_timercccccinfo regcbtfinshsisidisasb *0x000077ddcdisassidisasinfo reg#终端二操作结束#可以看到虚拟机屏幕输出结果是0100#可以看到异常的恢复点为0x00007982</code></pre><hr><h2 id="第四关-修改版本-1-内核源码，使得每次时钟中断发生时，都在屏幕上输出字符‘t’。"><a href="#第四关-修改版本-1-内核源码，使得每次时钟中断发生时，都在屏幕上输出字符‘t’。" class="headerlink" title="第四关 修改版本 1 内核源码，使得每次时钟中断发生时，都在屏幕上输出字符‘t’。"></a>第四关 修改版本 1 内核源码，使得每次时钟中断发生时，都在屏幕上输出字符‘t’。</h2><p>不知为何，代码的位置不对就会出问题</p><pre><code class="lang-assembly">.align 4timer_interrupt:    push %ds        # save ds,es and put kernel data space    push %es        # into them. %fs is used by _system_call    push %fs    pushl %edx        # we save %eax,%ecx,%edx as gcc doesn&#39;t    pushl %ecx        # save those across function calls. %ebx    pushl %ebx        # is saved as we use that in ret_sys_call    pushl %eax    movl $0x10,%eax    mov %ax,%ds    mov %ax,%es    movl $0x17,%eax    mov %ax,%fs    incl jiffies    movb $116,%al       # 新加入的代码1    int $0x81           # 新加入的代码2    movb $0x20,%al        # EOI to interrupt controller #1    outb %al,$0x20      # 新加入的代码在这句后面就过不去    movl CS(%esp),%eax    andl $3,%eax        # %eax is CPL (0 or 3, 0=supervisor)    pushl %eax    call do_timer        # &#39;do_timer(long CPL)&#39; does everything from    addl $4,%esp        # task switching to accounting ...    jmp ret_from_sys_call</code></pre><hr><h2 id="第五关：修改版本-0-内核"><a href="#第五关：修改版本-0-内核" class="headerlink" title="第五关：修改版本 0 内核"></a>第五关：修改版本 0 内核</h2><p><strong>目标</strong> ：修改<strong>版本 0 内核</strong>，使得每发生 100 次时钟中断，就在屏幕上输出一个字符‘t’和当时的进程号，如“t(0)”表示0号进程运行时发生了时钟中断。</p><p>这里实训做的很烂。。。</p><p>这个实训的难度就在于猜猜要改哪里。我尝试了改主函数，不行。。。改init函数，不行。pid放在代码的哪里，我也不知道。后来我看了前几关调试时命令行有一个变量叫<strong>current-&gt;state</strong>，估计这个是程序当前的pid了，make + ./run一试，还成功了。在vscode的搜索中，我搜索了一下<strong>pause</strong>相关的内容，在某个位置，出现了<strong>sys_pause</strong>这个函数，ctrl + 左键点进去，发现这个好像就是系统中断。于是在原代码基础上尝试添加以下代码。</p><pre><code class="lang-c">int sys_pause(void)&#123;    current-&gt;state = TASK_INTERRUPTIBLE;    schedule();    //add following code    if (jiffies % 100 == 0) &#123;            printk(&quot;t(%d)\n&quot;, current-&gt;pid);    &#125;    //end    return 0;&#125;</code></pre><p>然后make + ./run再再再…试，内核成功运行了，至此第五关通过。</p><p><strong>注意的问题</strong>：cur在前四关中都是指向1的，这关要将其指向0。至于为什么，打开config/0.11.bxrc看看。不改bochs就会报找不到硬盘的错误。</p><pre><code class="lang-sh">rm -rf curln -s 0 cur</code></pre><h1 id="实训2-2：异常"><a href="#实训2-2：异常" class="headerlink" title="实训2.2：异常"></a>实训2.2：异常</h1><h2 id="第一关：除零异常分析"><a href="#第一关：除零异常分析" class="headerlink" title="第一关：除零异常分析"></a>第一关：除零异常分析</h2><pre><code class="lang-sh">#终端一cp /data/workspace/myshixun/exp1/1.1.tar /home/headless/os/linux-0.11-lab/cd ~/os/linux-0.11-lab/tar -xvf 1.1.tarllrm -rf curln -s 1.1 curcd cur/linuxmakecd ../.../rungdb#终端一操作结束#终端二cd ~/os/linux-0.11-lab/./mygdbb main.c:147cx/6i $eip #这句话是idiv指令地址正确的判定依据，虽然它用处不大disas  #观察到idiv指令出现在0x690eb *0x690ecinfo reg  #观察到idiv指令执行之前cs:eip为0xf:0x690e，ss:esp为0x17:0x25760sidisasinfo reg  #观察到新指令位置cs:eip为0x8:0x814b，ss:esp为0x10:0x1fa2csiinfo regdisasx/5wx $esp #详见代码后注释[1]，观察到用户栈顶0x17:0x25760，恢复点位置0xf:0x690e#终端二结束</code></pre><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><ol><li>下面面显示了栈顶的 5 个长字，是某异常发生时的中断现场，其中存储的用户栈顶的位置是 0x17:0x2573c ，存储的恢复点的位置是 0xf:0x7967 。需要注意的是，x86 中栈是从高地址向低地址方向增长的，这里的栈顶位置是 0x1fa0c 。</li></ol><p><img src="https://data.educoder.net/api/attachments/1154430" alt="实验说明"></p><ol><li>单独查看一个寄存器</li></ol><pre><code class="lang-sh">p/x $eax</code></pre><hr><h2 id="第二关-int指令分析"><a href="#第二关-int指令分析" class="headerlink" title="第二关 int指令分析"></a>第二关 int指令分析</h2><pre><code class="lang-sh"># 终端1cp /data/workspace/myshixun/exp2/1.tgz ~/os/cd ~/os/linux-0.11-labtar -zxvf ../1.tgzrm -rf curln -s 1 curcd cur/linuxmakecd ../.../rungdb# 操作暂时结束# 开启终端2cd ~/os/linux-0.11-lab/./mygdbb task1cx/5i $eipsix/5i $eipinfo reg # 可以观察到当前指令位置CS:EIP(0xf:0x7987)和栈位置SS:ESP(0x17:0x2573c)disassiinfo reg # 可以观察到当前指令位置CS:EIP(0x8:0x7948)和栈位置SS:ESP(0x10:0xffffec)disasx/5wx $esp # 观察到用户栈顶0x17:0x2573c，恢复点位置0xf:0x7989# 操作结束</code></pre><hr><h2 id="第三关：iret指令分析"><a href="#第三关：iret指令分析" class="headerlink" title="第三关：iret指令分析"></a>第三关：iret指令分析</h2><p>没什么强调的，和第二关基本一样</p><pre><code class="lang-sh"># 终端一操作同上省略# 终端二cd ~/os/linux-0.11-lab/./mygdbb task1cx/5i $eipsix/5i $eipsi #找到中断处理模块b *0x795einfo reg #处理程序的 iret 指令执行之前，指令位置CS:EIP(0x8:0x795e)和栈位置SS:ESP(0x10:0xffffec)x/5wx $esp #此时栈中保存的恢复点位置(0xf:0x7989)和用户栈位置(0x17:0x2573c)sidisasinfo reg #使用 si 命令执行了该 iret 指令后，新指令位置(0xf:0x7989)和栈位置(0x17:0x2573c)</code></pre><hr><h2 id="第四关：陷入指令分析"><a href="#第四关：陷入指令分析" class="headerlink" title="第四关：陷入指令分析"></a>第四关：陷入指令分析</h2><p>和第三关唯一一处不同，就是跳入陷入函数的时候.</p><pre><code class="lang-sh"># 终端一操作同上省略# 终端二cd ~/os/linux-0.11-lab/./mygdbb main.c:145c# 使用n指令，跳过将要执行的move_to_user_mode();函数n# 陷入forkx/5i $eipsiinfo reg #在 0 号进程执行 fork 系统调用中的陷入指令(int 0x80)之前，当前指令位置CS:EIP(0xf:0x6908)和栈位置SS:ESP(0x17:0x25740)siinfo reg #使用 si 命令执行了该指令后，新指令位置(0x8:0x7764)和栈位置(0x10:0x1fa0c)x/5wx $esp ##此时栈中保存的恢复点位置(0xf:0x690a)和用户栈位置(0x17:0x25740)</code></pre><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><blockquote><p>跟踪到系统调用的陷入指令（int 0x80）执行之前</p><p>一般而言，可以在该系统调用处设置断点，跟踪到该断点，然后使用 si 命令单步执行到陷入指令。但是，对于 main 函数里的 fork 系统调用，不能这样操作（因为 gdb 有时断点设置不够准），可以先跟踪到前一行的 move_to_user_mode 语句，然后使用 n 单步执行，即可到达 fork 系统调用的开始，此时再反汇编，找到陷入指令。</p></blockquote><h1 id="实训-2-3-：系统调用"><a href="#实训-2-3-：系统调用" class="headerlink" title="实训 2.3 ：系统调用"></a>实训 2.3 ：系统调用</h1><h2 id="第一关：版本1内核执行的前-3-个系统调用"><a href="#第一关：版本1内核执行的前-3-个系统调用" class="headerlink" title="第一关：版本1内核执行的前 3 个系统调用"></a>第一关：版本1内核执行的前 3 个系统调用</h2><p>第一，使用方法一，找出第一次调用<br>请不要使用他提供的方法一，评测不过，明明都找到正确答案了。怪不得网上的人都说这是垃圾平台，给本来时间就充裕的我们增加了消磨<del>浪费</del>时间的机会。</p><p>第二，在输答案的时候，sys_要去掉，垃圾平台。。。让我们猜谜？</p><p>答案：<code>1.系统运行时，执行的前3个系统调用的编号和名字是(2,fork)、(29,pause)、(48,signal)</code></p><pre><code class="lang-sh"># 终端一，操作与2.1实验一的终端一一样，省略# 终端二cd ~/os/linux-0.11-lab/./mygdbb system_callcdisasdisplay $eaxb *0x7780cdisassix/3i $eip # 发现eax的值是2，查找unistd.h，进程为__NR_fork（其实不是，用第二种方法，可以看出是sys_fork）disascdisascdisassix/3i $eip # eax的值为29，调用了sys_pause函数，是一次系统中断disas# 第三次调用cdisascdisassix/3i $eipdisasc# eax的值为48，调用了sys_signal函数</code></pre><h2 id="第二关：命令-ls-执行的系统调用"><a href="#第二关：命令-ls-执行的系统调用" class="headerlink" title="第二关：命令 ls 执行的系统调用"></a>第二关：命令 ls 执行的系统调用</h2><pre><code class="lang-sh"># 终端一cd ~/os/linux-0.11-labrm -rf curln -s 0 curcd cur/linuxmakecd ../.../rungdb# 终端一结束# 终端二cd ~/os/linux-0.11-lab./mygdbdisplay current-&gt;piddisable 1b do_execveccommands 2p current-&gt;start_code+filenameendccc# 此时等待虚拟机响应# 虚拟机操作ls# 虚拟机操作结束b system_callcdisasdisplay $eaxp current-&gt;pidb system_call if current-&gt;pid != 0commands 3p $eaxp sys_call_table[$eax]endc# 以下是若干个c，一直到current-&gt;id != 6为止，不要c太多次cc...# 终端二结束</code></pre><p>不停运行，观察current-&gt;pid即可，答案为：</p><pre><code class="lang-sh">可执行文件ls运行时（无参数），会依次执行下面这些系统调用：1.(time)(ioctl)(brk)(brk)(brk)2.(brk)(brk)(open)(fstat)(brk)3.(read)(read)(close)(ioctl)(write)4.(write)(close)(exit)()()</code></pre><p>ls在6号进程中执行，后面由 6 号进程引发的系统调用才是ls 执行的系统调用，所以只需要记录current-&gt;pid = 6时的所有系统函数调用！</p><h2 id="第三关：版本1内核执行的完整系统调用序列"><a href="#第三关：版本1内核执行的完整系统调用序列" class="headerlink" title="第三关：版本1内核执行的完整系统调用序列"></a>第三关：版本1内核执行的完整系统调用序列</h2><h3 id="补充：GDB断点的启用和禁用"><a href="#补充：GDB断点的启用和禁用" class="headerlink" title="补充：GDB断点的启用和禁用"></a>补充：GDB断点的启用和禁用</h3><ul><li><code>disable 1</code> ：禁用第一个断点；</li><li><code>enable 2</code> ：启用第二个断点；</li><li><code>enable once</code> 1 ：下次用了第一个断点，第一个断点就被禁用；</li></ul><pre><code class="lang-sh"># 2号断点为无条件的system_callb system_callcommands 2p $eaxp sys_call_table[$eax]enddisable 2# 3号断点为有条件的system_callb system_call if $eax!=29 || current-&gt;pid!=0commands 3p $eaxp sys_call_table[$eax]endc# 接下来要不停的开关断点，在出现0号进程pause调用时，把它们跳过去disable 2enable 3c# 如果本次显示的断点没有发生0号进程pause调用，不用跳过，执行一次system_calldisable 3enable 2c</code></pre><p>答案：</p><pre><code class="lang-sh">1.(0,fork)(0,pause)(1,signal)(1,alarm)(1,pause)2.(0,pause)(1,alarm)(1,pause)(0,pause)(1,alarm)3.(1,pause)(0,pause)(1,alarm)(,)(,)</code></pre><h2 id="第四关：在版本1中输出系统调用信息"><a href="#第四关：在版本1中输出系统调用信息" class="headerlink" title="第四关：在版本1中输出系统调用信息"></a>第四关：在版本1中输出系统调用信息</h2><p>修改system_call.asm中的system_call:函数</p><pre><code class="lang-assembly">system_call:    cmpl $nr_system_calls-1,%eax    ja bad_sys_call    push %ds    push %es    push %fs    pushl %edx    pushl %ecx        # push %ebx,%ecx,%edx as parameters    pushl %ebx        # to the system call    movl $0x10,%edx        # set up ds,es to kernel space    mov %dx,%ds    mov %dx,%es    movl $0x17,%edx        # fs points to local data space    mov %dx,%fs    pushl %eax #新加入的指令1    call myfunc #新加入的指令2    popl %eax #新加入的指令3    call sys_call_table(,%eax,4)    pushl %eax    movl current,%eax    cmpl $0,state(%eax)        # state    jne reschedule    cmpl $0,counter(%eax)        # counter    je reschedule</code></pre><p>修改fork.c，在其中添加</p><pre><code class="lang-c">int baghdnkdn = -1;//全局变量，随机取名，不要与已有的变量名重复void myfunc (int eax) &#123;    if (baghdnkdn == current -&gt; pid &amp;&amp; eax == 29 &amp;&amp; baghdnkdn == 0) return;    else &#123;        printk(&quot;%d(%d)&quot;, eax, current-&gt;pid);    &#125;    baghdnkdn = current -&gt; pid;&#125;</code></pre><h2 id="第五关：在版本0中输出系统调用信息"><a href="#第五关：在版本0中输出系统调用信息" class="headerlink" title="第五关：在版本0中输出系统调用信息"></a>第五关：在版本0中输出系统调用信息</h2><p>和第四关几乎相同</p><p>修改system_call.asm中的system_call:函数，与第四关完全一样</p><p>修改fork.c，在其中添加</p><pre><code class="lang-c">void myfunc(int eax) &#123;    if (current -&gt; pid &lt; 4) return;    else &#123;        printk(&quot;%d(%d)&quot;, eax, current-&gt;pid);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 实训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Educoder </tag>
            
            <tag> 模拟实训 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Debian系统配置Linux0.11</title>
      <link href="/2021/09/07/Operation%20System/Debian%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AELinux0.11/"/>
      <url>/2021/09/07/Operation%20System/Debian%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AELinux0.11/</url>
      
        <content type="html"><![CDATA[<h2 id="由于系统的更新迭代，这篇文章已经过时需要再次更新！"><a href="#由于系统的更新迭代，这篇文章已经过时需要再次更新！" class="headerlink" title="由于系统的更新迭代，这篇文章已经过时需要再次更新！"></a>由于系统的更新迭代，这篇文章已经过时需要再次更新！</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近要上操作系统课，课上需要我们配置Linux0.11实验环境，在这个过程中，我遇到了大量的问题，耗费了很多时间。必须写个博客来做总结。刚开始我用OpenEuler，配置了一天，结果还是有问题。于是使用Debian再次尝试配置。</p><h2 id="什么是Linux0-11-实验环境"><a href="#什么是Linux0-11-实验环境" class="headerlink" title="什么是Linux0.11 实验环境"></a>什么是Linux0.11 实验环境</h2><p>Linux0.11实验环境由三个部分组成，第一为VMware，hyper-v等安装在实体机上的虚拟机A，第二为虚拟机中的Linux系统，第三为虚拟机A中Linux操作系统中的bochs虚拟机B。</p><p>程序在客户机上，使用编程软件编好后，使用网络映射，存储到虚拟机A上。在虚拟机A上完成编译后，会生成BIOS文件，这时，使用虚拟机软件bochs，添加BIOS及虚拟硬盘，生成虚拟机B。这样就相当于在Linux环境下，完成了Linux内核的编写和执行。</p><p>为什么这么麻烦，因为bochs是纯软件虚拟，而VMware等虚拟机存在硬件虚拟，不好调试输出。</p><h2 id="Debian部署Linux0-11"><a href="#Debian部署Linux0-11" class="headerlink" title="Debian部署Linux0.11"></a>Debian部署Linux0.11</h2><h3 id="第一步：安装Debian操作系统"><a href="#第一步：安装Debian操作系统" class="headerlink" title="第一步：安装Debian操作系统"></a>第一步：安装Debian操作系统</h3><p><a href="https://www.debian.org/CD/http-ftp/">通过 HTTP/FTP 下载 Debian CD/DVD 映像</a></p><p>最好安装一个图形化界面，如果是只用来做实验的话推荐Xfce，占用资源少</p><p>这一步比较简单，因为Debian在安装上难度和ubuntu差不多。</p><h3 id="第二步：安装Samba服务器"><a href="#第二步：安装Samba服务器" class="headerlink" title="第二步：安装Samba服务器"></a>第二步：安装Samba服务器</h3><ol><li><p>确保虚拟机网络是NAT模式，至于为什么？原理在这里：<a href="https://www.cnblogs.com/aeolian/p/8882790.html">VMWare虚拟机网络配置</a></p></li><li><p>在虚拟机上使用<strong>ifconfig</strong>命令看看虚拟机的ip地址，但是。。。我们发现没有<strong>ifconfig</strong>这个命令，出错情况如下：</p><pre><code class="lang-bash">bash: ifconfig：未找到命令</code></pre><p>这是因为ifconfig命令要被Linux淘汰了，取而代之的是功能更强的<strong>ip</strong>命令。<a href="https://www.runoob.com/linux/linux-comm-ip.html">Linux ip 命令</a></p><p>ifconfig 现在可以用 ip addr 代替。其他的替代详见下表：</p></li></ol><p><img src="http://www.linuxidc.com/upload/2014_06/14060411029186.png" alt="ifconfig 和 ip命令简要对应"></p><ol><li>客户机和虚拟机之间需要建立网络映射，如果直接ping虚拟机的ip，会发现虚拟机可以ping通，但磁盘映射始终建立不了。这是因为系统的安全问题（想想如果你的文件能被局域网里的坏家伙访问，会是什么结果），我们需要一个媒介，这个媒介就是Samba。通过Samba，我们才能建立两个主机的安全访问。安装命令如下：</li></ol><pre><code class="lang-bash">sudo apt-get install samba #安装sambawhereis samba #查看samba的安装目录</code></pre><p>安装时可能会出现如下的问题</p><pre><code class="lang-sh">更换介质：请把标有 “Debian GNU/Linux 11.0.0 _Bullseye_ - Official amd64 DVD Binary-1 20210814-10:04”的盘片插入驱动器“/media/cdrom/”再按「回车」键</code></pre><p>解决方法：</p><pre><code class="lang-sh"># 修改/etc/apt/sources.list文件sudo vim /etc/apt/sources.list# 注释掉deb cdrom:开头的一行（第一行），然后更新一下sudo apt-get update</code></pre><h3 id="第三步：配置samba"><a href="#第三步：配置samba" class="headerlink" title="第三步：配置samba"></a>第三步：配置samba</h3><p>samba的配置文件在  /etc/samba 目录下，名称为 smb.conf</p><p>先将原来的文件备份<code>sudo cp /etc/samba/smb.conf /etc/samba/smb.conf.bak</code></p><p>使用vi命令，以管理员身份打开 bash <code>sudo vim /etc/samba/smb.conf</code></p><p>仔细阅读带注释的地方，完成个性化的修改，复制到配置文件的最后面</p><pre><code class="lang-bash">[global]        workgroup = SAMBA        security = user        passdb backend = tdbsam        printing = cups        printcap name = cups        load printers = yes        cups options = raw        log file = /var/log/samba/log.%m         #主机名，可修改        netbios name = cccs[red_leaves]# service introduction#无关紧要comment = &quot;This is a share service&quot;# share folder#共享目录，可修改path = /home/red_leaves# close anonymous accesspublic = yes# writablewritable = yes</code></pre><p>而后启动samba服务</p><pre><code class="lang-bash">sudo /etc/init.d/smbd start</code></pre><p>为了方便，今后不用再手动打开samba，可以将samba设为开机自启</p><pre><code class="lang-bash">sudo systemctl enable smbd.servicesudo systemctl enable nmbd.service</code></pre><p>完成之后，创建samba用户</p><pre><code class="lang-bash">sudo smbpasswd -a red_leavessudo pdbedit -Lv #查看用户详细信息、</code></pre><p>最后再进行磁盘映射，再输入映射文件夹路径，格式为</p><pre><code class="lang-shell">\\你的主机名(ip地址)\共享目录</code></pre><p>输入samba的用户名和密码（Linux的用户名和密码也可以）,可以发现成功访问VMware虚拟机的文件</p><p><a href="https://blog.csdn.net/weixin_40806910/article/details/81917077">更复杂的Linux samba的配置和使用</a></p><h3 id="第四步：安装bochs"><a href="#第四步：安装bochs" class="headerlink" title="第四步：安装bochs"></a>第四步：安装bochs</h3><p>千万要注意，不要使用apt yum等命令安装，而且千万不要安装2.6.x版本，2.6.x存在中断表等bug，（bochs黑屏不显示，报hardware error错误），要在<a href="https://bochs.sourceforge.io/">官网</a>下载安装包，手动编译安装。</p><p>课程中要求用gdb，所以这里在./configure选项中中使用gdb</p><pre><code class="lang-sh"># prefix指定目录，自己随意指定即可,docbook, --enable-disasm被新版的调试器删除了，在编译的时候会出错,要去掉# 遇到“install: 无法获取&quot;./bochsdbg&quot; 的文件状态(stat): 没有该文件或目录”，需要在make后，将bochs拷贝一份，命名为bochsdbg。在bochs-2.6.9文件夹下打开命令行，键入cp bochs bochsdbg即可。./configure --with-x11 --enable-gdb-stub --enable-pci --enable-pcidev --enable-plugins --enable-ne2000 --enable-pnic --disable-docbookcp bochs bochsdbgmakesudo make install</code></pre><p>安装时报错“fatal error: X11/Xlib.h: 没有那个文件或目录”，说明缺少c++运行库，安装即可</p><pre><code class="lang-sh">sudo apt-get install build-essentialsudo apt-get install xorg-*sudo apt-get install libgtk2.0-dev</code></pre><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>要想利用win机器向共享文件夹复制内容，需要在Linux中对共享文件夹提权</p><pre><code class="lang-sh">chmod 777 共享文件夹名 -R</code></pre><h3 id="第五步：编译Linux0-11内核代码中的文件"><a href="#第五步：编译Linux0-11内核代码中的文件" class="headerlink" title="第五步：编译Linux0.11内核代码中的文件"></a>第五步：编译Linux0.11内核代码中的文件</h3><p>在这里，我遇到了一个让我头疼的问题。</p><p>在linux目录下make编译时，如图所示<img src="https://cdn.jsdelivr.net/gh/redleaves699/image-host/images/shixun/48d70c44bc63ba09.png" alt="image"></p><p>这些报错，我在StackOverflow上查询到的结果是32位指令和64位指令不兼容。试了网上所有的方法，都不管用。后来，我才知道这个代码是上个世纪写的。。。太古老了，现代的编译器和操作系统已经无法支持它的编译了。。。于是，我在github上，找到了大佬根据现代amd64Linux修改的代码，终于可以运行了。我把它fork到了我的仓库。<a href="https://github.com/RedLeaves699/Hack-Linux-0.11">点此进入</a></p><p>接着运行虚拟机即可。文件是现成的，不需要自己写，唯一需要改的地方可能是下面注释的地方</p><hr><p>实验环境在<a href="https://pan.baidu.com/s/1UNkwMJ6GFx0Mn-xT6J_ZKA">这里</a>下载，提取码y29a</p><p>[备用站]<a href="http://redleaves.ys168.com/">redleaves.ys168.com</a> 的实验材料目录</p><pre><code class="lang-bash">megs: 16romimage: file=/usr/local/share/bochs/BIOS-bochs-latest #BIOS-bochs-latest的位置# with the LGPL BIOS, X windows can be usedvgaromimage: file=/usr/local/share/bochs/VGABIOS-lgpl-latest #VGABIOS-lgpl-latest的位置boot: floppyfloppya: type=1_44floppya: 1_44=&quot;Linux/Image&quot;, status=inserted #虚拟软盘（本例中为启动盘）的位置floppyb: type=1_44floppyb: 1_44=vvfat:&quot;b/&quot;, status=insertedata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14ata0-master: type=disk, path=&quot;images/hdc-0.11.img&quot;, mode=flat #虚拟硬盘的位置log: bochsout.txtpanic: action=askerror: action=reportinfo: action=reportdebug: action=ignorepci: enabled=1, chipset=i440fxvga: extension=vbe, update_freq=15keyboard: serial_delay=250, paste_delay=100000cpu: ips=15000000clock: sync=slowdownmouse: enabled=0</code></pre><p>执行<code>sudo ./run</code>后，可以看到虚拟机正常开启。</p><p>如果是黑屏的，要在虚拟机B的控制台加一个c（continue），至此，Debian系统实验环境配置正式完成。</p><h3 id="第六步：使用GDB调试"><a href="#第六步：使用GDB调试" class="headerlink" title="第六步：使用GDB调试"></a>第六步：使用GDB调试</h3><p>下载第五步提到的实验环境，在两个终端分别运行./mygdb, ./rungdb脚本即可开始对内核的调试</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 实训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验环境配置 </tag>
            
            <tag> Debian </tag>
            
            <tag> Linux0.11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Node.js和hexo搭建GitHub博客（以windows为例）</title>
      <link href="/2021/09/02/Front/%E4%BD%BF%E7%94%A8hexo%E5%92%8Cnode.js%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/09/02/Front/%E4%BD%BF%E7%94%A8hexo%E5%92%8Cnode.js%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="第一步：安装node-js"><a href="#第一步：安装node-js" class="headerlink" title="第一步：安装node.js"></a>第一步：安装node.js</h2><p><a href="https://zhuanlan.zhihu.com/p/47822968">什么是 Nodejs ?</a></p><p><a href="https://nodejs.org/zh-cn/download/">点此前往官网下载</a></p><h2 id="第二步：安装hexo"><a href="#第二步：安装hexo" class="headerlink" title="第二步：安装hexo"></a>第二步：安装hexo</h2><p>在<strong>git bash</strong>中，键入<strong>npm install hexo -g</strong>命令即可，安装时间比较长，在我安装的时候没显示安装进度，执行这一步，需要一个稳定的网络。</p><h2 id="第三步：初始化博客文件夹"><a href="#第三步：初始化博客文件夹" class="headerlink" title="第三步：初始化博客文件夹"></a>第三步：初始化博客文件夹</h2><p>新建一个空文件夹，cd到新文件夹，执行<strong>hexo init</strong>命令，这时hexo会生成很多文件，这些文件是未来生成博客时的重要组件，注意这一步也需要联网。</p><h2 id="第四步：加载博客模板"><a href="#第四步：加载博客模板" class="headerlink" title="第四步：加载博客模板"></a>第四步：加载博客模板</h2><p>在网上寻找博客模板，每个模板都有自己的特点，所以模板的使用方法需要自己参考模板的readme.md文件。</p><h2 id="第五步：运行hexo"><a href="#第五步：运行hexo" class="headerlink" title="第五步：运行hexo"></a>第五步：运行hexo</h2><p>模板已经加载完毕，现在要在本地运行查看效果。</p><p>依次输入以下两条命令，一个是生成网页文件，一个是运行本地服务器</p><pre><code class="lang-bash">hexo g #生成网页文件hexo s #运行本地服务器</code></pre><h2 id="第六步：访问本地网页，查看效果"><a href="#第六步：访问本地网页，查看效果" class="headerlink" title="第六步：访问本地网页，查看效果"></a>第六步：访问本地网页，查看效果</h2><p>访问 <a href="https://localhost:4000">https://localhost:4000</a> 进入网站主页</p><h2 id="第七步：将本地网页部署在Github上"><a href="#第七步：将本地网页部署在Github上" class="headerlink" title="第七步：将本地网页部署在Github上"></a>第七步：将本地网页部署在Github上</h2><p>经过前面的操作，我们已经在本地搭好了博客，接下来，我们要把博客传送到GitHub上。</p><p>先要配置博客目录下（不是博客主题目录）的_config.yml文件，填写deploy选项，注意，<strong>每个字段冒号后都有一个空格</strong></p><pre><code class="lang-yaml">deploy:  type: git  repository: https://github.com/sample/sample.github.io.git  branch: master</code></pre><p>然后执行npm命令安装hexo-deployer-git插件</p><pre><code class="lang-bash">npm install hexo-deployer-git --save</code></pre><p>运行hexo g生成，再运行hexo d提交</p><pre><code class="lang-bash">hexo ghexo d</code></pre><p>等等，我们是不是忘了什么？</p><p>hexo d命令是提交到Github上的，意味着需要身份验证，我们上面的操作好像没有验证身份。。。</p><p>所以会报unable to access错，类似下面这样</p><pre><code class="lang-bash">unable to access &#39;https://github.com/*/*.github.io.git/&#39;: Couldn&#39;t resolve host &#39;github.com</code></pre><p>验证身份的方法：在deploy的repository中输入（不包含大括号）</p><p>respository: <a href="https://{Github用户名}:{Github令牌或SSH密钥}/sample/sample.github.io.git">https://{Github用户名}:{Github令牌或SSH密钥}/sample/sample.github.io.git</a></p><pre><code class="lang-yaml">respository: https://username:token@github.com/RedLeaves699/RedLeaves699.github.io.git</code></pre><p>注意GitHub现在不能密码认证了，<a href="https://github.blog/changelog/2021-08-12-git-password-authentication-is-shutting-down">详情见此</a>。</p><p>修改完毕后再hexo g，hexo d提交，发现可以成功提交了。如果还出问题，那就是hexo git冲突的问题。</p><h2 id="Extend01-解决MarkDown与MathJax渲染冲突"><a href="#Extend01-解决MarkDown与MathJax渲染冲突" class="headerlink" title="Extend01 : 解决MarkDown与MathJax渲染冲突"></a>Extend01 : 解决MarkDown与MathJax渲染冲突</h2><p>添加MathJax后写几个公式发现渲染出了很多问题。原因是hexo-renderer-marked会把一些特殊的latex符号转换为相应的html标签，比如在markdown语法中，下划线<code>_</code>代表斜体，会被转化为<code>&lt;em&gt;</code>标签，<code>\\</code>也会被转义成一个<code>\</code>。而Latex格式书写的数学公式下划线_ 表示角标，<code>\\</code>表示公式换行，有特殊的含义，所以MathJax引擎在渲染数学公式的时候就会出错。</p><p>解决方法:更换Hexo的MarkDown渲染引擎，用hexo-renderer-kramed 替换默认的hexo-renderer-marked引擎，并作出部分修改</p><p>针对二次转义的问题，我们只要不让inline.js去转义\\,{,}在MathJax中有特殊用途的字符就行了。  </p><p>编辑.\node_modules\kramed\lib\rules\inline.js 脚本：</p><pre><code class="lang-javascript">【第一步】将escape: /^\\([\\`*&#123;&#125;\[\]()# +\-.!_&gt;])/,替换为escape: /^\\([`*\[\]()# +\-.!_&gt;])/,这一步取消了对\\,\&#123;,\&#125;的转义(escape)【第二步】em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,替换为em:/^((?:|[\s\S])+?)(?!)/,这一步取消了对斜体标记_和\*的转义</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网页前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各种语言实现随机数和计时</title>
      <link href="/2021/08/17/Programming%20Language/%E5%90%84%E7%A7%8D%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%92%8C%E8%AE%A1%E6%97%B6/"/>
      <url>/2021/08/17/Programming%20Language/%E5%90%84%E7%A7%8D%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%92%8C%E8%AE%A1%E6%97%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="C语言生成随机数"><a href="#C语言生成随机数" class="headerlink" title="C语言生成随机数"></a>C语言生成随机数</h2><h3 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h3><pre><code class="lang-cpp">int void rand() //按照某个公式生成一个数void srand(unsigned int seed) //修改随机数种子srand((unsigned int )time(NULL) //time（NULL）随毫秒变化，种子变化极快，生成多个种子</code></pre><h3 id="限制范围"><a href="#限制范围" class="headerlink" title="限制范围"></a>限制范围</h3><p>生成$(min，max)$之间的随机数</p><pre><code class="lang-cpp">rand % (max - min + 1) + min</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">//生成(min，max)之间的随机数int generate_random(int minn, int maxx) &#123;    return rand() % (maxx - minn + 1) + minn;//&#125;void test() &#123;    srand(time(NULL));//生成随机数种子    int n = read();    for (int i = 1; i &lt;= n; ++i) &#123;        a[i] = generate_random(1, 10000);    &#125;    Print(a[i]);&#125;</code></pre><h2 id="C语言计时器"><a href="#C语言计时器" class="headerlink" title="C语言计时器"></a>C语言计时器</h2><p>clock()函数返回值是时钟打点数，要换算成秒，需要除以CLK_TCK或者 CLK_PER_SEC。</p><pre><code class="lang-c">#include &lt;time.h&gt;int main() &#123;    double st0 = clock();    merge_sort(std, n);    double ed0 = clock();    printf(&quot;std time = %.3f\n&quot;, (ed0 - st0) / CLOCKS_PER_SEC);    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> 随机数 </tag>
            
            <tag> 计时 </tag>
            
            <tag> 实用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百年未有之大变局</title>
      <link href="/2021/07/26/%E7%99%BE%E5%B9%B4/"/>
      <url>/2021/07/26/%E7%99%BE%E5%B9%B4/</url>
      
        <content type="html"><![CDATA[<p>百年未有之大变局，概括起来说，就是当前国际格局和国际体系正在发生深刻调整，全球治理体系正在发生深刻变革，<br>国际力量对比正在发生近代以来最具革命性的变化，世界范围内正在呈现出影响人类历史进程和趋向的重大态势。<br> 《习近平 新时代中国特色社会主义思想学习问答》第42页，第二段</p>]]></content>
      
      
      <categories>
          
          <category> 感想随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 政治历史 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A - Alice and Bob</title>
      <link href="/2021/07/26/Algorithm/A%20-%20Alice%20and%20Bob/"/>
      <url>/2021/07/26/Algorithm/A%20-%20Alice%20and%20Bob/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>填表法和刷表法的速度相差能有多大？将近百倍！</p><h2 id="题目原文"><a href="#题目原文" class="headerlink" title="题目原文"></a>题目原文</h2><p>Alice and Bob like playing games. There are two piles of stones with numbers n and m. Alice and Bob take turns to operate, each operation can take away $k(k&gt;0)$ stonesfrom one pile and take away $s \times k(s \geq 0)$ stones from another pile. Alice plays first. The person who cannot perform the operation loses the game.</p><p>Please determine who will win the game if both Alice and Bob play the game optimally.</p><h3 id="思路一-原始思路-动态规划"><a href="#思路一-原始思路-动态规划" class="headerlink" title="思路一 原始思路 : 动态规划"></a>思路一 原始思路 : 动态规划</h3><p>博弈论动态规划(又称暴力SG函数法)，令$f[i][j]$为当前局面的状态为第一堆还剩$i$个，第二堆还剩$j$个(今后再描述状态会使用$(i, j)$表示)，遇到这个状态的人是否会赢，将赢的情况记为$N$，输的情况记为$P$。很明显，$f[0][0] = P$，因为两堆石子都取完了，遇到这个局面的人就输了。与此相反，假设状态为$(0, i)$，说明这个人可以将$i$个石子全取走，使得下一个人的状态为$f[0][0] = P$，所以遇到这个状态的人赢了，将局面$(i, j)$记为$N$。</p><p>这时，我们使用动态规划的方法，考虑状态$f[i][j]$，考虑先手(这里的先后手是相对的)所有可能的取法，比如说先手在左面一堆取了一个石子，留给后手的状态就是$f[i - 1][j]$，如果$f[i - 1][j] = P$，说明当前先手留给后手的状态是后手必败，先手必胜。反之，$f[i - 1][j] = N$，则为先手败，后手胜。</p><p>先手的操作有很多种，所以我们列举出所有的转移，无非是两种情况 :</p><ol><li>先手无论怎么取，都不存在一种取法$(i - k, i - s *k)$ 或 $(i - s* k, j)$，使得后手在这种情况下为失败$P$，那么就表明情况$(i, j)$下先手必败。</li><li>先手的取法中，存在一种取法$(i - k, i - s *k)$ 或 $(i - s* k, j)$，使得后手在这种情况下为失败$P$，那么，先手就会赢(先手选择最优方案， 一定是让ta赢)</li></ol><p>按这种思路，我们得到了如下代码，代码中使用的是填表法，复杂度(O$(n^3log(n))$)</p><pre><code class="lang-cpp">//(n^3 log n)#include &lt;cstdio&gt;#include &lt;assert.h&gt;const int MAXN = 500;#define P 1 //先手不赢#define N 0 //先手赢int f[MAXN+10][MAXN+10];int main() &#123;    f[0][0] = P;    for (int i = 1; i&lt;= MAXN; ++i) &#123;        f[i][0] = f[0][i]  = N;    &#125;    for (int i = 1; i &lt;= MAXN; ++i)&#123;        for (int j = 1; j &lt;= MAXN; ++j) &#123;            int neg = N;//统计所有可能状态中是否有P状态            for (int k = 1; k &lt;= j; ++k) &#123;                for (int s = 0; s * k &lt;= i; ++s) &#123;                    neg |= f[i - s * k][j - k];                &#125;            &#125;            for (int k = 1; k &lt;= i; ++k) &#123;                for (int s = 0; s * k &lt;= j; ++s) &#123;                    neg |= f[i - k][j - s * k];                &#125;            &#125;            if (!neg) &#123;                f[i][j] = P;            &#125; else &#123;                f[i][j] = N;            &#125;        &#125;    &#125;    int T;    scanf(&quot;%d&quot;, &amp;T);    while(T--) &#123;        int x, y;        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);        printf(&quot;%s\n&quot;, f[x][y] == N?&quot;Alice&quot;:&quot;Bob&quot;);    &#125;    return 0;&#125;</code></pre><h3 id="思路二-基于思路一的优化"><a href="#思路二-基于思路一的优化" class="headerlink" title="思路二 : 基于思路一的优化"></a>思路二 : 基于思路一的优化</h3><p>经过上面一通严谨的分析，我们发现在我们枚举的全部后手状态中，只有f[…][…] = P这个结果对于断定$f[i][j]$的值是有帮助的。这也是这句话存在的意义。</p><pre><code class="lang-cpp">neg |= f[i - s * k][j - k];//统计所有可能状态中是否有P状态</code></pre><p>这句话是有优化空间的。我们能否倒过来想一下，如果我在状态$(i - k, i - s *k)$ 或 $(i - s* k, j)$已经知道遇到这两种情况必输，那么，是不是情况$(i, j)$，就是必赢的？对，我们可以不用笨笨的在$(i,j)$逆推全部情况！而是可以用刷表法，当且仅当$f[i][j] = P$时，我们才会从$(i, j)$推$(i + k, i + s *k)$ 或 $(i + s* k, j)$，从而节省大量的时间！</p><p>刷表法的代码，仍然不够通过测试。</p><pre><code class="lang-cpp">//(n^2 log n)#include &lt;cstdio&gt;const int MAXN = 5000;#define P 0 //后手赢#define N 1 //先手赢int f[MAXN + 10][MAXN + 10];int main() &#123;    for (int i = 0; i &lt;= MAXN; ++i) &#123;        for (int j = 0; j &lt;= MAXN; ++j) &#123;            if (f[i][j] == P) &#123;                for (int k = 1; k + j &lt;= MAXN; ++k) &#123;                    for (int s = 0; s * k + i &lt;=MAXN; ++s) &#123;                        f[i + s * k][j + k] = N;                    &#125;                &#125;                for (int k = 1; k + i &lt;= MAXN; ++k) &#123;                    for (int s = 0; s * k + j &lt;=MAXN; ++s) &#123;                        f[i + k][j + s * k] = N;                    &#125;                &#125;            &#125;        &#125;    &#125;    int T;    scanf(&quot;%d&quot;, &amp;T);    while(T--) &#123;        int x, y;        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);        printf(&quot;%s\n&quot;, f[x][y] == N?&quot;Alice&quot;:&quot;Bob&quot;);    &#125;    return 0;&#125;</code></pre><h3 id="再优化"><a href="#再优化" class="headerlink" title="再优化"></a>再优化</h3><p>$n= 5000$ 的情况下，跑$n^2$的算法是极其危险的，题目可能会卡常，要注意细节。$f[i][j]$的值只有$0,1$两种情况，所以把$f[i][j]$的声明由int改为bool就会<strong>减少几百毫秒</strong>的运行时间，和4倍的空间，至此，程序终于通过了。</p><h3 id="扩展-SG函数的知识"><a href="#扩展-SG函数的知识" class="headerlink" title="扩展 : SG函数的知识"></a>扩展 : SG函数的知识</h3><p><a href="https://oi-wiki.org/math/game-theory/"><font color = "blue" face = "KaiTi"> -&gt; 博弈论 OI Wiki</font></a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2021牛客暑期多校第一场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈（Monotone Priority Stack）</title>
      <link href="/2021/07/26/Algorithm/Monotone%20Priority%20Stack/"/>
      <url>/2021/07/26/Algorithm/Monotone%20Priority%20Stack/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>满足单调性的栈结构</p><h2 id="伪代码描述"><a href="#伪代码描述" class="headerlink" title="伪代码描述"></a>伪代码描述</h2><pre><code class="lang-c">insert xwhile !sta.empty() &amp;&amp; sta.top()&lt;x    sta.pop()sta.push(x)</code></pre><h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>定义函数 $f(i)$ 代表数列中第 $i$ 个元素之后第一个大于 $a_{i}$的元素的下标，即 $f(i)=min_{i<j\leq n, a_{j} > a_{i}}{j}$。若不存在，则 $f(i)=0$。<br>求出$f(1) … f(n)$的值。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>5<br>1 4 2 3 5</p><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>2 5 4 5 0</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p><a href="http://poj.org/problem?id=3250">[USACO06NOV] POJ3250 Bad Hair Day</a></p><pre><code class="lang-c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXN 3000000 + 100struct num &#123;    int p, val;&#125;stack[MAXN];void Print_array(int *a, int n) &#123;    for (int i = 1; i &lt;= n; ++i) &#123;        if (i == 1)printf(&quot;%d&quot;, a[i]);        if (i &gt; 1)printf(&quot; %d&quot;, a[i]);    &#125;    printf(&quot;\n&quot;);&#125;int ans[MAXN];int solve() &#123;    int top = 0;    int n, x;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; ++i) &#123;        scanf(&quot;%d&quot;, &amp;x);        struct num xx = &#123;i, x&#125;;        if (top == 0) stack[++top] = xx, ans[stack[top].p] = 0;        else &#123;            while (top &amp;&amp; xx.val &gt; stack[top].val) &#123;                ans[stack[top].p] = xx.p;                --top;            &#125;            stack[++top] = xx;        &#125;    &#125;    while (top--) &#123;        ans[stack[top].p] = 0;    &#125;    Print_array(ans, n);    return 1;&#125;int main() &#123;    solve();    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓扑排序</title>
      <link href="/2021/07/26/Algorithm/Toposort/"/>
      <url>/2021/07/26/Algorithm/Toposort/</url>
      
        <content type="html"><![CDATA[<h2 id="1-根据dfs的拓扑排序"><a href="#1-根据dfs的拓扑排序" class="headerlink" title="1, 根据dfs的拓扑排序"></a>1, 根据dfs的拓扑排序</h2><p>dfs可以找出天然的拓扑序，只是在最后需要倒转一下，想想为什么(因为最后一层先输出)</p><p>遍历时，把遍历过程中的点的标记置为-1，如果再次访问到标记为-1的点，说明有环路，不能拓扑排序</p><p>返回时，把遍历完的点置为1，表示这些点遍历完毕，没有环路，未来不用遍历了</p><pre><code class="lang-c">int dfs(int u, int n, int *ans) &#123;    flag[u] = -1;    for (int v = 1; v &lt;= n; ++v) &#123;        if (G[u][v]) &#123;            if (flag[v] == -1) return false;            else if (flag[v] == 0 &amp;&amp; !dfs(v, n, ans)) return false;        &#125;    &#125;    flag[u] = 1;    ans[cnt++] = u;    return true;&#125;int toposort(int n, int m, int *ans) &#123;    cnt = 0;    memset(G, 0, sizeof(G));    memset(flag, 0, sizeof(flag));    for (int i = 0; i &lt; m; ++i) &#123;        int x, y;        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);        G[x][y] = 1;    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        if (!flag[i]) &#123;            if (!dfs(i, n, ans)) return false;        &#125;    &#125;    reverse(ans, ans + cnt);    return true;&#125;</code></pre><h2 id="2-根据bfs的拓扑排序"><a href="#2-根据bfs的拓扑排序" class="headerlink" title="2, 根据bfs的拓扑排序"></a>2, 根据bfs的拓扑排序</h2><p>原理为不停维护入度为0的点，让其入队，直到所有的点都被遍历到</p><p>如果有环路，那么那个点不会入队，入度不可能被减为1，所以判断环路的条件就是是否遍历了所有点</p><pre><code class="lang-c">int G[MAXN][MAXN], in[MAXN];int cnt = 0;int toposort(int n, int m, int *ans) &#123;    std::queue&lt;int&gt; q;    for (int i = 1; i &lt;= n; ++i) &#123;        if (in[i] == 0) q.push(i);    &#125;    while (!q.empty()) &#123;        int u = q.front();q.pop();        ans[cnt++] = u;        for (int v = 1; v &lt;= n; ++v) &#123;            if (G[u][v]) &#123;                in[v]--;                if (in[v] == 0) q.push(v);            &#125;        &#125;    &#125;    return cnt == n;&#125;int solve(int n, int m, int *ans) &#123;    memset(G, 0, sizeof(G));    memset(in, 0, sizeof(in));    cnt = 0;    for (int i = 0; i &lt; m; ++i) &#123;        int x, y;        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);        G[x][y] = 1;        in[y]++;    &#125;    return toposort(n, m, ans);&#125;</code></pre><h2 id="3-根据层序的拓扑排序"><a href="#3-根据层序的拓扑排序" class="headerlink" title="3, 根据层序的拓扑排序"></a>3, 根据层序的拓扑排序</h2><p>经典题目《车站分级》中的排序方式，可以找出拓扑序的层数</p><pre><code class="lang-c">int toposort(int G[][MAXN], int n, int *in, int *out) &#123;    int tmp[MAXN], book[MAXN];    memset(book, 0, sizeof(book));    int depth = 0;    while (1) &#123;        int cnt = 0;        for (int p = 1; p &lt;= n; ++p) &#123;            if (!in[p] &amp;&amp; !book[p]) &#123;                tmp[cnt++] = p;                book[p] = 1;            &#125;        &#125;        if (cnt == 0) break;        for (int i = 0; i &lt; cnt; ++i) &#123;            for (int j = 0; j &lt; MAXN &amp;&amp; out[tmp[i]] &gt; 0; ++j) &#123;                if (G[tmp[i]][j]) &#123;                    in[j]--;                    out[tmp[i]]--;                &#125;            &#125;        &#125;        ++depth;    &#125;    return depth;&#125;</code></pre><h2 id="4-拓扑排序经典题目"><a href="#4-拓扑排序经典题目" class="headerlink" title="4, 拓扑排序经典题目"></a>4, 拓扑排序经典题目</h2><p><a href="https://vjudge.net/problem/UVA-10305">UVa 10305 Ordering Tasks</a></p><p><a href="https://vjudge.net/problem/%E8%AE%A1%E8%92%9C%E5%AE%A2-T2076">NOIP 2013 普及组T4 车站分级</a></p><p><a href="https://www.luogu.com.cn/problem/P3243">HNOI2015 菜肴制作</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> toposort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown 字体，字号，颜色</title>
      <link href="/2021/07/26/Markdown/MarkdownFont/"/>
      <url>/2021/07/26/Markdown/MarkdownFont/</url>
      
        <content type="html"><![CDATA[<h2 id="1-效果实例"><a href="#1-效果实例" class="headerlink" title="1.效果实例"></a>1.效果实例</h2><font size = 4 face="HEI" color = "red">黑体</font><font size = 5 face="KAI" color = "(0,255,255)">楷体</font><font size = 6 face="GB18030 Bitmap" color = "#00FFFF">扩展字体</font><h2 id="2-markdown代码"><a href="#2-markdown代码" class="headerlink" title="2.markdown代码"></a>2.markdown代码</h2><pre><code class="lang-markdown">#### 使用 &lt;font&gt; 标签的修改字体，字号，颜色这里是默认字体&lt;font size = 4 face=&quot;HEI&quot; color = &quot;red&quot;&gt;黑体&lt;/font&gt;&lt;font size = 5 face=&quot;KAI&quot; color = (0,255,255)&gt;楷体&lt;/font&gt;&lt;font size = 6 face=&quot;GB18030 Bitmap&quot; color = &quot;#00FFFF&quot;&gt;扩展字体&lt;/font&gt;&lt;style&gt;p &#123;font-size: 2rem;&#125;&lt;/style&gt;</code></pre><h2 id="3-常用字体集锦"><a href="#3-常用字体集锦" class="headerlink" title="3.常用字体集锦"></a>3.常用字体集锦</h2><div class="table-container"><table><thead><tr><th style="text-align:center">字体名称</th><th style="text-align:center">对应markdown表示</th></tr></thead><tbody><tr><td style="text-align:center">黑体</td><td style="text-align:center"><code>&lt;font face=&#39;SimHei&#39;&gt;</code></td></tr><tr><td style="text-align:center">宋体</td><td style="text-align:center"><code>&lt;font face=&#39;SimSun&#39;&gt;</code></td></tr><tr><td style="text-align:center">新宋体</td><td style="text-align:center"><code>&lt;font face=&#39;NSimSun&#39;&gt;</code></td></tr><tr><td style="text-align:center">仿宋</td><td style="text-align:center"><code>&lt;font face=&#39;FangSong&#39;&gt;</code></td></tr><tr><td style="text-align:center">楷体</td><td style="text-align:center"><code>&lt;font face=&#39;KaiTi&#39;&gt;</code></td></tr><tr><td style="text-align:center">仿宋_GB2312</td><td style="text-align:center"><code>&lt;font face=&#39;FangSong_GB2312&#39;&gt;</code></td></tr><tr><td style="text-align:center">楷体_GB2312</td><td style="text-align:center"><code>&lt;font face=&#39;KaiTi_GB2312&#39;&gt;</code></td></tr><tr><td style="text-align:center">微软雅黑</td><td style="text-align:center"><code>&lt;font face=&#39;Microsoft YaHei&#39;&gt;</code></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在markdown中插入图片</title>
      <link href="/2021/07/26/Markdown/MarkdownImage/"/>
      <url>/2021/07/26/Markdown/MarkdownImage/</url>
      
        <content type="html"><![CDATA[<h2 id="一，base64格式"><a href="#一，base64格式" class="headerlink" title="一，base64格式"></a>一，base64格式</h2><p>另一个坑：不能有空格！ 包括可替换文本；资源标签。</p><pre><code class="lang-markdown">![image][image id]you can write your document here [image id]:data:image/png;base64, ...your image&#39;s base64</code></pre><h2 id="二，-网址-本地文件格式"><a href="#二，-网址-本地文件格式" class="headerlink" title="二， 网址,本地文件格式"></a>二， 网址,本地文件格式</h2><pre><code class="lang-markdown">![avatar](http://baidu.com/pic/doge.png)![avatar](/home/picture/1.png)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于markdown中文首行缩进的问题</title>
      <link href="/2021/07/26/Markdown/MarkdownIndent/"/>
      <url>/2021/07/26/Markdown/MarkdownIndent/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5 face = "KAITI">markdown语法中，多个空格只会被翻译成一个空格</font></strong></p><pre><code class="lang-markdown">半角的空白&amp;ensp;或&amp;#8194;全角的空白&amp;emsp;或&amp;#8195;不断行的空白格&amp;nbsp;或&amp;#160;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>G - League of Legends</title>
      <link href="/2021/07/26/Algorithm/G%20-%20League%20of%20Legends/"/>
      <url>/2021/07/26/Algorithm/G%20-%20League%20of%20Legends/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>什么时候进行单调队列优化？代码中包含区间处理的大量细节。</p><h2 id="题目原文"><a href="#题目原文" class="headerlink" title="题目原文"></a>题目原文</h2><p>ZLOIers love playing League of Legends, but they seldom have time to play together.</p><p>When summer vacation came, each of them scheduled some free time for it, which could be described as an interval $[a_i,b_i)$(minute).</p><p>Now the ${n}$ ZLOIers plan to play in $k$ groups. Each group will play together when all the players in it are free. Each ZLOIer joins exactly one group, and each group has at least one ZLOIer. The number of people in each group does not necessarily need to be equal.</p><p>Since they don’t have a full plan of groups yet, they want you to maximize the total time the ${k}$ groups can play.You should tell them maximum total time.</p><p>Note that a group must play at least ${1}$ minute, and the total time is not accumulated by each person, but by each group.</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定$n$个区间，要求将它们分成$k$组，每组之间有交，最大化每组交长度之和</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目中<strong>最大化每组交长度之和</strong>这句告诉我们，这是一个最优化问题，要想到搜索和动态规划</p><p>那么，应该如何动态规划？</p><h3 id="先考虑特殊情况——处理如下排布的区间"><a href="#先考虑特殊情况——处理如下排布的区间" class="headerlink" title="先考虑特殊情况——处理如下排布的区间"></a>先考虑特殊情况——处理如下排布的区间</h3><p>大概形状如下</p><pre><code class="lang-n">-------------    ------------      -------------         ------------</code></pre><p>设$dp[i][j]$为前$i$个线段，分为$j$组，得到的最大交区间的和，可以得到递推式</p><p>刷表递推</p><script type="math/tex; mode=display">dp[i][j]+b[i]-a[k]\rightarrow dp[k][j+1]\ \ (b[i] >= a[k])</script><p>填表递推</p><script type="math/tex; mode=display">dp[i][j]=dp[k][j-1]+b[k+1]-a[i]\ \ (b[i] >= a[k])</script><p>时间复杂度是$O(n^3)$的。题目中的数据$n\leq 5000$这样的方法不够解决问题。</p><p>我们发现在填表递推的式子中，$dp[k][j-1]+b[k+1]$这一项实际上在寻找$dp[1][j-1]+b[k+1] \sim dp[i-1][j-1]+b[k+1]$的最大值。这样就可以用单调队列优化，从而实现在$O(1)$的时间里找到最大值$dp[k][j-1]+b[k+1]$出现的位置$k$。循环少了一重，复杂度变为$O(n^2)$。</p><p>注意一点，使用单调队列优化时，要把定义的i,j反过来，即定义$dp[i][j]$为前$j$个线段，分为$i$组，得到的最大交区间的和。</p><p>这样一个特殊化的问题至此解决了。</p><h3 id="再考虑更多细节——处理大区间"><a href="#再考虑更多细节——处理大区间" class="headerlink" title="再考虑更多细节——处理大区间"></a>再考虑更多细节——处理大区间</h3><p>我们通过动手画图观察到，大区间(能够包含其它区间的区间)有时不会影响结果，有时又可以把他们独立算一段，使最终结果变得大一些。总结一下，大区间的处理方式就两种</p><p>&emsp;&emsp;1.归属到一个被它包含的区间所在的组，不影响答案<br>&emsp;&emsp;2.独自一组，长度直接算入答案</p><p>最后对大区间的处理可以独立处理，方法类似于前缀和，详见代码。</p><h3 id="预处理区间"><a href="#预处理区间" class="headerlink" title="预处理区间"></a>预处理区间</h3><p>细节见代码，主要操作是把特殊区间和大区间分开，依据代码实现模拟即可看懂，比较巧妙。必须学会这种方法。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="lang-cpp">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;queue&gt;const int MAXN = 5e3 + 10;struct interval &#123;    int l, r;    bool operator &lt;(const interval &amp;i)const &#123;        return l == i.l ? r &gt; i.r : l &lt; i.l;    &#125;&#125;vt[MAXN], v[MAXN];int len[MAXN], dp[MAXN][MAXN];int main() &#123;    int n, K;    scanf(&quot;%d%d&quot;, &amp;n, &amp;K);    for (int i = 1; i &lt;= n; ++i) &#123;        scanf(&quot;%d%d&quot;, &amp;vt[i].l, &amp;vt[i].r);    &#125;    std::sort(vt + 1, vt + 1 + n);    int cnt = 0, nn = 0, prev_r = 1e9;    for (int i = n; i &gt;= 1; --i) &#123;        if (prev_r &lt;= vt[i].r) len[++cnt] = vt[i].r - vt[i].l;        else prev_r = vt[i].r, v[++nn] = vt[i];    &#125;    std::reverse(v + 1, v + 1 + nn);    std::sort(len + 1, len + 1 + cnt, std::greater&lt;int&gt; ());    std::fill_n(&amp;dp[0][0], MAXN * MAXN, -1);    dp[0][0] = 0;    for (int i = 1; i &lt;= K; ++i) &#123;        std::deque&lt;int&gt; dq;        for (int j = 1; j &lt;= nn; ++j) &#123;            if (~dp[i - 1][j - 1]) &#123;                while (!dq.empty() &amp;&amp; dp[i - 1][dq.back()] + v[dq.back() + 1].r &lt;= dp[i - 1][j - 1] + v[j].r) &#123;                    dq.pop_back();                &#125;                dq.push_back(j - 1);            &#125;            while (!dq.empty() &amp;&amp; v[dq.front() + 1].r &lt;= v[j].l) dq.pop_front();            if (!dq.empty()) &#123;                dp[i][j] = dp[i - 1][dq.front()] + v[dq.front() + 1].r - v[j].l;            &#125;        &#125;    &#125;    int sum = 0, ans = 0, tmp = std::min(K, cnt);    for (int i = 0; i &lt;= tmp; ++i) &#123;        sum += len[i];        if(~dp[K - i][nn])ans = std::max(ans, sum + dp[K - i][nn]);    &#125;    printf(&quot;%d\n&quot;, ans);    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2021牛客暑期多校第二场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K - Stack</title>
      <link href="/2021/07/26/Algorithm/K%20-%20Stack/"/>
      <url>/2021/07/26/Algorithm/K%20-%20Stack/</url>
      
        <content type="html"><![CDATA[<h2 id="题目原文"><a href="#题目原文" class="headerlink" title="题目原文"></a>题目原文</h2><p>YT had a magic permutation $a_{1},a_{2},\cdots, a_{n}$, and he constructed a sequence $b_{1},b_{2},\cdots b_{n}$ by the following pseudo code:</p><pre><code class="lang-cpp">Stk is an empty stackfor i = 1 to n :    while ( Stk is not empty ) and ( Stk&#39;s top &gt; a[i] ) :        pop Stk    push a[i]    b[i]=Stk&#39;s size</code></pre><p>But he somehow forgot the permutation $a$, and only got some $k$ elements of $b_{i}$.</p><p>Construct a permutation $a$ satisfying these $b_{i}$, or determine no such permutation exists.</p><p>Here a permutation refers to a sequence that contains all integers from $1$ to ${n}$ exactly once.</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>定义条件A为：位置$pos$之前（包括该位置）有$x$个数不小于这个位置上的数$a[pos]$。现在知道多个位置满足条件A,将这些要求记为$(pos, x)$，能否构造一个序列，满足给定的全部要求？</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>先考虑什么时候不能，不能的情况其实只有一种，就是$b[i]$的需求大于提供的$i$个位置。</p><p>再考虑可行的情况下，如何解决安排的问题。由离散数学的知识，小于等于(或大于)是一个偏序，很多个小于等于情况可以抽象为偏序关系，继而可以得到关系图，偏序的关系图是有向无环的(DAG)，所以想到根据题目条件建立关系图后，用拓扑排序的思想解题。</p><p>关系图的节点是谁？只能是位置，因为我们知道的条件是关于位置的。如何知道这个位置(上的数)和其他位置(上的数)的关系？可以<strong>模拟位置序列的插入</strong>。</p><p>1234567…，将这些属于位置的编号，按照伪代码的方式压栈弹栈，<strong>注意，当某个位置有需求时，需要将栈的大小弹至b[i]规定的大小。此时，这个位置上的数必大于等于于栈顶元素，小于最后一次弹出的数</strong>，这样就建立了关系图，</p><script type="math/tex; mode=display">a[栈顶数的位置] \leq a[位置pos] < a[刚弹出的数的位置]</script><p>可以抽象出这样的关系图(代码中的抽象关系)</p><script type="math/tex; mode=display">刚弹出的数的位置 \rightarrow pos \rightarrow 栈顶数的位置</script><p>由此，拓扑排序第一层就是最大层，此后的数越来越小</p><p>实现的详情见代码注释</p><h2 id="编程实现"><a href="#编程实现" class="headerlink" title="编程实现"></a>编程实现</h2><pre><code class="lang-cpp">#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;const int MAXN = 1e6 + 10;int b[MAXN], in[MAXN], next[MAXN], ans[MAXN];void Print(std::vector &lt;int&gt; &amp;v, int n) &#123;    for (int i = 0; i &lt; v.size(); ++i) &#123;        ans[v[i]] = n - i;//在相应位置由大到小填入数字    &#125;    for (int i = 1; i &lt;= n ; ++i) &#123;        if (i == 1)printf(&quot;%d&quot;, ans[i]);        else printf(&quot; %d&quot;, ans[i]);    &#125;printf(&quot;\n&quot;);&#125;std::queue &lt;int&gt; q;std::vector &lt;int&gt; v;void toposort(int n) &#123;      for (int i = 1; i &lt;= n; ++i) &#123;        if (in[i] == 0) q.push(i);    &#125;    while (!q.empty()) &#123;        int t = q.front();q.pop();        v.push_back(t);//按照拓扑序放置位置序        in[next[t]]--;        if (in[next[t]] == 0) &#123;            q.push(next[t]);        &#125;    &#125;    Print(v, n);&#125;std::stack &lt;int&gt; s;int solve() &#123;    int n, k;    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);    for (int i = 1; i &lt;= k; ++i) &#123;        int pos;        scanf(&quot;%d&quot;, &amp;pos);scanf(&quot;%d&quot;, &amp;b[pos]);    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        int t;        if (b[i]) &#123;            if (b[i] &gt; i) return -1;            while (s.size() &amp;&amp; s.size() &gt;= b[i]) t = s.top(), s.pop();            next[t] = i;        &#125;        if(!s.empty()) next[i] = s.top();        s.push(i);    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        in[next[i]]++;    &#125;    toposort(n);    return 0;&#125;int main() &#123;    if (solve() == -1) puts(&quot;-1&quot;);    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2021牛客暑期多校第二场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>F - Girlfriend</title>
      <link href="/2021/07/20/Algorithm/F%20-%20Girlfriend/"/>
      <url>/2021/07/20/Algorithm/F%20-%20Girlfriend/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出四个空间点$A,B,C,D$和$k_{1},k_{2}$，求关于动点$P_{1},P_{2}$且满足$|AP_{1}| \geq k_{1}|BP_{1}|, |CP_{2}| \geq k_{2}|DP_{2}|$的两个点的轨迹方程$\Gamma_{P1},\Gamma_{P2}$，并求出它们的交体积。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先进行轨迹方程的推导。设$A(x_{1}, y_{1}, z_{1}), B(x_{2}, y_{2}, z_{2})$，由题目条件得$(x-x_{1})^2+(y-y_{1})^2+(z-z_{1})^2 \geq k^2((x-x_{2})^2+(y-y_{2})^2+(z-z_{2})^2)$</p><p>配方后，化简得<br>$(x-\frac{k^2 x_{2}-x_{1}}{k^2-1})^2 + (y-\frac{k^2 y_{2}-y_{1}}{k^2-1})^2 + (z-\frac{k^2 z_{2}-z_{1}}{k^2-1})^2 \leq (\frac{k^2 x_{2}-x_{1}}{k^2-1})^2-\frac{x_{2}^2k^2-x_{1}}{k^2-1} + (\frac{k^2 y_{2}-y_{1}}{k^2-1})^2-\frac{y_{2}^2k^2-y_{1}}{k^2-1} + (\frac{k^2 z_{2}-z_{1}}{k^2-1})^2-\frac{z_{2}^2k^2-z_{1}}{k^2-1}$</p><p>得到圆心$(\frac{k^2 x_{2}-x_{1}}{k^2-1},\frac{k^2 y_{2}-y_{1}}{k^2-1},\frac{k^2 z_{2}-z_{1}}{k^2-1})$，半径$\sqrt{(\frac{k^2 x_{2}-x_{1}}{k^2-1})^2-\frac{x_{2}^2k^2-x_{1}}{k^2-1} + (\frac{k^2 y_{2}-y_{1}}{k^2-1})^2-\frac{y_{2}^2k^2-y_{1}}{k^2-1} + (\frac{k^2 z_{2}-z_{1}}{k^2-1})^2-\frac{z_{2}^2k^2-z_{1}}{k^2-1}}$</p><p>然后算两个球的交体积。用微积分分别算出两个部分的体积，下面这个积分是绿色区域的体积</p><p>$\int_{0}^h\pi(R^2-(Rcos\alpha+x)^2)dx = \pi (Rh^2-\frac{h^3}{3})$</p><p>圆的相交体积大小的结论为，d为球心距</p><script type="math/tex; mode=display">cos\alpha = \frac{R^2+d^2-r^2}{2Rd}</script><script type="math/tex; mode=display">cos\beta = \frac{r^2+d^2-R^2}{2rd}</script><script type="math/tex; mode=display">V=\frac{\pi}{3}((3R-R(1-cos\alpha))R^2(1-cos\alpha)^2+(3r-r(1-cos\beta))r^2(1-cos\beta)^2)</script><p><img src="data:image/png;base64,/9j/4AAQSkZJRgABAQEAeAB4AAD/4QBmRXhpZgAATU0AKgAAAAgABgESAAMAAAABAAEAAAMBAAUAAAABAAAAVgMDAAEAAAABAAAAAFEQAAEAAAABAQAAAFERAAQAAAABAAASdFESAAQAAAABAAASdAAAAAAAAYagAACxj//bAEMAAgEBAgEBAgICAgICAgIDBQMDAwMDBgQEAwUHBgcHBwYHBwgJCwkICAoIBwcKDQoKCwwMDAwHCQ4PDQwOCwwMDP/bAEMBAgICAwMDBgMDBgwIBwgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDP/AABEIAgcDmgMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/AP38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooprShTQA6iq+o6rb6Pp095dzRWtnaxtNPPM4jjhRQSzMx4VQASSeAK+N/2oP+Dg79kf9lCz1D+2vi/oPiLU9OcRNpfhdjrN3NI1u06Knk5jwwAXeXEau6q7Lk4APtDOKaZFHevww/aI/wCD2HwnNJDpnwR+Bvi7xJqWpWxit7nxZfQ6ebe9ZtsSCzszctcocg4E8LEnaB/FXIH/AILO/wDBUr9pg/2l8O/2a/8AhGtO0v8A0S8h/wCENuz50x+bd/psgfhSBhOB35NAH9AG7mjNfgB/wgf/AAWw+Ia/8JDba0dDt9e/4mUWm/bfDlr/AGcs37wQeVMDLH5YbbskJZduCSRQP+CNH/BWb47n/hK/EH7V3/CG6xq/z3Ojf8LN1rT/ALEU/dqPI0u2ayTcqK37liDuy3zlhQB+/wDQWwK/AH/hwX/wVO/6PU/8y94u/wDkSkP/AARz/wCCtH7Pn/FXeG/2qf8AhONa0niDRf8AhZer6l9sEv7lz5GrWy2L7EkaT98wK7NyZkCAgH7/ABcCgOCa/AE2n/Baz4B/8VZfSnxra6XxJo2/w/qX2vzf3QPkW22Z9hcP8jDbs3HKhhVbV/8AgvR/wUq/ZJ0q6h+KH7M9vrEs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QAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAf/9k=" alt="image"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;typedef long double ldouble;#define eps 1e-9struct coodinate&#123;    ldouble x, y, z;&#125;cd[5];struct sphere&#123;    coodinate c;    ldouble r;&#125;sp[3];inline ldouble f(ldouble x2, ldouble x1, ldouble k) &#123;    return (x2 * k * k - x1) / (k * k - 1);&#125;inline ldouble f2(ldouble x2, ldouble x1, ldouble k) &#123;    return f(x2, x1, k) * f(x2, x1, k) - (k * k * x2 * x2 - x1 * x1) / (k * k - 1);&#125;ldouble pi = acosl(-1);ldouble dis(coodinate p, coodinate q) &#123;    ldouble ans = sqrt((p.x - q.x)*(p.x - q.x) + (p.y - q.y)*(p.y - q.y) + (p.z - q.z)*(p.z - q.z));    return ans;&#125;ldouble V(ldouble r) &#123;    return  (ldouble)4 / 3 * r * r * r * pi;//不加入强制转换结果会算错，详见下面的数据&#125;int main() &#123;    int T;    scanf(&quot;%d&quot;, &amp;T);    while (T--) &#123;        ldouble k1, k2, ans = 0;        for (int i = 1; i &lt;= 4; ++i)            scanf(&quot;%Lf%Lf%Lf&quot;, &amp;cd[i].x, &amp;cd[i].y, &amp;cd[i].z);        scanf(&quot;%Lf%Lf&quot;, &amp;k1, &amp;k2);        sp[1].c = coodinate&#123;f(cd[2].x, cd[1].x, k1), f(cd[2].y, cd[1].y, k1), f(cd[2].z, cd[1].z, k1)&#125;;        sp[1].r = sqrtl(f2(cd[2].x, cd[1].x, k1) + f2(cd[2].y, cd[1].y, k1) + f2(cd[2].z, cd[1].z, k1));        sp[2].c = coodinate&#123;f(cd[4].x, cd[3].x, k2), f(cd[4].y, cd[3].y, k2), f(cd[4].z, cd[3].z, k2)&#125;;        sp[2].r = sqrtl(f2(cd[4].x, cd[3].x, k2) + f2(cd[4].y, cd[3].y, k2) + f2(cd[4].z, cd[3].z, k2));        ldouble d = dis(sp[1].c, sp[2].c);        ldouble maxr = std::max(sp[1].r, sp[2].r), minr = std::min(sp[2].r, sp[1].r);        if (sp[1].r + sp[2].r &lt;= d) ans = 0;        else if (d + minr &lt;= maxr) &#123;            ans = V(minr);        &#125; else &#123;            ldouble cosa = (sp[1].r * sp[1].r + d * d - sp[2].r * sp[2].r) / (2 * sp[1].r * d);            ldouble cosb = (sp[2].r * sp[2].r + d * d - sp[1].r * sp[1].r) / (2 * sp[2].r * d);            ans = pi / 3 * (3 * sp[1].r - sp[1].r * (1 - cosa)) * sp[1].r * (1 - cosa) * sp[1].r * (1 - cosa) +                     pi / 3 * (3 * sp[2].r - sp[2].r * (1 - cosb)) * sp[2].r * (1 - cosb) * sp[2].r * (1 - cosb);        &#125;        printf(&quot;%Lf\n&quot;, ans);    &#125;    return 0;&#125;/*10 0 0600 0 0596 0 0602 0 02 2应输出 : 268.083但是不加入强制转换会输出 : 201.062*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2021牛客暑期多校第二场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-07-17 关于自己读书的有趣现象</title>
      <link href="/2021/07/17/Essay-2021-7-17/"/>
      <url>/2021/07/17/Essay-2021-7-17/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;作为学生，课本是一定要读的，暂且不算在文中谈的”读书”。</p><p>&emsp;&emsp;发现了自己很有趣的一个现象，平时自己极度反感别人教自己做事。可现实中，一想读什么书，就要先看看网上的评论，唯恐网上的评论教你的东西少，生怕自己读错书。这种心情是可以理解的，因为看书会消耗人的时间，但是，网上的评论，真的完全客观吗，质量高吗?是否存在幸存者偏差?</p><p>&emsp;&emsp;上大学已经两年了，转眼间就要上大三。随着手机网络的不断发展，我读书的时间已经被不知不觉的占据。视频客户端的推送，让人欲罢不能，贴吧知乎推送的帖子回答，总会有一条让我感兴趣。推送的内容不乏精品，包含各个领域，纷繁复杂。然而，我在看完这些高质量的视频，帖子，回答后，很少能记住，都放进了收藏夹里。快速查看，快速遗忘，是这个时代的特色，久而久之，人的专注力和记忆力都下降了。</p><p>&emsp;&emsp;现代社会，网络耗费了人大量的时间，人就会在不属于网络的时间中患得患失，生怕浪费了一点，因为剩下的时间不多了。</p><p>&emsp;&emsp;如果这本书你觉得适合你阅读，那就尝试着静下心来把它读完。总是关注别人的评论，你就会不停的纠结这本书能不能读，不停上网找评论去支持你想读或不想读的观点，在这种纠结中，你在互联网上消耗的时间会不自觉的变多，这就陷入了互联网浮躁思维的陷阱。</p><p>&emsp;&emsp;静下心来，摆脱外界对你的桎梏，你才能真正收获到阅读的知识和快乐。</p>]]></content>
      
      
      <categories>
          
          <category> 感想随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
