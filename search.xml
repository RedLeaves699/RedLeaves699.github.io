<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git的使用</title>
      <link href="/2026/01/20/Sharp%20Tools/git%E6%93%8D%E4%BD%9C/"/>
      <url>/2026/01/20/Sharp%20Tools/git%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="Git-快速上手"><a href="#Git-快速上手" class="headerlink" title="Git 快速上手"></a>Git 快速上手</h2><h3 id="Git-的作用与参考资料"><a href="#Git-的作用与参考资料" class="headerlink" title="Git 的作用与参考资料"></a>Git 的作用与参考资料</h3><p>Git是一个开源的分布式版本控制系统。<br>更多内容请参考：<br><a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-Git-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">起步-Git-是什么</a><br><a href="https://www.cnblogs.com/potatso/p/18644042">深入理解Git：从原理到实践的全面指南</a><br><a href="https://www.cnblogs.com/yingchi/p/18754048">关于HEAD</a><br><a href="https://www.zhihu.com/question/25491925/answer/2471516234">代码版本控制用SVN还是Git好？- 腾讯技术工程的回答 - 知乎</a><br><a href="https://www.bilibili.com/video/BV1HM411377j/">【GeekHour】一小时Git教程</a><br><a href="https://learngitbranching.js.org/">Git 模拟器</a></p><h3 id="基本概念-PART1：工作区域与仓库存储"><a href="#基本概念-PART1：工作区域与仓库存储" class="headerlink" title="基本概念 PART1：工作区域与仓库存储"></a>基本概念 PART1：工作区域与仓库存储</h3><ol><li><p>Git 如何追踪文件的变化？<br> 追踪新旧文件变化需要把新旧文件放在至少两个区域做对比。如果需要追踪新文件与任意历史时期文件的变动，那还需要一个存储任意时期历史文件的区域。遵循这个逻辑，Git 设计了三个区域：工作区，暂存区（stage）和仓库区。</p><ul><li><strong>工作区</strong>就是我们编辑文件的区域，是电脑中实际的目录。这里的文件会被用户随时修改，永远是最新的。</li><li><strong>暂存区</strong>（又称索引，index）是由 git 管理的，存放旧文件的区域。git 在对比暂存区和工作区的内容后，告知用户文件有那些变动。</li><li><strong>仓库区</strong>是由 git 管理的，存放历史文件的区域。这个仓库使得 git 可以追踪新文件与任意历史时期文件（以下均称作历史版本），以及任意两个历史版本之间的变动。分为本地仓库和远程仓库。</li></ul><p> 处在不同区域的同名文件，可以用以下几种状态描述：</p><ul><li><strong>未跟踪</strong>状态。该文件出现在工作区，但未出现在暂存区。Git 无法跟踪对比新旧文件的差异，因为用作对比标准的旧文件不存在。</li><li><strong>未修改</strong>状态。该文件出现在工作区和暂存区，且工作区与暂存区无差异。</li><li><strong>已修改</strong>状态。该文件出现在工作区和暂存区，且工作区内容相对于暂存区内容有更新。注意，在工作区删除暂存区存在的同名文件也是一种修改。</li><li><strong>已暂存</strong>（staged）状态。工作区最新的修改已经保存到暂存区的状态。</li></ul></li><li><p>Git 仓库区的作用<br> Git 仓库区分为本地仓库和远程仓库。它们的功能是相同的，存储文件的全部历史版本。使用 Git，我们可以轻易把仓库中的文件恢复到工作区或暂存区。</p></li><li><p>“三区域四状态”之间通过 Git 操作的转化关系图。<br> 上述的“三区域四状态”可以通过常用的 Git 命令联系起来。<br> <img src="/assets/sharptools/git-1.svg" alt="“三区域四状态”的转换"></p><blockquote><p>补充说明：图中工作区内的一些未跟踪文件在使用<code>git add</code>命令加入暂存区后，将同时拥有两个状态：未修改和已暂存。其中已暂存的状态在<code>git commit</code>之后会转化为未修改。此时这些文件就只有未修改一种状态了。</p></blockquote></li><li><p>Git 相关操作命令<br> <code>git init</code>：将当前目录，以及所有子目录下的文件交由git管理。目录下会生成 .git 目录存储管理所需的必要信息。<br> <code>git log</code>：查看历史提交记录。每次提交会将当前的暂存区文件存储到本地仓库区，并形成一条提交记录。<br> <code>git add .</code>：将目录下所有文件加入暂存区。<br> <code>git rm</code>：将指定文件移出<strong>工作区</strong>和<strong>暂存区</strong>。<code>git rm --cached</code>将指定文件移出<strong>暂存区</strong>。<br> <code>git commit</code>：将暂存区所有文件提交到本地仓库区。<br> <code>git reset</code>：将工作区恢复到某个状态。有三个选项，对应不同的恢复程度（即是否保留工作区或暂存区的修改）。不指定参数，默认使用<code>--mixed</code></p><table><thead><tr><th align="center">选项</th><th align="center">保留当前工作区修改</th><th align="center">保留当前缓存区修改</th><th align="center">使用场景</th></tr></thead><tbody><tr><td align="center">–soft</td><td align="center">✅</td><td align="center">✅</td><td align="center">合并多次提交</td></tr><tr><td align="center">–hard</td><td align="center">❎</td><td align="center">❎</td><td align="center">完全恢复到某个历史状态</td></tr><tr><td align="center">–mixed</td><td align="center">✅</td><td align="center">❎</td><td align="center">合并多次提交</td></tr></tbody></table><blockquote><p>PS：如何使用 reset 合并多次提交的问题将在分支与历史版本管理主题解释。</p></blockquote><p> <code>git diff</code>：对比工作区和暂存区。不仅如此，可以使用<code>--cached/--staged</code>选项对比暂存区和仓库最新一次提交，在<code>diff</code>后加<code>HEAD</code>参数对比工作区和仓库（当前分支下）最新一次提交，在<code>diff</code>后加仓库中两次提交的ID对比两次提交。<br> <code>git push</code>：向远程仓库推送本地仓库提交记录<br> <code>git pull/git clone</code>：从远程仓库获取提交记录</p></li></ol><h3 id="基本概念-PART2：仓库分支与历史版本管理"><a href="#基本概念-PART2：仓库分支与历史版本管理" class="headerlink" title="基本概念 PART2：仓库分支与历史版本管理"></a>基本概念 PART2：仓库分支与历史版本管理</h3><ol><li><p>分支：</p><ul><li>每个分支代表一条<strong>链表</strong>，这条链表由一系列提交记录构成，在一条分支上，每提交一次，分支就在其头部插入一条提交记录。</li><li>每个分支都维护一个指针，这个指针表示链表的头部，指向一条提交记录（在下面的相关图片中，分支名字所在的位置就是这个指针所在的位置）。我们把这个指针指向的位置称为分支的“<strong>最新提交</strong>”。</li><li>master分支（main 分支）：git 的默认分支。</li></ul></li><li><p>HEAD 指针<br> 注意 HEAD 指向的是<strong>当前分支</strong>（这使得它可以操作分支内的数据，如链表头指针），而不是直接指向提交记录。后面出现的两张示例图体现了这一点。在操作提交记录时，使用<code>HEAD^</code>或<code>HEAD~</code>表示前一个版本，<code>HEAD^5</code>或<code>HEAD~5</code>表示前五个版本。HEAD 指针在特殊情况下也可以直接指向提交记录，此时被称作分离头指针状态。</p></li><li><p>分支操作</p><ul><li><code>git branch dev</code>：在当前提交记录创建 dev 分支。</li><li><code>git switch dev</code>：切换到名为 dev 的分支（让 HEAD 指向 dev）。这是 git 2.23+引入的新功能，原有的<code>git checkout dev</code>不推荐使用了，它的语义没有这个命令明确。</li><li><code>git checkout -- file</code>：从暂存区恢复<code>file</code>文件的状态。即从暂存区中取同名文件覆盖当前工作区的同名文件。<code>--</code>是一个分隔符，用来区分分支名和文件路径，以防止与把 file 认作分支产生歧义。</li><li><code>git checkout commit-hash -- file</code>：将<code>file</code>恢复到 commit-hash 这次提交时的状态。</li><li><code>git restore</code>：从暂存区恢复工作区的某个文件。这是 git 2.23+引入的新功能，用于替代<code>git checkout</code>命令的恢复文件功能，它的语义更加明确，用法与<code>checkout</code>略有不同。</li><li><code>git checkout dev</code>：切换到名为 dev 的分支。</li><li><code>git checkout commit-hash</code>：进入不在任何分支操作的分离头指针状态（detached head），若要保留更改，必须另开一个分支，或者将分离头指针状态的提交记录与某个分支合并。后一种做法的过程如下：<br> <img src="/assets/sharptools/git%20detached%20head.svg" alt="将分离头指针状态的提交记录与某个分支合并"><br> 如图所示，使用<code>git checkout C2</code>命令让 HEAD 直接指向 C2 这次提交，然后基于 C2 修改内容后，向本地仓库提交本次修改，提交记录为 C4（图中左侧）。C4 这个提交记录目前不属于任何分支。随后，将分支切换为 master，最后使用<code>git merge C4</code>合并C4与master分支的提交记录C2，最终结果如图中右侧所示。</li><li><code>git merge dev</code>：合并两个分支。即合并 dev 分支指向的提交记录与当前分支 master 的提交记录。合并时可能需要手动处理一些冲突。    </li><li><code>git rebase dev</code>：假设当前 HEAD 指向 master 分支，这个操作将以 dev 分支作为基础，将 master 分支最新提交与 dev 分支最新提交的最近公共祖先（LCA）节点（即图中无标签的点）以上，master 及以下的部分移至 dev 分支最新提交的上方。<br> <img src="/assets/sharptools/git%20rebase.svg" alt="git rebase 图示"></li></ul></li><li><p>如何使用 reset 合并多次提交？<br> 假如有六个提交都修改了某个文件的其中一行，第七次修改还没有提交。此时使用 soft 或 mixed 选项回到第一次提交时的状态，回到这个状态后，第七次修改后未提交的文件仍会保留在工作区。如果我们以第一次提交为基础再提交一次，由于提交的文件包含了第二至第七次的全部修改，第二次到第七次提交的全部修改就此合并。<br> 下图是全过程（图中的<code>Helloxxx</code>表示工作区文件的内容）：<br> <img src="/assets/sharptools/git%20reset%20soft.svg" alt="reset 合并多次提交"><br> 此时，提交记录 C2-C6 将<strong>不再属于任何分支</strong>，而新生成的提交记录 C7 被纳入了 master 分支中，这样就实现了在 master 分支合并提交。而 C2-C6 自此可以手动删除，或保留以备不时之需。</p></li></ol><h3 id="团队协作任务中的版本管理"><a href="#团队协作任务中的版本管理" class="headerlink" title="团队协作任务中的版本管理"></a>团队协作任务中的版本管理</h3><ol><li>工作流模型<br> 复杂，用于大型企业，大量中等水平开发者。<br> <a href="https://zhuanlan.zhihu.com/p/707366399">Git-GitFlow工作流</a></li><li>GitHub模型<br> 主要用于开源项目，适合少数高水平开发者。<br> 一个主分支与一个 dev 分支，贡献者 fork 代码，创建 dev 分支，并在修改后发起一个 pull request，由项目管理者审计代码，合并分支。</li></ol><h2 id="Git-使用场景参考与使用方法速查"><a href="#Git-使用场景参考与使用方法速查" class="headerlink" title="Git 使用场景参考与使用方法速查"></a>Git 使用场景参考与使用方法速查</h2><h3 id="在U盘上创建代码仓库"><a href="#在U盘上创建代码仓库" class="headerlink" title="在U盘上创建代码仓库"></a>在U盘上创建代码仓库</h3><ol><li>在U盘上创建空仓库my_repo。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /media/&lt;username&gt;/&lt;usb_name&gt;/Git-USB/my_repo</span><br><span class="line">git init --bare /media/&lt;username&gt;/&lt;usb_name&gt;/Git-USB/my_repo</span><br></pre></td></tr></table></figure></li><li>在本地git工程目录下执行，创建远程仓库链接 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;远程分支名&gt; /media/&lt;username&gt;/&lt;usb_name&gt;/Git-USB/my_repo</span><br></pre></td></tr></table></figure></li><li>用git push&#x2F;pull 命令进行版本管理 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程分支名&gt; main</span><br></pre></td></tr></table></figure></li></ol><p>使用–bare选项创建的repository被称作bare repository，它不会包含working目录（只包含.git目录下的内容），所以不适合在上面改code。bare repository主要的作用就是被push和pull。根据GitFaq的说法：</p><blockquote><p>A quick rule of thumb is to never push into a repository that has a work tree attached to it, until you know what you are doing.</p></blockquote><h3 id="查看状态常用操作"><a href="#查看状态常用操作" class="headerlink" title="查看状态常用操作"></a>查看状态常用操作</h3><ol><li><p><code>git status</code>：这是一个非常常用的命令，用于查看当前的工作树状态以及与版本控制系统之间的差异。它会显示文件的修改状态、是否有未提交的更改、是否有未跟踪的文件等信息。</p></li><li><p><code>git branch</code>：通过运行该命令，可以查看当前分支的列表并标记当前所在的分支。当前分支前面带有星号（*）的就是当前所在的分支。</p></li><li><p><code>git log</code>：该命令可用于查看提交日志。运行<code>git log</code>会显示当前分支的所有提交记录，包括提交者、提交日期和提交的摘要信息。</p></li><li><p><code>git reflog</code>：如果你想查看操作历史，包括分支切换、提交、重置等操作的日志，可以使用该命令。它会显示所有引用的更改历史记录。</p></li><li><p><code>git show</code>：这个命令可以显示提交的具体内容以及所做的更改。可以使用<code>git show HEAD</code>来查看最后一次提交的内容，或者使用<code>git show commit_id</code>来查看特定提交的内容。</p></li></ol><h3 id="修改最近一次git-commit的message"><a href="#修改最近一次git-commit的message" class="headerlink" title="修改最近一次git commit的message"></a>修改最近一次git commit的message</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend </span><br></pre></td></tr></table></figure><h2 id="gitignore-文件"><a href="#gitignore-文件" class="headerlink" title=".gitignore 文件"></a>.gitignore 文件</h2><h3 id="为什么需要-gitignore文件"><a href="#为什么需要-gitignore文件" class="headerlink" title="为什么需要.gitignore文件"></a>为什么需要.gitignore文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;0.1&quot;</span></span><br></pre></td></tr></table></figure><p>上面这两段语句十分简洁，大大方便了代码的提交。</p><p>但有时，一些不必要的文件也会被提交上去。比如可执行文件，或者用户本地配置文件等。人类是懒惰的，我绝不会手动对逐个文件进行添加或删除。这该怎么办？</p><p>这时，我们就需要.gitignore，它会让git我们忽略不必要的文件。</p><h3 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h3><p>举例</p><p>.gitignore支持通配符，支持忽略目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Mobile Tools for Java (J2ME)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.ear</span><br><span class="line"></span><br><span class="line"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span><br><span class="line">hs_err_pid*</span><br><span class="line"></span><br><span class="line">!/foo</span><br><span class="line">/foo/*</span><br><span class="line">!/foo/bar</span><br></pre></td></tr></table></figure><h3 id="详细的使用文档-英文"><a href="#详细的使用文档-英文" class="headerlink" title="详细的使用文档(英文)"></a>详细的使用文档(英文)</h3><p><a href="https://git-scm.com/docs/gitignore">Git - gitignore Documentation (git-scm.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 VSCode/VSCodium 上使用 clangd 插件替换微软 cpptools，辅助 C/C++ 开发</title>
      <link href="/2026/01/10/Sharp%20Tools/vscode%20clangd/"/>
      <url>/2026/01/10/Sharp%20Tools/vscode%20clangd/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么使用-clangd-套件"><a href="#为什么使用-clangd-套件" class="headerlink" title="为什么使用 clangd 套件"></a>为什么使用 clangd 套件</h2><p>最直接原因：微软式开源使得我无法在 VSCodium 上使用微软的 C&#x2F;C++ 套件（以下简称 cpptools），可以在<a href="https://github.com/VSCodium/vscodium/issues/2300">这个链接</a>查看相关讨论。<br>间接原因：clangd 的效率更高，代码提示效果更好，比 cpptools 好用。来自知乎，Github，以及多个个人博客的多位博主用实际使用体验验证了上述结论。</p><h2 id="使用-clangd-套件的方法"><a href="#使用-clangd-套件的方法" class="headerlink" title="使用 clangd 套件的方法"></a>使用 clangd 套件的方法</h2><p>clangd套件包含 clangd Language Server 与 VSCode 插件两部分。在 VSCode 上使用 clangd 的方法如下：</p><ol><li>在 VSCode 安装 clangd 插件，关闭 cpptools 的 Intelli Sense Engine 以避免代码高亮冲突。</li><li>在当前操作系统安装 clangd 并设置环境变量。（Linux 直接运行<code>sudo apt install clangd</code>即可）<br>完成上述两项配置之后，即可正常使用 clangd 插件编写单文件程序。</li></ol><p>如果要在较为复杂的工程中正常使用 clangd，则需要更多配置，步骤如下：</p><ol><li>在 .VSCode&#x2F;settings.json 文件中指定 compile_commands.json 文件存放的目录。clangd 依据 compile_commands.json 文件获取工程结构，使用<code>--compile-commands-dir</code>选项指定该文件存放的目录。</li><li>指定工程所需的编译器。clangd 默认使用 clang 作为语法检查的编译器，如果不想使用 clang，可以在 .VSCode 的 settings.json 中添加<code>--query-driver</code>选项。</li><li>生成 compile_commands.json 文件。这个文件一般由 cmake 之类的工程管理软件生成。如果使用 cmake 需要在 CMakeLists.txt 中设置<code>set(CMAKE_EXPORT_COMPILE_COMMANDS ON)</code>，或者使用<code>cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON</code>即可。如果在 VSCode 使用 platformio 做嵌入式开发，使用<code>pio run -t compiledb</code> 即可在当前工作目录下生成该文件。</li><li>每次增删（注意不包括改）代码目录中的文件，都需要重新生成 compile_commands.json 文件供 clangd 使用。</li><li>重新生成 compile_commands.json 文件后，使用 <code>Ctrl+Shift+P</code> 唤起命令面板，执行其中的<code>clangd: Restart language server</code>，clangd会重新读取文件，并更新工程结构。</li></ol><h2 id="配置文件示例"><a href="#配置文件示例" class="headerlink" title="配置文件示例"></a>配置文件示例</h2><p>.&#x2F;VSCode&#x2F;settings.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;files.associations&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;clangd.arguments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;--query-driver=/usr/bin/c*&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;--compile-commands-dir=$&#123;workspaceFolder&#125;/build&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="替换-cpptools-的其他套件"><a href="#替换-cpptools-的其他套件" class="headerlink" title="替换 cpptools 的其他套件"></a>替换 cpptools 的其他套件</h2><p>Clang-Format：由 xaver 发布的自动格式化代码插件，cpptools 的格式化功能就是内嵌这个插件实现的。<br>C&#x2F;C++ debug: 由 kylinIdeTeam 发布的 C&#x2F;C++ 代码调试插件，和 cpptools debug 功能的使用方法相同。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://opensouce-club.top/tech-article/tech-note/platform-io-clangd.html">PlatformIO 配置使用 Clangd，替换 C&#x2F;C++ Extension</a><br><a href="https://github.com/VSCodium/vscodium/issues/2300">Microsoft C&#x2F;C++ Extension appears to no longer support unofficial forks of VS Code</a><br><a href="https://github.com/clangd/clangd/issues/537#issuecomment-1806938810">–query-driver not having any effect</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暂时不能解决的问题</title>
      <link href="/2025/12/18/%E6%84%9F%E6%83%B3%E9%9A%8F%E7%AC%94/%E6%82%AC%E8%80%8C%E6%9C%AA%E5%86%B3%E4%B9%8B%E9%97%AE/"/>
      <url>/2025/12/18/%E6%84%9F%E6%83%B3%E9%9A%8F%E7%AC%94/%E6%82%AC%E8%80%8C%E6%9C%AA%E5%86%B3%E4%B9%8B%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-猜测排列"><a href="#1-猜测排列" class="headerlink" title="1.猜测排列"></a>1.猜测排列</h2><p>有一个长度为n的排列，给定一些猜测和这些猜测中位置正确的数字的个数，问应该如何猜测，至少经过多少次猜测能够确定这个排列？</p><p>猜想$O(nlog(n))$。和信息论可能有关系。</p><h2 id="2-编程珠玑第八章习题4"><a href="#2-编程珠玑第八章习题4" class="headerlink" title="2.编程珠玑第八章习题4"></a>2.编程珠玑第八章习题4</h2><p>If the elements in the input array are random real numbers chosen uniformly from [ -1, 1 ], what is the expected value of the maximum subvector?</p><p>该问题属于随机过程与极值理论交叉领域，目前无通用闭式解。<br>从n&#x3D;1到n&#x3D;2，期望值从$0$增至$\frac{5}{12}$​。可以发现随数组长度增加，最大子数组和期望值增长。</p>]]></content>
      
      
      <categories>
          
          <category> 感想随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提问 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker简介及基础使用</title>
      <link href="/2025/11/01/Sharp%20Tools/Docker%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/11/01/Sharp%20Tools/Docker%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-学习-docker-的动机"><a href="#1-学习-docker-的动机" class="headerlink" title="1. 学习 docker 的动机"></a>1. 学习 docker 的动机</h2><p>从事计算机相关行业，久闻 docker 大名，总想学习了解一下。然而，我每次上网搜索，都找不到什么平易近人的教程，要么默认你什么都掌握，要么就是讲一些概念上的东西，不贴近实际使用场景。因为工作中不常用，所以也就失去了学习的兴趣。</p><p>尽管如此，上周在软件部署时出现的问题还是让我的学习热情死灰复燃了。当时的我看到链接器那令人畏惧的报错后，第一时间的想法不是勇敢面对，而是掉头就跑——既然开发主机升级系统之前编译软件都没有问题，那就用一个和目标机器配置相同的虚拟机编译程序好了。正当我准备打开 qemu 安装系统时，docker这个词在我的脑海中浮现了。在我的印象中，它好像也有类似虚拟机的作用，而且比虚拟机的性能更好，为什么不尝试一下呢？正好趁此机会彻底把它弄明白。</p><p>由于本人使用场景有限，频率不高，所以本文只是简要介绍常用操作，不会过于深入。</p><h2 id="2-Docker-是什么"><a href="#2-Docker-是什么" class="headerlink" title="2. Docker 是什么"></a>2. Docker 是什么</h2><p>在官方资料中，这个问题已有解释，但我想在这里表达我自己的观点：docker 是一款模拟操作系统的软件。它不模拟硬件，而是如同一般应用程序一样直接使用主机本身的硬件。它利用了 Linux 内核的隔离机制（Cgroups 和 Namespaces），这使得在用户看来，每个容器内部都好像一个独立的操作系统，与运行虚拟机的效果一样。</p><p>所以，如果只是想实现日常应用，那么按照虚拟机的概念学习，并了解docker与虚拟机的区别和联系是一种极好的方式。</p><p>补充两个机制各自实现的功能：<br>Cgroups：限制和隔离进程的资源使用，为每个容器设定 cpu，内存，网络带宽的使用上限。<br>Namespaces：容器只能看到内部进程 ID，网络，和文件。</p><h2 id="3-如何安装-docker"><a href="#3-如何安装-docker" class="headerlink" title="3. 如何安装 docker"></a>3. 如何安装 docker</h2><p>在官网上有<a href="https://docs.docker.com/engine/install/">安装教程</a>，Linux 系统建议直接增加软件源，方便以后自动更新。另外，如果软件源的<a href="https://download.docker.com/">官网</a>国内访问不上，可以使用镜像网站代替（阿里云或中科大或清华）。这里给出<a href="https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/">清华源的使用方法</a>。</p><h2 id="4-镜像和镜像的管理"><a href="#4-镜像和镜像的管理" class="headerlink" title="4. 镜像和镜像的管理"></a>4. 镜像和镜像的管理</h2><p>这里镜像的概念和虚拟机在概念是可以认为一致，可以将其理解为一个安装了操作系统和必要环境的虚拟机磁盘，但实际上，它只是一个文件系统而已，没有常规镜像中用于引导操作系统启动的区域。</p><h3 id="4-1-配置镜像下载站"><a href="#4-1-配置镜像下载站" class="headerlink" title="4.1 配置镜像下载站"></a>4.1 配置镜像下载站</h3><p>docker 的镜像可以从<a href="https://hub.docker.io/">docker 官网镜像仓库</a>直接下载。但因国内访问不上，使用多有不便。所以需要设置从国内镜像站下载。在 Linux 系统中，设置 docker 下载镜像时使用网站的配置文件在<code>/etc/docker/deamon.json</code>中，如果 docker 没有生成这个文件，那就需要自己创建一个。在其中填写内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://registry.docker-cn.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这样 docker 下载镜像之前就会优先访问这些网址而不是官网。</p><h3 id="4-2-下载镜像"><a href="#4-2-下载镜像" class="headerlink" title="4.2 下载镜像"></a>4.2 下载镜像</h3><p>下载镜像的命令如下，注意，因为 docker 需要使用一些系统的 socket 文件，所以非 root 用户每次使用 docker 命令都要加 sudo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker pull --platform=amd64 docker.io/library debian:bookworm</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">–platform&#x3D;amd64</td><td align="center">决定下载在哪种 cpu 架构运行的镜像。可以不填，选择让 docker 根据当前系统 cpu 架构决定。</td></tr><tr><td align="center">docker.io</td><td align="center">仓库地址，省略默认为官方仓库。</td></tr><tr><td align="center">library</td><td align="center">命名空间，可以理解为仓库的作者名，省略默认为 docker 官方。</td></tr><tr><td align="center">debian</td><td align="center">镜像库的名字，这里代表 debian 操作系统。</td></tr><tr><td align="center">bookworm</td><td align="center">标签，可以理解为版本号，省略默认为 latest，即最新版。</td></tr></tbody></table><p>上述命令中，<code>docker.io/library debian</code>这一整体被称为一个镜像库（respoitory）,每个库都存放着一个镜像的多个版本。</p><p>如果仅需官方的镜像，使用下面的命令下载即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker pull debian:bookworm</span><br></pre></td></tr></table></figure><h3 id="4-3-管理镜像"><a href="#4-3-管理镜像" class="headerlink" title="4.3 管理镜像"></a>4.3 管理镜像</h3><p>列出当前拥有的所有镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker images</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY     TAG        IMAGE ID       CREATED        SIZE</span><br><span class="line">debian         bookworm   d89cafb62862   13 days ago    117MB</span><br><span class="line">hello-world    latest     1b44b5a3e06a   2 months ago   10.1kB</span><br></pre></td></tr></table></figure><p>删除某个镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker <span class="built_in">rm</span> 镜像名或镜像ID</span><br></pre></td></tr></table></figure><h2 id="5-容器的运维与管理"><a href="#5-容器的运维与管理" class="headerlink" title="5. 容器的运维与管理"></a>5. 容器的运维与管理</h2><p>单独的镜像只是一些二进制文件，能让镜像运行起来才是关键。在 docker 中，能够搭载镜像的环境被称为容器。容器就像一台可以开关机的虚拟机。</p><h3 id="5-1-容器的创建和运行"><a href="#5-1-容器的创建和运行" class="headerlink" title="5.1 容器的创建和运行"></a>5.1 容器的创建和运行</h3><p>使用镜像创建一个容器<strong>并立即运行</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run 镜像名或镜像ID</span><br></pre></td></tr></table></figure><p>如果只是想创建而不启动，使用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker create 镜像名或镜像ID</span><br></pre></td></tr></table></figure><p>run 和 create 这两个命令有很多的参数可以设置：</p><table><thead><tr><th align="center">参数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-d</td><td align="center">使用镜像创建一个容器，但在后台分离运行（注意这里的 d 不是 deamon，而是 detached）</td></tr><tr><td align="center">-p 宿主机端口:容器内端口</td><td align="center">端口映射，将宿主机某个端口的网络访问请求转发到容器内某个端口进行处理</td></tr><tr><td align="center">-v 宿主机目录:容器内目录</td><td align="center">将宿主机目录映射到容器目录，又称挂载卷</td></tr></tbody></table><p>这里要打断一下讲一下挂载方式。docker 挂载方式分为两种：</p><ol><li>绑定挂载：直接映射宿主机目录到容器上。</li><li>命名卷挂载：docker 在宿主机创建一个存储空间，然后用这个空间的名字映射容器目录。<strong>命名卷第一次使用时，docker 会把被映射的容器目录内容同步到命名卷中以进行命名卷初始化</strong>。<br>使用命名卷的方式如下：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建命名卷</span></span><br><span class="line"><span class="built_in">sudo</span> docker volume create 命名卷名称</span><br><span class="line"><span class="comment"># 映射命名卷到容器 /usr/share 目录</span></span><br><span class="line"><span class="built_in">sudo</span> docker run -d -p 80:80 nginx_html:/usr/share debian:bookworm</span><br><span class="line"><span class="comment"># 查看命名卷的真实位置</span></span><br><span class="line"><span class="built_in">sudo</span> docker volume inspect 命名卷名称</span><br><span class="line"><span class="comment"># 运行后查看 MountPoint 即可</span></span><br></pre></td></tr></table></figure><p>管理命名卷的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有创建过的卷</span></span><br><span class="line"><span class="built_in">sudo</span> docker volume list</span><br><span class="line"><span class="comment"># 删除名字为 nginx 的卷</span></span><br><span class="line"><span class="built_in">sudo</span> docker volume <span class="built_in">rm</span> nginx</span><br><span class="line"><span class="comment"># 删除没有在使用的卷</span></span><br><span class="line"><span class="built_in">sudo</span> docker volume prune -a</span><br></pre></td></tr></table></figure><p>下面继续说明<code>docker run</code>参数</p><table><thead><tr><th align="center">参数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-e LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;lib</td><td align="center">在运行时添加环境变量</td></tr><tr><td align="center">–name my_container</td><td align="center">取一个与容器ID等价的别名</td></tr><tr><td align="center">-it</td><td align="center">让终端与容器进行交互</td></tr><tr><td align="center">–rm</td><td align="center">在容器停止后立即删除</td></tr><tr><td align="center">–restart 选项</td><td align="center">设置自动重启，选项有两个，always表示只要容器停止运行就强制重启，unless-stopped表示除了手动停止容器的情况，只要停止运行就重启</td></tr></tbody></table><h3 id="5-2-容器的管理"><a href="#5-2-容器的管理" class="headerlink" title="5.2 容器的管理"></a>5.2 容器的管理</h3><p>运行时管理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始容器，停止容器</span></span><br><span class="line"><span class="built_in">sudo</span> docker start 容器名称或ID</span><br><span class="line"><span class="built_in">sudo</span> docker stop 容器名称或ID</span><br></pre></td></tr></table></figure><p>使用这两条命令启动或停止容器时，之前创建和启动容器时配置的参数会保留，如果忘记了参数，可以使用下面的的命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker inspect 容器名称或ID</span><br></pre></td></tr></table></figure><p>使用下面的命令查看容器状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看运行中容器，查看所有容器</span></span><br><span class="line"><span class="built_in">sudo</span> docker ps</span><br><span class="line"><span class="built_in">sudo</span> docker ps -a</span><br><span class="line"><span class="comment"># 滚动查看容器运行日志，加入 -f 参数可以滚动查看</span></span><br><span class="line"><span class="built_in">sudo</span> docker logs 容器名称或ID</span><br></pre></td></tr></table></figure><p>使用下面的命令可以在容器中执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在容器中执行 ps -ef 命令</span></span><br><span class="line"><span class="built_in">sudo</span> docker <span class="built_in">exec</span> 容器名称或ID ps -ef</span><br><span class="line"><span class="comment"># 获取分离状态运行容器的命令行终端</span></span><br><span class="line"><span class="built_in">sudo</span> docker <span class="built_in">exec</span> -it 容器名称或ID /bin/sh</span><br><span class="line"><span class="comment"># 在容器中执行复杂的 bash 命令</span></span><br><span class="line"><span class="built_in">sudo</span> docker <span class="built_in">exec</span> 容器名称或ID /bin/bash -c <span class="string">&quot;cd /home/src/build &amp;&amp; cmake .. &amp;&amp; make&quot;</span></span><br></pre></td></tr></table></figure><p>使用下面的m命令删除容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker <span class="built_in">rm</span> 容器名称或ID</span><br></pre></td></tr></table></figure><p>下面是一个使用示例：<br>使用 docker 编译程序，其中 debian12_env 是搭载编译环境的镜像，由于使用 cmake，为了方便，将本机源代码目录映射到容器中与之相同的目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker create --name debian12 -dit -v /usr/share/project:/usr/share/project debian12_env:bookworm</span><br><span class="line"><span class="built_in">sudo</span> docker start debian12_server</span><br><span class="line"><span class="built_in">sudo</span> docker <span class="built_in">exec</span> debian12 /bin/bash -c <span class="string">&quot;cd /usr/share/project/build &amp;&amp; cmake .. &amp;&amp; make&quot;</span></span><br></pre></td></tr></table></figure><h2 id="6-站在前人的肩膀上——镜像的制作与-DockerFile"><a href="#6-站在前人的肩膀上——镜像的制作与-DockerFile" class="headerlink" title="6. 站在前人的肩膀上——镜像的制作与 DockerFile"></a>6. 站在前人的肩膀上——镜像的制作与 DockerFile</h2><h3 id="6-1-制作镜像"><a href="#6-1-制作镜像" class="headerlink" title="6.1 制作镜像"></a>6.1 制作镜像</h3><p>DockerFile 文件用来描述一个镜像的产生过程，通过它，我们可以修改他人的镜像，自定义自己的镜像，设置镜像在启动时的行为。</p><p>下面给出一个示例，就是上一节提到的 debian12_env。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择一个基础镜像，如果电脑上没有，docker 会自动下载</span></span><br><span class="line"><span class="keyword">FROM</span> debian:bookworm</span><br><span class="line"><span class="comment"># 构建镜像时，切换到镜像的某个目录。在镜像运行时，如果使用终端，会发现当前工作目录也是这个目录。</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root</span></span><br><span class="line"><span class="comment"># COPY 将文件从当前主机复制到镜像中。第一个参数是当前主机的目录，第二个参数是镜像内的目录。</span></span><br><span class="line"><span class="comment"># 举例来说，如果需要更换镜像内部 apt 的镜像源，就需要将本机编辑好的 source.list 文件拷入镜像。</span></span><br><span class="line"><span class="comment"># 即使用 COPY /etc/apt/source.list /etc/apt/source.list。</span></span><br><span class="line"><span class="comment"># 这里的 copy 命令是将主机当前工作目录下的全部文件复制到镜像当前的工作目录 /root 下</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="comment"># 运行构建镜像所需的命令，这里是安装必要的编译环境。</span></span><br><span class="line"><span class="comment"># 注意，每次使用 RUN 命令都会在镜像上新建一层，所以，最好一次 RUN 命令执行全部构建。</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; apt install autoconf automake autotools-dev curl python3 python3-pip \</span></span><br><span class="line"><span class="language-bash">libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool \</span></span><br><span class="line"><span class="language-bash">patchutils bc zlib1g-dev libexpat-dev ninja-build git cmake libglib2.0-dev libslirp-dev \</span></span><br><span class="line"><span class="language-bash">libwxgtk3.2-dev libgl1-mesa-dev freeglut3-dev libsdl2-dev libopencv-dev -y \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; <span class="built_in">cp</span> /usr/lib/x86_64-linux-gnu/wx/include/gtk3-unicode-3.2/wx/setup.h /usr/include/wx-3.2/wx/</span></span><br><span class="line"><span class="comment"># 一个声明，提示要开放 8000 端口，不写没有任何影响，运行时仍然以 -p 参数为准</span></span><br><span class="line"><span class="comment"># 虽然编译程序并不需要开放端口，但为了更全面些，还是加上了这部分</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8000</span></span><br><span class="line"><span class="comment"># 设置镜像在运行后执行的第一条命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>使用下面的命令运行 DockerFile 脚本构建镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker build -t debian12_env:bookworm .</span><br></pre></td></tr></table></figure><p>最后的<code>.</code>表示构建时主机的工作目录为当前工作目录。命令会自动搜寻当前工作目录下的名为 DockerFile 的文件。如果不想用 DockerFile 这个名字，可以使用<code>-f 文件位置</code>指定用于构建镜像的文件。</p><h3 id="6-2-推送镜像"><a href="#6-2-推送镜像" class="headerlink" title="6.2 推送镜像"></a>6.2 推送镜像</h3><p>用于无法访问 docker 官网，故简要带过</p><ol><li>注册 dockerhub 账号。</li><li>docker login</li><li>使用下面命令构建 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker build -t 用户名/镜像名:标签</span><br></pre></td></tr></table></figure></li><li>推送 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 用户名/镜像名</span><br></pre></td></tr></table></figure></li></ol><h2 id="Docker-的网络配置"><a href="#Docker-的网络配置" class="headerlink" title="Docker 的网络配置"></a>Docker 的网络配置</h2><p>Docker 网络有多种模式。通过不同的机制实现容器与容器之间，容器与宿主机之间的网络通信。<br>因目前未深入使用，暂且不做详细说明。简要介绍详见参考资料<a href="%5B40%E5%88%86%E9%92%9F%E7%9A%84Docker%E5%AE%9E%E6%88%98%E6%94%BB%E7%95%A5%EF%BC%8C%E4%B8%80%E6%9C%9F%E8%A7%86%E9%A2%91%E7%B2%BE%E9%80%9ADocker%5D(https://www.bilibili.com/video/BV1THKyzBER6)">^1</a>。</p><h2 id="Docker-容器编排技术"><a href="#Docker-容器编排技术" class="headerlink" title="Docker 容器编排技术"></a>Docker 容器编排技术</h2><p>有些容器需要按照顺序启动，一旦这种启动顺序因容器数量增多变得复杂，使用人力处理将极为麻烦，这是就需要一个自动化的容器编排方案。目前功能最强大的编排方案是 kubernetes，即 k8s。<br>因目前尚未用到，暂且不做详细说明。简要介绍详见参考资料<a href="%5B40%E5%88%86%E9%92%9F%E7%9A%84Docker%E5%AE%9E%E6%88%98%E6%94%BB%E7%95%A5%EF%BC%8C%E4%B8%80%E6%9C%9F%E8%A7%86%E9%A2%91%E7%B2%BE%E9%80%9ADocker%5D(https://www.bilibili.com/video/BV1THKyzBER6)">^1</a>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
            <tag> docker </tag>
            
            <tag> 部署工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实践中理解 Linux 软件依赖机制和打包方法</title>
      <link href="/2025/10/25/Linux/Linux%20%E8%BD%AF%E4%BB%B6%E4%BE%9D%E8%B5%96%E6%9C%BA%E5%88%B6%E5%92%8C%E6%89%93%E5%8C%85/"/>
      <url>/2025/10/25/Linux/Linux%20%E8%BD%AF%E4%BB%B6%E4%BE%9D%E8%B5%96%E6%9C%BA%E5%88%B6%E5%92%8C%E6%89%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>——记一次发布 Linux 程序时遇到的问题及解决方案</p><h3 id="万事俱备：软件在目标机上运行成功"><a href="#万事俱备：软件在目标机上运行成功" class="headerlink" title="万事俱备：软件在目标机上运行成功"></a>万事俱备：软件在目标机上运行成功</h3><p>这一次待部署的软件是一个代码约 2000 行的，使用 C++ 与 wxWidgets 图形库编写的一款简单的上位机软件，运行平台为 Linux 操作系统。目标机器为一台安装了 Debian12 的 amd64 主机。因业务需求，该主机必须单机运行，不能接入任何网络。开发主机也是使用 Debian12 系统的 amd64 主机。故将开发主机上编译好的二进制文件部署到目标机器时，软件可以正常运行。后续又对软件进行了几次修改和重新部署，均未发生问题。</p><h3 id="埋下隐患：将开发主机系统由-Debian12-升级为-Debian13"><a href="#埋下隐患：将开发主机系统由-Debian12-升级为-Debian13" class="headerlink" title="埋下隐患：将开发主机系统由 Debian12 升级为 Debian13"></a>埋下隐患：将开发主机系统由 Debian12 升级为 Debian13</h3><p>2025年8月9日，Debian 的新稳定版 Debian13 Trixie 正式发布，新系统使用了更新的软件包，升级了 Wayland，可以支持更高的分辨率，极大优化了用户体验。2025年9月18日，我将当前系统升级到了该版本，升级时遇到了一些小问题，不过很快都得到了解决。然而，这次升级却埋下了问题的种子。</p><h3 id="事与愿违：为什么好好的程序不能运行了？"><a href="#事与愿违：为什么好好的程序不能运行了？" class="headerlink" title="事与愿违：为什么好好的程序不能运行了？"></a>事与愿违：为什么好好的程序不能运行了？</h3><p>为了降低软件使用门槛，用户提出了新的需求：修改系统中一些参数的默认初始值。因为系统的一些默认的初始值是硬编码在程序中的，所以需要重新编译部署一次。如同往常一样，我在开发主机上敲下<code>cmake ..</code>和<code>make</code>命令，胸有成竹的将生成的二进制文件拷入目标机器，期待它能够正常运行。然而，当我用鼠标点击多次后，软件界面没有显示。我意识到大事不妙，打开命令行运行，一行报错赫然出现在眼前：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/main: /lib64/libc.so.6: version `GLIBC_2.38` not found (required by ./main)</span><br></pre></td></tr></table></figure><h3 id="先入为主：提出一种可行的解决方案——Linux-软件打包"><a href="#先入为主：提出一种可行的解决方案——Linux-软件打包" class="headerlink" title="先入为主：提出一种可行的解决方案——Linux 软件打包"></a>先入为主：提出一种可行的解决方案——Linux 软件打包</h3><p>明明系统安装了 glibc，为什么会找不到呢？再看一眼，发现是找不到 GLIBC_2.38。目标机器 Debian12 的 glibc 版本是 2.36，这说明程序运行需求 glibc 版本要高于当前系统。</p><p>针对这个问题，我当时想到了一个办法。链接器报错只会报第一个遇到的错误，既然以 glibc 为代表的软件动态库与目标机器当前系统不匹配，那么其他的动态库也可能会报类似错误。为了在今后避免这个问题，增加软件兼容性，我应该把软件主程序与动态库放在一起，就像常见的 Windows 软件那样。遵循这个想法，我使用下面的步骤尝试解决问题：</p><p>首先在开发主机上查询软件所有的依赖库，然后复制一份到软件的<code>lib</code>目录下，随后在编译时使用 RPATH 参数指定软件优先从<code>lib</code>目录查找运行库。最后复制运行软件需要的链接器<code>ld-linux-x86-64.so.2</code>。运行时，让这个链接器代替目标机器的链接器链接这些库就可以了。</p><p>我当时实现这个思路的操作如下：</p><ol><li>复制依赖库和链接器。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Usage: ./libcopy.sh &lt;executable&gt; &lt;directory&gt;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Effect: Copy the dependency of <span class="variable">$1</span> to directory <span class="variable">$2</span>&quot;</span></span><br><span class="line">dependency_list=$(ldd <span class="variable">$1</span> | awk <span class="string">&#x27;&#123;if (match($3,&quot;/&quot;))&#123;print $3&#125;&#125;&#x27;</span>)</span><br><span class="line"><span class="comment"># echo $dependency_list</span></span><br><span class="line"><span class="built_in">cp</span> -L -n <span class="variable">$dependency_list</span> <span class="variable">$2</span></span><br><span class="line"><span class="built_in">cp</span> -L -n /lib64/ld-linux-x86-64.so.2 <span class="variable">$2</span></span><br></pre></td></tr></table></figure></li><li>指定 RPATH 参数让链接器优先链接指定目录的动态库。（使用cmake） <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_SKIP_RPATH <span class="keyword">FALSE</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_WITH_INSTALL_RPATH <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_RPATH <span class="string">&quot;$ORIGIN/../lib&quot;</span> <span class="string">&quot;$ORIGIN/../lib&quot;</span>)</span><br></pre></td></tr></table></figure></li><li>设置编译参数使<code>lib</code>的链接器代替系统默认链接器。（使用cmake） <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;-Wl,-dynamic-linker=../lib/ld-linux-x86-64.so.2&quot;</span>)</span><br></pre></td></tr></table></figure></li></ol><p>这在使用这个解决方案后，glibc 的问题解决了，但拷入到目标机器运行时，另外的问题出现了，软件的一个依赖包 libwx_gtk3u_core-3.2.so.0 报错，提示这个包必须在 GLIBC_2.38 运行。为什么会出现这种情况呢？</p><h3 id="追根溯源：Linux-软件如何寻找动态库及正确打包方案"><a href="#追根溯源：Linux-软件如何寻找动态库及正确打包方案" class="headerlink" title="追根溯源：Linux 软件如何寻找动态库及正确打包方案"></a>追根溯源：Linux 软件如何寻找动态库及正确打包方案</h3><p>解决这个问题需要对 Linux 的动态链接有一定的了解，下面需要我们仔细探究 Linux 动态链接的过程。</p><p>在开发机器上使用<code>ldd</code>命令查看软件需要的动态库是如何链接的：我们发现了让人疑惑的结果，只有软件程序直接需要的库（可以用<code>readelf -d</code>命令看到）被链接到了我们指定的<code>lib</code>目录，其他被这些库间接需要的库仍然被链接到系统默认目录（<code>/lib</code>，<code>/usr/lib</code>）中。</p><p>看起来好像是我们为程序设置的 RPATH 变量出了问题，实际上，RPATH 变量的设置是正确的。这里涉及到 Linux 动态库链接的一个机制。Linux 的库依赖是一个 DAG 图结构，链接器会自顶向下搜索每个库，找到它们在系统中的位置。首先是主程序，由于主程序设置了 RPATH 变量，所以这次查找将优先选择 RPATH 变量中匹配的运行库。之后，链接器继续遍历，选择这些运行库的一个（如 libwx_gtk3u_core-3.2.so.0），查找其依赖库。问题就出现在这里，查找 libwx_gtk3u_core-3.2.so.0 库的依赖库时，由于 libwx_gtk3u_core-3.2.so.0 库是我们直接从开发主机操作系统复制过来的，并没有设置 RPATH，链接器并不会在我们指定的<code>lib</code>目录寻找依赖库。所以，所有 libwx_gtk3u_core-3.2.so.0 的依赖库都将从系统默认目录中寻找。</p><p>在目标机器上运行时，libwx_gtk3u_core-3.2.so.0 这个库是主程序直接依赖的，所以使用的是我们指定的<code>lib</code>目录的新版库，然而，由于这个库没有设置 RPATH 的缘故，链接器会从系统寻找这个库需要的依赖，其中的一些就属于系统上的旧版 glibc（比如<code>libstdc++.so.6</code>）。而开发主机操作系统中的 libwx_gtk3u_core-3.2.so.0 这个库需要更新的 glibc，与目标机操作系统的旧版 glibc 不适配，自然会产生报错。</p><p>由此，我们终于可以找到解决方案了。使用 patchelf 软件，<strong>将复制的所有动态链接库都增加 RPATH 属性</strong>即可。第一步的操作增加这一步就是正确的打包方案了。</p><p>上面的方式略显繁琐，且会导致软件包过大，但可以在保证软件的兼容性减少思考量。然而，我们可以简单分析一下程序的依赖，从而减少软件包的大小。我们首先使用<code>readelf -d</code>命令查看程序使用的所有依赖组件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -d main</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0x6ed70 contains 33 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libwx_gtk3u_core-3.2.so.0]</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libwx_baseu-3.2.so.0]</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libpulse-simple.so.0]</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libpulse.so.0]</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libstdc++.so.6]</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libgcc_s.so.1]</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]</span><br></pre></td></tr></table></figure><p>发现程序依赖 wxWidgets,pulseaudio,libstdc++,libgcc_s.so.1,libc.so.6 五个组件，由于我们这次的改动只是几个常量的变动，不涉及任何运行库新特性的使用，所以我们可以继续使用目标机器上已安装的 wxWidgets,pulseaudio 库。为了程序在目标机器运行时，链接器将<strong>目标机器</strong>系统中安装的两个库链接到程序中，<code>lib</code>目录下不应存在这两个库。对于剩下三个库，由于目标程序对这三个库的版本做出了要求，所以不可以使用目标机器的系统库，应当从<strong>开发主机</strong>复制这三个库及其所有依赖，以及支持链接这三个新库的新版链接器。复制后将所有动态库的<code>rpath</code>修改。</p><p>实现操作如下：</p><ol><li>复制依赖库并修改<code>rpath</code>，最后复制链接器，$1 为<code>lib</code>目录。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Usage: ./glibcopy.sh &lt;directory&gt;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Effect: Copy the glibc dependency to directory <span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="built_in">cp</span> -L -n /usr/lib/x86_64-linux-gnu/libstdc++.so.6 <span class="variable">$1</span> <span class="comment"># 依赖libc.so.6，libm.so.6，libgcc_s.so.1</span></span><br><span class="line"><span class="built_in">cp</span> -L -n /usr/lib/x86_64-linux-gnu/libgcc_s.so.1 <span class="variable">$1</span> <span class="comment"># 依赖libc.so.6</span></span><br><span class="line"><span class="built_in">cp</span> -L -n /usr/lib/x86_64-linux-gnu/libm.so.6 <span class="variable">$1</span> <span class="comment"># 依赖libc.so.6</span></span><br><span class="line"><span class="built_in">cp</span> -L -n /usr/lib/x86_64-linux-gnu/libc.so.6 <span class="variable">$1</span> <span class="comment"># 不依赖其他库</span></span><br><span class="line">patchelf * --set-rpath <span class="string">&#x27;$ORIGIN&#x27;</span> <span class="comment"># 改变所有动态库的 rpath</span></span><br><span class="line"><span class="built_in">cp</span> -L -n /lib64/ld-linux-x86-64.so.2 <span class="variable">$1</span> <span class="comment"># 最后复制链接器，注意不能修改它的rpath，它不是动态库！</span></span><br></pre></td></tr></table></figure></li><li>程序编译时指定 RPATH 参数。（使用cmake） <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_SKIP_RPATH <span class="keyword">FALSE</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_WITH_INSTALL_RPATH <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_RPATH <span class="string">&quot;$ORIGIN/../lib&quot;</span> <span class="string">&quot;$ORIGIN/../lib&quot;</span>)</span><br></pre></td></tr></table></figure></li><li>设置编译参数使<code>lib</code>的链接器代替系统默认链接器。（使用cmake） <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;-Wl,-dynamic-linker=../lib/ld-linux-x86-64.so.2&quot;</span>)</span><br></pre></td></tr></table></figure> 可以使用<code>readelf -l</code>命令查看程序寻找哪个链接器，判断参数是否成功设置。</li></ol><p>此时存放在<code>build</code>目录下的主程序就可以正确链接<code>lib/</code>目录下面的动态库了。</p><p>最后一个小问题，如果使用相对路径寻找链接器，那么程序将只能在当前工作目录正常运行，在其他目录执行就会报“无法执行：找不到需要的文件”的错误。这时，我们可以先将主程序重命名，然后相同目录创建一个与主程序原名相同的脚本，在脚本打开后，它会将工作目录切换到主程序所在位置，然后再运行主程序（Linux 平台的 Wolfram Mathematica 使用了类似的做法）。</p><p>举例来说，将下面的脚本改名为 main，并赋予执行权限，同时将程序改名为 main.exec。这样无论在那个目录都可以正常打开程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXECUTABLE_NAME=<span class="string">&quot;main.exec&quot;</span></span><br><span class="line">SCRIPT_REALPATH=$(<span class="built_in">realpath</span> <span class="variable">$0</span>)</span><br><span class="line">SCRIPT_DIRPATH=$(<span class="built_in">dirname</span> <span class="variable">$SCRIPT_REALPATH</span>)</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;SCRIPT_DIRPATH&#125;</span></span><br><span class="line"><span class="built_in">exec</span> ./<span class="variable">$&#123;EXECUTABLE_NAME&#125;</span></span><br></pre></td></tr></table></figure><h3 id="权宜之计：直接在-Debian12-环境下编译的省心方案"><a href="#权宜之计：直接在-Debian12-环境下编译的省心方案" class="headerlink" title="权宜之计：直接在 Debian12 环境下编译的省心方案"></a>权宜之计：直接在 Debian12 环境下编译的省心方案</h3><p>如果上述的操作方法实现起来过于麻烦，那可以使用另一个路子。如果你有操作系统的镜像，那可以直接在现有环境下创建一个虚拟机模拟目标机，然后使用虚拟机里的编译产物。如果选择了这类办法，使用目前应用广泛的 docker 技术更为经济，开销更小。在制作好 docker 镜像并创建容器后，将待编译的源文件映射到容器中，输入命令编译即可。</p><p>在拥有镜像（取名为<code>debian12_env:bookworm</code>）的情况下，使用 docker 的方法如下：</p><ol><li><p>创建docker容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker create --name debian12_wxwidgets_compiler \</span><br><span class="line">-dit -v /home/username/app:/home/username/app debian12_env:bookworm</span><br></pre></td></tr></table></figure></li><li><p>如果创建后立即运行，使用下面的命令</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run --name debian12_wxwidgets_compiler \</span><br><span class="line">-dit -v /home/username/app:/home/username/app debian12_env:bookworm</span><br></pre></td></tr></table></figure></li><li><p>启动docker容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker start debian12_wxwidgets_compiler</span><br></pre></td></tr></table></figure></li><li><p>执行docker环境下的编译过程</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 这一步是为了在容器创建一个与当前用户相同的用户，以解决编译产物归属问题</span></span><br><span class="line"><span class="built_in">sudo</span> docker <span class="built_in">exec</span> debian12_wxwidgets_compiler /bin/bash -c \</span><br><span class="line"><span class="string">&quot;groupadd username&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> docker <span class="built_in">exec</span> debian12_wxwidgets_compiler /bin/bash -c \</span><br><span class="line"><span class="string">&quot;useradd -m username -g username&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> docker <span class="built_in">exec</span> debian12_wxwidgets_compiler /bin/bash -c \</span><br><span class="line"><span class="string">&quot;cd /home/username/develop/AcData/build &amp;&amp; cmake .. &amp;&amp; make&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这一步是为了在容器创建一个与当前用户相同的用户，以解决编译产物归属问题</span></span><br><span class="line"><span class="built_in">sudo</span> docker <span class="built_in">exec</span> debian12_wxwidgets_compiler /bin/bash -c \</span><br><span class="line"><span class="string">&quot;chgrp -R username . &amp;&amp; chown -R username .&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> docker <span class="built_in">exec</span> debian12_wxwidgets_compiler /bin/bash -c <span class="string">&quot;exit&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>第五步：编译过程结束后，手动退出容器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker stop debian12_wxwidgets_compiler</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Glibc </tag>
            
            <tag> Release </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于博客重构</title>
      <link href="/2025/10/21/%E6%84%9F%E6%83%B3%E9%9A%8F%E7%AC%94/new%20blog/"/>
      <url>/2025/10/21/%E6%84%9F%E6%83%B3%E9%9A%8F%E7%AC%94/new%20blog/</url>
      
        <content type="html"><![CDATA[<h2 id="一、重构计划的产生"><a href="#一、重构计划的产生" class="headerlink" title="一、重构计划的产生"></a>一、重构计划的产生</h2><p>2025年春天，我就已经有重构老博客的打算。重构的原因有很多。第一，旧博客使用的模板并不是原生的，而是我根据使用需求改动过的，随着使用强度的提高，暴露的问题越来越多，数学公式的 bug，markdown 显示与排版的问题逐渐体现出来，此外，随着文档的增多，加载速度也成了一大问题。第二，旧博客的很多内容是我大学时期的课程作业，以及对一些概念粗浅的理解，需要的大量的纠正甚至是重写。第三，旧博客的布局我不太喜欢了，不是很主流，且文章的分类归档搜索功能也不是很强大，与我现在建设博客的概念相悖。</p><h2 id="二、本次重构的特点"><a href="#二、本次重构的特点" class="headerlink" title="二、本次重构的特点"></a>二、本次重构的特点</h2><p>本次重构具有如下特点：</p><h3 id="1-文章标签——提炼主旨，凸显特点"><a href="#1-文章标签——提炼主旨，凸显特点" class="headerlink" title="1. 文章标签——提炼主旨，凸显特点"></a>1. 文章标签——提炼主旨，凸显特点</h3><p>文档的标签是索引相关文章的重要属性。原来老博客的标签太多，很多标签名称不同，但意义相同，有些博客主题都是C语言，但在不同文档中，有的标签中标注“C”，有的标注“C语言”。有些标签分割不细致，相互之间有包含关系，如已有“编程语言”标签，文档中还有“C语言”，“Python语言”等标签。这些问题导致标签大量冗余，影响博客检索效率和博客性能。针对这些问题，在新博客中设定标签时，要尽可能复用已存在的标签，需要新添加标签时，不但要用最简练的语言提炼文章主旨，而且要思考标签的可复用性。</p><h3 id="2-文档分类——放弃树状，回归扁平"><a href="#2-文档分类——放弃树状，回归扁平" class="headerlink" title="2. 文档分类——放弃树状，回归扁平"></a>2. 文档分类——放弃树状，回归扁平</h3><p>与旧博客的层次化分类不同，新文档的分类将放弃层次的概念。这是一种概念上的简化，当然，也和新主题的展示方式有关。新主题不再以文档分类展示文档列表，所以过于追求分类的细化是没有必要的。</p><h3 id="3-文章数量——精兵简政，注重质量"><a href="#3-文章数量——精兵简政，注重质量" class="headerlink" title="3. 文章数量——精兵简政，注重质量"></a>3. 文章数量——精兵简政，注重质量</h3><p>以往的文章中，有些内容虽是我精心编写，但囿于学习时认识尚浅，文章质量水平难以与互联网上的大牛匹敌，一些讲算法理论的文章，如KMP介绍，远不如oiwiki上的教程好。有些内容几乎是照抄教材，自己的理解极少，更让人沮丧的是，照抄教材的质量虽为精品，但在同类中并非翘楚（举个例子，如《机器学习》西瓜书）。有些实践性强的内容，短短两年，随着技术的发展，就已经过时，如《使用 Android Studio 运行小米便签》、《使用 Debian11 运行 Linux0.11 代码》。有些文章是课程实践报告，其中一步步操作截图固然细致，但这些教程受到技术变革的影响太大，且我无法复现这些实验环境，并不能及时更新文章内容，这种文章以教程自居，难免误人子弟。所以这些内容，在本次博客更新中均不再出现。</p><p>今后的文章，将从我的工作生活实际出发，从一步步操作截图的教程化的形式中跳出来，多总结原理，透过现象看本质，深入原理，表达自己的理解。</p><h3 id="4-博客功能——便于使用、易于检索"><a href="#4-博客功能——便于使用、易于检索" class="headerlink" title="4.博客功能——便于使用、易于检索"></a>4.博客功能——便于使用、易于检索</h3><p>博客是展示自己的窗口，然而对我来说，博客更是一个积累知识与经验的平台。所以我最需要的，是高效的搜索功能。检索的方式十分多元，如果记得什么时候遇到了问题，写下了总结，我可以根据时间搜索。如果相关内容再次出现，我可以根据分类和标签查看相关知识。如果只记得文档关键词，也可以使用博客全文搜索。这也是我将这个博客取名为“知识库”的原因。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>这次更新，最主要的还是卸下博客的历史包袱。很多被舍弃的文章是我大学时期花费大量时间经历完成的，写下那些文章最后一个句号时，很多时候时间已经是万籁俱寂的深夜。可是，我最后还是要舍弃这些，这些文章不是没有价值，它们帮助我重新体会学习的历程，也帮助了好多在课后作业“卡关”的同学们。它们虽然不会在新博客中出现，但我会将它们珍藏，在许多年之后，当我再次回顾它们的时候，我依然会想到那为完成它们付出的白天，夜晚和汗水。也会想起，那段追求真理，渴望进步的经历。它们已经过时，然而完成它们却是成长进步必不可少的一部分，就像一句俗话，“如果一顿饭吃第6个馒头吃饱了，那我只吃第6个，能够吃饱饭吗？”</p>]]></content>
      
      
      <categories>
          
          <category> 感想随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语学习笔记</title>
      <link href="/2025/10/08/%E6%84%9F%E6%83%B3%E9%9A%8F%E7%AC%94/English_Learning/"/>
      <url>/2025/10/08/%E6%84%9F%E6%83%B3%E9%9A%8F%E7%AC%94/English_Learning/</url>
      
        <content type="html"><![CDATA[<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="高效理解定语从句"><a href="#高效理解定语从句" class="headerlink" title="高效理解定语从句"></a>高效理解定语从句</h3><p>2025年的十一假期，在阅读《人月神话》的时候，第十六章《No Sliver bullet - The essence and accident in software engineering》一节时，发现这句话不太好读：</p><blockquote><p>Ada is perhaps over-rich, the natural product of process by which requirements were laid on the design.</p></blockquote><p>要理解这句话，有两个难点：</p><ol><li><strong>laid</strong> 的意思，这是一词多意，应该理解为“提出”。这个词一旦理解错误，会让人觉得整句话不知所云。</li><li>一个比较绕的定语从句。</li></ol><p>有一个注意的点：</p><ol><li><strong>product</strong>的意思，在这里不应翻译为“产品”，而应该翻译为“结果”。</li></ol><p>这里有一个高效理解定语从句的办法，将从句中的代词翻译成<strong>就是那个</strong>的形式。例如：</p><blockquote><p>Ada 语言可能过于丰富，是<strong>那个过程</strong>的自然的结果，（<strong>就是</strong>，）通过<strong>那个过程</strong>，设计的需求被提出。<br>Ada is perhaps over-rich, the natural product of <strong>process</strong> by <strong>which</strong> requirements were laid on the design.</p></blockquote><p>为了不影响阅读速度，下面的的步骤可以不做，但如果要译成中文，还需要进行调整语序，润色表达的后续工作。</p><p>然后，使用从句提供的描述，修饰主句的“那个XX”：</p><blockquote><p>Ada 语言可能过于丰富，是<strong>设计的需求被提出的过程</strong>的自然的结果。</p></blockquote><p>润色表达使之更加通顺：</p><blockquote><p>Ada 语言可能过于丰富，是<strong>设计需求被提出后</strong>自然<strong>产生的</strong>结果。</p></blockquote><h3 id="否定疑问句和反意疑问句"><a href="#否定疑问句和反意疑问句" class="headerlink" title="否定疑问句和反意疑问句"></a>否定疑问句和反意疑问句</h3><p>反意疑问句</p><blockquote><p>He isn’t a driver, is he?</p></blockquote><p>回答：<br>无论是反意疑问句和否定疑问句，如果使用英语回答，你不用关注疑问句中的 isn’t，doesn’t等否定词，直接回答<code>Is he a driver</code>这个问题即可。</p><blockquote><p>Yes, he is.<br>表示他是司机<br>No, he isn’t.<br>表示他不是司机</p></blockquote><p>但译为中文时，需要这样翻译：<br>他不是一个司机，是吗？<br>不是，他是司机。<br>是，他不是司机。</p><p>参考：<a href="https://www.zhihu.com/question/20877943">请问否定疑问句和反意疑问句的区别？如何回答？</a></p><h2 id="特殊用法积累"><a href="#特殊用法积累" class="headerlink" title="特殊用法积累"></a>特殊用法积累</h2><h3 id="转载：谈谈-very-的强调作用"><a href="#转载：谈谈-very-的强调作用" class="headerlink" title="转载：谈谈 very 的强调作用"></a>转载：谈谈 very 的强调作用</h3><p>very 常用作<strong>副词</strong>，置于形容词、副词前，表示“很、非常、十分、极” 等意义。除此之外，它还可以放在形容词最高级、形容词 same 和 own 或 序数词前, 起强调作用，表示 <strong>“就是”、“正是”</strong> 的意思。（used to add force to a superlative adjective or to the adjectives “ same” or “ own”）</p><p>● 置于修饰名词的形容词最高级前。</p><blockquote><p>This is the very best chocolate cake that I’ve ever tasted.</p></blockquote><p>这是我尝过的最好的巧克力蛋糕。</p><p>● 置于修饰名词的 same 或 own 前。</p><blockquote><p>This is the very same place we sat the last time we came.</p></blockquote><p>这就是上次我们来的坐的那个地方。 </p><p>very 还可以用作<strong>形容词</strong>，置于名词前, 加强名词的语意，表示 <strong>“就是”、“正是”</strong> 的意思。</p><p>● 置于定冠词修饰的名词前。</p><blockquote><p>Everybody says he is the very man for the case.</p></blockquote><p>人人都说他是这件案子的最佳人选。</p><blockquote><p>He was caught in the very act of stealing.</p></blockquote><p>他是正在行窃时被抓获的。</p><p>● 置于被定语从句修饰的名词前面。</p><blockquote><p>He might be the very person we are looking for for this job.</p></blockquote><p>他可能是我们要为这项工作找的最好人选。</p><blockquote><p>How did you know this was the very thing I wanted?</p></blockquote><p>你怎么知道这就是我想要的东西？</p><p>● 置于指示代词</p><p>this 、that 修饰的名词前。</p><blockquote><p>At this very moment the telephone rang.</p></blockquote><p>就在这个时候电话铃响了。</p><blockquote><p>Red Army fought a battle on this very spot.</p></blockquote><p>红军就在此地打过一仗。 </p><p>● 置于物主代词</p><p>修饰的名词前。</p><blockquote><p>History is taking place before your very eyes.</p></blockquote><p>历史就在你们的眼前发生着。</p><blockquote><p>I know his very thoughts on the problem.</p></blockquote><p>我知道他在这个问题上的想法。 </p><p>● 置于某些表示极端点的名词前 （used to describe or emphasize the furthest point of something）。</p><blockquote><p>At the very back of the garden was a wooden shack.</p></blockquote><p>在院子的最后面是一间小木屋。</p><blockquote><p>I found it at the very bottom of the box.</p></blockquote><p>我是在这个盒子的最底层发现它的。</p><p>转载自：<a href="https://zhuanlan.zhihu.com/p/400922078">知乎专栏：英语词语杂谈（4）谈谈 very 的强调作用</a></p><h3 id="if-anything-的三个用法"><a href="#if-anything-的三个用法" class="headerlink" title="if anything 的三个用法"></a>if anything 的三个用法</h3><ul><li>A. 用来表达对某事的看法（used to express an opinion about something） ，常表示“若要说什么的话”、“要说有什么区别（不同）的话”等意思。</li></ul><p>例句:</p><blockquote><p>I’d say he was more like his father, if anything.</p></blockquote><p>依我看，如果一定要说他像谁的话，他比较像他的父亲。</p><blockquote><p>If anything, she is even more selfish than her husband.</p></blockquote><p>要说他们有什么区别的话，那只是她比她丈夫更自私一些。</p><blockquote><p>If anything, he is a little better today.</p></blockquote><p>如果说有什么不同，他比昨天略为好了一点。</p><blockquote><p>She was as horrified as he was and, if anything, her misery seemed greater than his.</p></blockquote><p>她和他一样恐惧，要说有什么不同，那就是她的似乎比他更痛苦。</p><ul><li>B. 在否定的陈述之后表示相反的观点（after a negative statement to suggest that the opposite is true）。</li></ul><p>例句：</p><blockquote><p>She’s not thin — if anything she’s a little plump.</p></blockquote><p>她一点也不瘦，只是有点胖。</p><blockquote><p>I haven’t made much of this — if anything, I’ve played it down.</p></blockquote><p>我并没有太在意这件事，我只是看得淡一些。</p><blockquote><p>Tom isn’t a bad boy, if anything, he is a pretty good one.</p></blockquote><p>汤姆不是一个坏男孩，相反，他是一个顶好的孩子。 </p><ul><li>C. “更可能的是”； “或许可能”， “甚至可能相反”用来试探性地暗示某事可能是这样的 （通常与先前暗示的相反）used to suggest tentatively that something may be the case (often the opposite of something previously implied)。</li></ul><p>例句：</p><blockquote><p>The weather forecast is not far cooler weather; if anything, it is expected to be warmer.</p></blockquote><p>天气预报说天气不会变凉; 预计却是要转暖。</p><blockquote><p>Despite optimistic reports, conditions has if anything worsened.</p></blockquote><p>尽管传来乐观的消息，情况甚至可能恶化了。</p><blockquote><p>We need to assess what happened and what, if anything, we could have done to prevent it.</p></blockquote><p>我们需要评估发生了什么，如果有什么的话，我们可以做些什么来防止它。</p><blockquote><p>Asthma drugs are not addictive and you don’t need to keep increasing the dose. If anything, the reverse is true.</p></blockquote><p>哮喘药物不会造成药物依赖，你不用持续增大剂量。甚至正相反，减小剂量才对。</p><p>转载自：<a href="https://zhuanlan.zhihu.com/p/537165490">知乎专栏：if anything 的三个用法</a></p><h3 id="such…-as-such-as引导定语从句四种类型"><a href="#such…-as-such-as引导定语从句四种类型" class="headerlink" title="such….as&#x2F;such as引导定语从句四种类型"></a>such….as&#x2F;such as引导定语从句四种类型</h3><p>such 中文意思：这样（的），那样（的），如此程度。词性为代词。</p><ul><li>一、用于such…as结构，其中的as为关系代词</li></ul><blockquote><p>Such women as knew Tom thought he was charming. </p></blockquote><p>那些认识汤姆的女人都认为他很迷人。</p><blockquote><p>Britain is not enjoying such prosperity as it was in the mid-1980s. </p></blockquote><p>英国现在已经不像 20 世纪 80 年代中期那么繁荣昌盛。</p><ul><li>二、such as相当于those who</li></ul><blockquote><p>Such as alter in a moment, win not credit in a month. </p></blockquote><p>那些朝令夕改的人是不会获得人们长久信任的。相当于Those who alter in a moment, win not credit in a month.</p><blockquote><p>Associate with such as will improve your manners.</p></blockquote><p>要和那些能提高你的礼貌修养的人交往。</p><ul><li>三、such as相当于what或whatever</li></ul><blockquote><p>Such as remains after tax will be yours when I die. </p></blockquote><p>我死以后全部财产除了交税以外都给你。</p><p>此句相当于：</p><blockquote><p>What remains after tax will be yours when I die.<br>Whatever remains after tax will be yours when I die.<br>Everything that remains after tax will be yours when I die.</p></blockquote><ul><li>四、such as 用作关系代词，用法上相当于that或which</li></ul><blockquote><p>Then I left it, feeling a weight at my heart such as I had never had before.</p></blockquote><p>然后我离开那里，心头感到一种前所未有的沉重情绪。</p><blockquote><p>There was a look of fear in her eyes, such as people have when they are suddenly awakened.</p></blockquote><p>她眼睛里有一种人们突然被唤醒时产生的恐惧表情。</p><p>转载自：<a href="https://zhuanlan.zhihu.com/p/138060814">such….as&#x2F;such as引导定语从句四种类型</a></p>]]></content>
      
      
      <categories>
          
          <category> 感想随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统的桌面环境简介</title>
      <link href="/2025/07/23/Linux/Debian%20Linux%20%E7%B3%BB%E7%BB%9F%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83/"/>
      <url>/2025/07/23/Linux/Debian%20Linux%20%E7%B3%BB%E7%BB%9F%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>已经使用当前的 Debian Linux 作为主力机两年了，一直都在用 Debian 的 KDE 桌面环境。开箱即用的环境，与 Windows 差不多的使用体验，几乎没有的使用门槛，以至于两年来并没有好好研究过桌面环境是如何实现的。最近，因为业务需要，我需要将一个在X86 Linux平台wxWidgets编写的程序移植到ARM Linux平台上，于是开始学习 Linux 桌面环境的细节。</p><h2 id="图形是如何显示在屏幕上的（基于-X11）"><a href="#图形是如何显示在屏幕上的（基于-X11）" class="headerlink" title="图形是如何显示在屏幕上的（基于 X11）"></a>图形是如何显示在屏幕上的（基于 X11）</h2><p>随着计算机技术的不断发展，单纯的命令行终端已经不能满足人们的使用需要。我们需要计算机帮助我们进行视频处理、图像处理、印刷排版、3D制图的功能。为了满足这些需求，用户图形接口(GUI)应运而生。</p><p>Linux 用户图形接口的基础是一个名为 X Windows System 的软件。为什么图形窗口要被称为 X 呢？是因为在英文字母表中，X 在 W 的后面，蕴含“这是下一代用户图形接口”的意思[^1]。</p><p>下面进入正题：X Windows System 分为服务端（X Server）、客户端（X Client）、窗口管理器（Windows Manager）、登录管理器（Display Manager）四部分。</p><p>在屏幕上绘图的功能，是由服务端（X Server）和客户端（X Client）交互完成的。</p><p>服务端（X Server）负责与所有硬件设备交互，包括接收外设的输入和将图形绘制到屏幕上。例如：</p><ol><li>处理“将某像素变为黑色”的命令。</li><li>接收“敲下键盘的 Esc 键”的用户操作。<br>另外，绘制需要的一切资源，如字体，屏幕参数等都是由服务端（X Server）管理的，具体可以查看<code>xorg.conf</code>配置文件（如果没有，需使用<code>Xorg-configure</code>手动制作）。<br>服务端（X Server）的实现主要有：Xorg、xFree86、Xnest等。</li></ol><p>客户端负责向服务端提供需要绘制的内容，以及处理服务端发来的事件。例如：</p><ol><li>程序运行时需要在某个位置绘制一个点，那么它就会调用 X Client 向服务端发送描述这个点详细信息的数据例如，类似于“将某像素变为黑色”。</li><li>如果鼠标移动了一下，服务器会感知到鼠标在横轴移动了X mm，纵轴移动了Y mm[^2]，但服务端没有能力将这样的变化体现在屏幕上，所以服务端将这个动作发送给客户端，由客户端对动作进行解算，解算完毕后，将类似“鼠标应该向某方向移动多少像素”这样的指令性操作发送给服务端，由服务端在屏幕上绘制图像。<br>我们平时在 Linux 上使用的窗口化的客户端软件，都是通过调用 Xlib 库，实现与服务端（X Server）交互的。可以看作是客户端（X Client）。Xlib 库是 X11 通信协议在 X Client 端的函数封装。</li></ol><p>X Windows System 使用的C&#x2F;S模式，使得客户端不必在意硬件平台的类型，在不同操作系统或硬件平台迁移时，只需改动功能相对简单的服务端即可，大大增加了可移植性。但我们又发现另一个问题：客户端与服务端的交互是点对点的，这就意味着客户端与客户端之间没有交互。换句话说，每个客户端并不知道其他客户端的存在。如果多个客户端同时运行，重叠的情况是不可避免的。窗口管理器（Windows Manager）解决了这个问题。</p><p>窗口管理器（Windows Manager）是一个特殊的客户端（X Client），它负责所有客户端的（X Client）管理，还提供一些特殊功能：</p><ol><li>任务栏、后台桌面的设置。</li><li>虚拟桌面。</li><li>窗口控制参数，如最大化，最小化，调整大小等。<br>下面这些 Linux 用户耳熟能详的“桌面环境”都是窗口管理器：GNOME、KDE、Xfce。</li></ol><p><img src="/assets/xWindows.svg" alt="X Windows System 组件关系示意图"></p><p>登录管理器（Display Manager）是相对独立的模块，主要是提供用户使用 X Windows Manager 之前的身份验证功能，并且加载用户选择的窗口管理器（Windows Manager）与用户配置数据（如<code>~/.local</code>目录中关于窗口管理器的相关配置，如自定义的任务栏等）。<br>与上面提到的窗口管理器相对应的登录管理器：GDM、KDM、XDM。</p><h2 id="X-Window的启动流程"><a href="#X-Window的启动流程" class="headerlink" title="X Window的启动流程"></a>X Window的启动流程</h2><h3 id="startx"><a href="#startx" class="headerlink" title="startx"></a>startx</h3><p>在启动X Window System时，必须先启动管理硬件与绘图的X Server，然后才加载X Client。基本上，目前都是使用WIndow Manager来管理窗口接口风格的。可以通过登入本机的文字接口后，输入startx来启动X窗口；也可以通过diplay manager提供的登入画面输入账号密码登入来启动X窗口。下面介绍从命令行入口启动X的流程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startx</span><br></pre></td></tr></table></figure><p>从命令行登入系统后，输入startx（shell脚本），它的任务就是找到用户或系统默认的X Server与X Client的配置文件，也可以在startx后接配置参数，格式如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startx [X client参数] -- [X server参数] <span class="comment">#如startx -- -depth 16</span></span><br></pre></td></tr></table></figure><p>注意后面的参数以–隔开，前面是client的设定，后面是server的设定。</p><h3 id="initx"><a href="#initx" class="headerlink" title="initx"></a>initx</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xinit</span><br></pre></td></tr></table></figure><p>实际上startx会启动xinit，startx在帮它找出设置参数。</p><p>语法格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xinit [client option] -- [server or display option]</span><br></pre></td></tr></table></figure><p>系统默认的startx，等于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xinit /etc/X11/xinit/xinitrc -- /etc/X11/xinit/xserverrc</span><br></pre></td></tr></table></figure><p>若xserverrc不存在，则是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xinit /etc/X11/xinit/xinitrc -- /usr/bin/X</span><br></pre></td></tr></table></figure><p>单纯执行xinit，系统的默认X client和X server是这样的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xinit xterm -geometry +1+1 -n login -display :0 -- X :0</span><br></pre></td></tr></table></figure><h3 id="X-server参数"><a href="#X-server参数" class="headerlink" title="X server参数"></a>X server参数</h3><p>startx后面的参数</p><p>若无，则<code>~/.xserverrc</code></p><p>若无，则<code>/etc/X11/xinit/xserverrc</code></p><p>若无，则单纯执行<code>/usr/bin/X</code></p><h3 id="X-client参数"><a href="#X-client参数" class="headerlink" title="X client参数"></a>X client参数</h3><p>startx后面的参数</p><p>若无，则<code>~/.xinitrc</code></p><p>若无，则<code>/etc/X11/xinit/xinitrc</code></p><p>若无，则单纯执行<code>xterm</code></p><p>最终会载入KDE或者GNOME，X Client中的两个指令搜寻，startkde和gnome-session，这是CentOS预设的两个主要的Window Manager。</p><p>概括来说，在命令行模式下启动X时，直接使用startx找到X Server与X Client的参数或配置文件，然后打开xinit启动X窗口系统。xinit先载入X Server找到预设的 :0这个现实接口，然后再加载X Client到这个X现实接口上。而X Client通常就是GNOME或者KDE。另外使用<code>ctrl+alt+Fn</code>可以切换不同终端画面。</p><h2 id="X-启动流程测试"><a href="#X-启动流程测试" class="headerlink" title="X 启动流程测试"></a>X 启动流程测试</h2><p>在tty1中，启动第一个X在:1画面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X :1 &amp;</span><br></pre></td></tr></table></figure><p>返回tty1中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xterm -display :1 &amp;</span><br></pre></td></tr></table></figure><p>再次在tty1中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xterm -display :1 &amp;</span><br><span class="line">xclock -display :1 &amp;</span><br><span class="line">xeyes -display :1 &amp;</span><br></pre></td></tr></table></figure><p>在tty1中，启动Window Manager</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">twm -display :1 &amp;</span><br></pre></td></tr></table></figure><h2 id="窗口系统新生代-Wayland-简介"><a href="#窗口系统新生代-Wayland-简介" class="headerlink" title="窗口系统新生代 Wayland 简介"></a>窗口系统新生代 Wayland 简介</h2><p>由于我并非相关专业开发者，只是一名用户，所以只能根据 wayland 官网的介绍简要的写出一些理解，这一小节仅供参考。</p><h3 id="为什么使用-Wayland-代替-X-Windows-System"><a href="#为什么使用-Wayland-代替-X-Windows-System" class="headerlink" title="为什么使用 Wayland 代替 X Windows System"></a>为什么使用 Wayland 代替 X Windows System</h3><p>随着X Windows 的发展，功能的增多，该结构的设计缺陷也逐步暴露。如对Linux上独立程序支持的不好、包含许多与其他开源项目重复的工作、组合多个窗口元素的的开销较大等。同时，如果遵循X Windows 的架构设计，将会为一些现代化桌面系统功能带来较大的运行时开销（上下文切换）。[^5]</p><p>在 X Windows 的开发过程中，开发者们为了解决 X Windows 过于臃肿的架构，将一部分功能交给了 X 客户端和系统内核驱动。举例来说，首先被摘出的功能就是字体渲染。随着直接图形渲染技术的发展，OpenGL，DRI2 技术将图形渲染功能也交由客户端实现。这样的变革，是 wayland 发展的契机。</p><h3 id="Wayland-的原理和特点"><a href="#Wayland-的原理和特点" class="headerlink" title="Wayland 的原理和特点"></a>Wayland 的原理和特点</h3><p>wayland 与 X 一样，是一种图形显示协议。Weston 是 wayland 协议的具体实现。wayland 将渲染的任务交给了客户端，客户端拥有自己的图形缓冲区，根据需求使用各种硬件加速库，Cairo 软件库等。最后，wayland 只需要做窗口管理即可，无需复杂的服务端实现。下图是 X 与 wayland 架构的对比[^5]。（注意 Compositor 与上文的 Windows Manager 作用是相同的）</p><p>X windows System:<br><img src="/assets/x-architecture.png" alt="X windows System 架构"></p><p>Wayland:<br><img src="/assets/wayland-architecture.png" alt="wayland 架构"></p><p>更多对比详见官方文档wayland结构部分，<a href="https://wayland.freedesktop.org/docs/html/ch03.html">链接</a></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="X是什么，X11是什么"><a href="#X是什么，X11是什么" class="headerlink" title="X是什么，X11是什么"></a>X是什么，X11是什么</h3><p>X 是 X Windows System 的简称，X11，X11R6 是软件的版本号。</p><h3 id="C-S-模式下，为什么使用-lsof-i-命令看不见关于-X-的开放端口"><a href="#C-S-模式下，为什么使用-lsof-i-命令看不见关于-X-的开放端口" class="headerlink" title="C&#x2F;S 模式下，为什么使用 lsof -i 命令看不见关于 X 的开放端口"></a>C&#x2F;S 模式下，为什么使用 lsof -i 命令看不见关于 X 的开放端口</h3><p>考虑 X Windows System 主要在本机上运行，各大发行版将端口改为了 socket 文件，占用 6000 端口，在 X 中表示为 hostname:0。</p><h3 id="GTK-是什么，和-X-有什么联系"><a href="#GTK-是什么，和-X-有什么联系" class="headerlink" title="GTK 是什么，和 X 有什么联系"></a>GTK 是什么，和 X 有什么联系</h3><p>GTK 是基于 GDK 的一个开源控件库。GDK 库是标准 Xlib 函数的封装，GTK 是在 GDK 基础上的控件库，与 GDK 做法相同的还有著名的 QT 库[^3]。这些库封装了对于 Xlib 函数的调用，使编码更加方便。wxWidgets 也是一个封装库，它封装 GTK 库的版本称为 wxGTK，同样它也有直接封装 Xlib 的版本，wxX11[^4]。从上面的关系我们可以看出：实际上，像QT，wxWidgets 这类跨平台 GUI 库只是对各个平台 GUI 的差异部分做了抽象，实际后端多用系统原生 api 实现。具体关系如图所示：<br><img src="/assets/gtk_xlib.svg" alt="桌面组件库与 X 的关系图"></p><h3 id="Wayland-能完全替代-X-Windows-System-吗？"><a href="#Wayland-能完全替代-X-Windows-System-吗？" class="headerlink" title="Wayland 能完全替代 X Windows System 吗？"></a>Wayland 能完全替代 X Windows System 吗？</h3><p>并不能，Wayland 是与 X 完全不同的新技术，所以他们是<strong>不兼容的</strong>。在过去几十年中，一些依赖 X11 运行的程序已经成为日常工作生活中不可缺少的部分。这些程序因历史原因无法及时迁移到新技术，所以 X 在长远的未来仍不会被淘汰。目前要想在 Wayland 桌面环境中运行为 X11 编写的软件，需要使用 XWayland 这个中间件。</p><p>参考资料：<br>[^1]:《鸟哥的的Linux私房菜》第四版 2023.09 人民邮电出版社 第23章<br>[^2]: <a href="https://zhuanlan.zhihu.com/p/430687503">鼠标在移动时发生了什么</a><br>[^3]: <a href="https://www.cnblogs.com/bigben0123/p/3238483.html">X11,GTK,QT,GNOME的区别与联系</a><br>[^4]: <a href="https://blog.csdn.net/iw1210/article/details/52463912">X11、GTK、QT、GNOME和KDE之间的区别与联系</a><br>[^5]: <a href="https://wayland.freedesktop.org/docs/html/ch01.html#sect-Motivation">wayland组织官网</a><br>[^6]: <a href="https://farseerfc.me/zhs/brief-history-of-compositors-in-desktop-os.html">桌面系统的混成器简史</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 桌面环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次修电脑的经历</title>
      <link href="/2025/06/09/%E6%84%9F%E6%83%B3%E9%9A%8F%E7%AC%94/repair2025/"/>
      <url>/2025/06/09/%E6%84%9F%E6%83%B3%E9%9A%8F%E7%AC%94/repair2025/</url>
      
        <content type="html"><![CDATA[<h2 id="购入新电脑"><a href="#购入新电脑" class="headerlink" title="购入新电脑"></a>购入新电脑</h2><p>2019年8月9日，为了上大学的需要，我在长沙购置了一台联想ThinkPad笔记本电脑。这台电脑伴随我度过了包括网课在内的四个学期。电脑质量非常不错，在学校摔了六七次不止，仍然安然无恙。但它还是光荣退役了，原因是这样的：2021年，正值疫情期间，那年寒假，学校因为特殊的形势，并没有放我们回家。2021年4月的某一天，我在使用电脑时将耳机放在了键盘的位置。随后，我出去上了个厕所，回来后，宿舍有人问我作业输出的结果，于是我便合上电脑，准备去宿舍支援一下舍友。这一合，用力过猛，键盘上的耳机把我的屏幕硌坏了。随后就到了5月，学校为了弥补寒假没放的遗憾，把五一假期延长了10天。于是我回家去电脑城修了一下电脑，顺便物色有没有更好的电脑。跑了好几家，选了这个联想小新Air15 2021版。</p><h2 id="第一次屏幕开胶"><a href="#第一次屏幕开胶" class="headerlink" title="第一次屏幕开胶"></a>第一次屏幕开胶</h2><p>新电脑入手不到两个月，就出现了一个严重的问题，屏幕的左下角开胶了（当时只能观察出这个问题）。当时正好是周四，只耽误了一天的使用。周六，我去河西大学城溁湾镇的联想售后修了一下，花费一周时间，和400块钱后，我的电脑又恢复如初了。就没有深究这个问题，随后，一直到2025年5月，这台电脑也就没有再出现过问题。</p><h2 id="第二次屏幕开胶"><a href="#第二次屏幕开胶" class="headerlink" title="第二次屏幕开胶"></a>第二次屏幕开胶</h2><p>2025年5月30日，端午节的前一天，我的电脑B壳左下角与屏幕的连接处又出现了轻微分离，经过几次开合后，分离区域越来越大，我立刻回想起2021年的问题与之类似。同一个问题出现两次，这引起了我的警觉。先上网搜索，发现引起该问题的根本原因是：转轴过紧，长时间多次开合，A壳用于固定屏幕合页的底座疲劳碎裂，导致合页不能随A壳运动，挤压B壳使之开裂。简而言之，屏轴碎裂！我随即搜索联想小新屏轴碎裂相关维修方法，发现屏轴碎裂联想小新电脑，甚至是联想所有品牌笔记本电脑的通病。方法有两种，一种是用AB胶粘住碎裂的部分，一种是更换A壳。我拆开电脑，观察屏轴状态，发现左侧屏轴固定点完全碎裂，方法一显然不可行，遂采取方法二。随后，我再次组装电脑。开机上电后，一个可怕的问题出现了。可能是因为我拆B壳时用力过猛，把屏幕的压坏了。小问题变成大问题了，表情哭笑不得，心中沮丧万分。我工作的地方是一个小城市，联想售后店离我有将近20公里远，实在不想跑了，于是购买物品，自行维修。物品清单如下表（有些物品不单卖），如果仅需要更换A壳，购买加<code>*</code>的物品即可，拆机套件未列出：</p><table><thead><tr><th align="center">物品</th><th align="center">数量</th><th align="center">价格</th></tr></thead><tbody><tr><td align="center">防静电拆机片*</td><td align="center">5</td><td align="center">15.36</td></tr><tr><td align="center">A面保护膜*</td><td align="center">2</td><td align="center">25.08</td></tr><tr><td align="center">易拉胶（抽拉胶）*</td><td align="center">2*10</td><td align="center">18.76</td></tr><tr><td align="center">A壳（带天线）*</td><td align="center">1</td><td align="center">70</td></tr><tr><td align="center">B壳</td><td align="center">1</td><td align="center">30</td></tr><tr><td align="center">左右小盖</td><td align="center">1</td><td align="center">20</td></tr><tr><td align="center">AB胶</td><td align="center">1</td><td align="center">13.3</td></tr><tr><td align="center">小新Air15 2021屏幕</td><td align="center">1</td><td align="center">276</td></tr><tr><td align="center">总计</td><td align="center">-</td><td align="center">468.5</td></tr></tbody></table><p>（好贵，心痛）</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>调整转轴，使之松一些</li><li>更换A，B壳（B壳可以不换的）</li><li>更换屏幕（注意不要粘歪了）</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>断电操作</li><li>拆除B壳时，用拆机片沿B壳四周划一圈，把双面胶去掉</li><li>拆易拉胶时动作要慢，要温柔，如果易拉胶中途断掉，那就很麻烦，需要使用电吹风加热A面，使得易拉胶热融。</li><li>确保接口完全接好，无虚接</li><li>谨慎，不要相信大力出奇迹（如果屏幕坏了也是奇迹，请忽略这一项）</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>感谢B站的各位大神，统统收进我的收藏夹<code>(^_^)</code>。</p><p>参考资料：<br>[^1]: <a href="https://www.bilibili.com/video/BV1xdmYYhE5Q">联想小新屏轴断裂，不花钱原壳完美修复</a><br>[^2]: <a href="https://www.bilibili.com/video/BV1ti4y1r7y4">联想小新AIR15换屏幕教程Air15 2021 2022款 ALC ITL成功更换笔记本显示液晶屏屏幕拆屏换内屏视频教程</a><br>[^3]: <a href="https://www.bilibili.com/video/BV1q44y1w7KX">小新15 20&#x2F;21款屏幕崩开，单独更换A壳可以解决问题</a><br>[^4]: <a href="https://www.bilibili.com/video/BV1sy411q7zv">联想小新屏轴过紧导致A壳开裂，别只会换壳 ，调节屏轴才是重点</a></p>]]></content>
      
      
      <categories>
          
          <category> 感想随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维杂谈</title>
      <link href="/2025/05/21/others/%E8%BF%90%E7%BB%B4%E6%9D%82%E8%B0%88/"/>
      <url>/2025/05/21/others/%E8%BF%90%E7%BB%B4%E6%9D%82%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="机房运维"><a href="#机房运维" class="headerlink" title="机房运维"></a>机房运维</h2><p>这里存放着我做机房运维工作时的一些细节和故事。</p><h2 id="1-温湿度标准"><a href="#1-温湿度标准" class="headerlink" title="1 温湿度标准"></a>1 温湿度标准</h2><h3 id="A-类机房"><a href="#A-类机房" class="headerlink" title="A 类机房"></a>A 类机房</h3><p>包括干线传输枢纽和设置长途交换机、省际&#x2F;省内骨干信令转接点、省际&#x2F;省内骨干智能网SCP、省际&#x2F;省内骨干数据网设备的电信机房及其动力机房等。</p><p>正常温、湿度范围：温度10～25℃，湿度40～70% 可接受的温、湿度范围：温度10～26℃，湿度40～75%。</p><h3 id="B-类机房"><a href="#B-类机房" class="headerlink" title="B 类机房"></a>B 类机房</h3><p>包括设置本地网汇接局、关口局、智能网SCP、信令 转接点、无线市话核心网设备、传输骨干节点、数据骨干节点（含城 域网核心层设备）、IDC、拨号服务器的通信机房及其动力机房，进口程控交换母局和5万门以上的国产程控交换母局机房及其测量室、动力机房，服务重要用户及要害部门的交换、传输、数据设备通信机房，长途干线上下话路站等。</p><p>正常温、湿度范围：温度10～28℃，湿度30～70% 可接受的温、湿度范围：温度5～28℃，湿度30～80%</p><h3 id="C-类机房"><a href="#C-类机房" class="headerlink" title="C 类机房"></a>C 类机房</h3><p>包括5万门以下国产程控交换母局、城域网汇聚层数据机房及所属的动力机房，长途传输中继站等。</p><p>正常温、湿度范围：温度10～30℃,湿度30～75% 可接受的温、湿度范围：温度5～30℃,湿度20～80%</p><h3 id="D-类机房"><a href="#D-类机房" class="headerlink" title="D 类机房"></a>D 类机房</h3><p>包括设置固定电话模块局、用户接入网、城域网接入层设备（小区路由器、交换机）、DSLAM设备、线缆进线室机房等。</p><p>正常温、湿度范围：温度5～33℃,湿度20%～80% 可接受的温、湿度范围：温度0～35℃,湿度15%～85% 注：可接受的温、湿度范围是指在短时间内（连续4小时以内），允许设备在低于、或高于正常温、湿度范围的条件下工作的温、湿度范围。</p><h3 id="要求室外环境温度"><a href="#要求室外环境温度" class="headerlink" title="要求室外环境温度"></a>要求室外环境温度</h3><p>室内：0℃～40℃<br>室外：4℃～45℃(水冷)，-40℃～45℃(风冷) </p><h2 id="2-空调系统高压保护故障的解决"><a href="#2-空调系统高压保护故障的解决" class="headerlink" title="2 空调系统高压保护故障的解决"></a>2 空调系统高压保护故障的解决</h2><p>时间：2025.5.21<br>今天上午，发现机房的温度比较高。检查空调状态，发现空调只吹风，不制冷，提示“系统高压保护”。看着机房温度升高，解决问题的需求迫在眉睫，在网上查阅发现是空调压缩机出了问题，看这个样子，我们自身没法解决，于是咨询厂家。中午收到空调厂家的回复，然后，用一把扫帚解决了问题。</p><p>问题是这样产生的：5月份，正是一片万物复苏，生机勃发的境界。杨树柳树都会在在此时飞絮。漫天飞絮随风飘荡，堪称五月飞雪的奇景。这些飞絮在途径空调外机附近时，会被空调外机进风口一端捕获，从而一层一层的沉积。沉积的层数多了，就相当于给空调的散热板盖上一层棉被，影响空调的散热性能。根据空调热循环的原理，空调外机散热性能不佳，外机回流冷凝水温度就会升高。在冷凝器中温度更高的冷凝水，会导致制冷剂循环中气态制冷剂的占比变大。多次循环后，气态制冷剂占比越来越大，产生的气压会使得压缩机无法正常工作，出现压缩机高压保护。所以，解决的办法是，用扫帚把外机进风口的杨絮柳絮扫掉，然后重新启动空调就可以了。</p><p>后续：在稳定运行3小时后，又出现了这个故障。厂家第二天继续排查，发现空调的高压开关也坏了。于是短接高压开关，后续的几天里空调运行正常了。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>awk的基本使用</title>
      <link href="/2025/04/21/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/awk/"/>
      <url>/2025/04/21/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/awk/</url>
      
        <content type="html"><![CDATA[<h2 id="awk-简介"><a href="#awk-简介" class="headerlink" title="awk 简介"></a>awk 简介</h2><p>shell下功能极其强大的文本处理工具，语法与C语言很类似。每个unix及其衍生系统（如Linux）都会携带这个程序。</p><h2 id="awk-程序的结构"><a href="#awk-程序的结构" class="headerlink" title="awk 程序的结构"></a>awk 程序的结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;pattern &#123;action&#125;&#x27;</span> file</span><br></pre></td></tr></table></figure><p>其中 pattern 可以为正则表达式匹配上的行，可以为 BEGIN ,END 等时间词。满足 pattern 的条件，就执行后面的 action 程序。最后的 file 是待处理的文件名。</p><h2 id="awk-程序中的内置变量"><a href="#awk-程序中的内置变量" class="headerlink" title="awk 程序中的内置变量"></a>awk 程序中的内置变量</h2><p>为了方便处理文件，标识全局信息，awk 定义了一些内置变量。<br>请忽略表格第一列中除美元符号外的全部特殊符号！</p><table><thead><tr><th align="center">内置变量名</th><th>内置变量作用</th></tr></thead><tbody><tr><td align="center">NR</td><td>当前处理的行号，处理多个文件时会累加</td></tr><tr><td align="center">FNR</td><td>当前处理的行号，处理多个文件时会重新计数</td></tr><tr><td align="center">NF</td><td>当前行的字段数（列数，以FS指定的符号分隔）</td></tr><tr><td align="center"><code>$0</code>,<code>$1</code>,<code>$2</code></td><td>当前行全列，第一列，第二列的值</td></tr><tr><td align="center"><code>$NF</code></td><td>当前行的最后一列的值</td></tr><tr><td align="center">FS</td><td>指定输入字段的分隔符，默认是空格</td></tr><tr><td align="center">OFS</td><td>指定输出字段的分隔符，默认是空格</td></tr><tr><td align="center">RS</td><td>指定输入记录的分隔符，默认是换行符</td></tr><tr><td align="center">ORS</td><td>指定输出记录的分隔符，默认是换行符</td></tr><tr><td align="center">ARGIND</td><td>当前处理的文件在命令行参数中的索引</td></tr><tr><td align="center">ARGC</td><td>命令行参数的数量</td></tr><tr><td align="center">ARGV</td><td>命令行参数列表，使用ARGV[]获取</td></tr><tr><td align="center">ENVIRON</td><td>存储当前环境变量的关联数组</td></tr><tr><td align="center">FILENAME</td><td>当前正在处理文件的文件名</td></tr><tr><td align="center">SUBSEP</td><td>数组下标分隔符，默认是不可打印字符\034</td></tr><tr><td align="center">RSTART</td><td>match函数匹配字符串的起始位置</td></tr><tr><td align="center">RLENGTH</td><td>match函数匹配字符串的长度</td></tr></tbody></table><p>解释与举例：</p><ol><li>RS：将RS改为空，awk就不再一行行的读文件了，而是一下读入全部文件。</li><li>ENVIRON：BEGIN{print ENVIRON[“HOME”]}会输出当前用户 HOME 目录。</li><li>match 与 RSTART, RLENGTH 使用方法：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN&#123;start=match(&quot;this is a teststr&quot;, /^[a-z ]+$/); print start,RSTART,RLENGTH&#125;&#x27;</span> test.txt</span><br></pre></td></tr></table></figure><p>RSTART 是从 1 开始计数的。</p><h2 id="内置变量常用用法"><a href="#内置变量常用用法" class="headerlink" title="内置变量常用用法"></a>内置变量常用用法</h2><ol><li>将 RS 设为空串，以一次性处理多行记录 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN &#123;RS=&#x27;</span><span class="string">&#x27;&#125;&#123;print $0&#125;&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li><li>修改 SUBSEP 定义多维数组的下标分隔符 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN&#123;SUBSEP=&quot;:&quot;; arr[&quot;a&quot;, &quot;b&quot;]=10;&#125; &#123;for (x in arr) &#123;print x, arr[x];&#125;&#125;&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li><li>结合 match, substr 函数，可以提取匹配的字符串： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN&#123;str=&quot;Hello World!&quot;; match(str, /World/); print substr(str, RSTART, RLENGTH);&#125;&#x27;</span> test.txt</span><br></pre></td></tr></table></figure></li></ol><h2 id="awk-程序运行方式"><a href="#awk-程序运行方式" class="headerlink" title="awk 程序运行方式"></a>awk 程序运行方式</h2><h3 id="方法一：命令行运行"><a href="#方法一：命令行运行" class="headerlink" title="方法一：命令行运行"></a>方法一：命令行运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;pattern &#123;action&#125;&#x27;</span> file </span><br></pre></td></tr></table></figure><p>pattern 为匹配条件（可选）<br>action 为运行处理动作</p><h3 id="方法二：awk-代码文件"><a href="#方法二：awk-代码文件" class="headerlink" title="方法二：awk 代码文件"></a>方法二：awk 代码文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -f script.awk file</span><br></pre></td></tr></table></figure><h2 id="awk-pattern-部分的过滤功能"><a href="#awk-pattern-部分的过滤功能" class="headerlink" title="awk pattern 部分的过滤功能"></a>awk pattern 部分的过滤功能</h2><ol><li>按某列的值 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;$2&gt;50&#123;print $1&#125;&#x27;</span> file`</span><br></pre></td></tr></table></figure></li><li>按某几列的计算结果 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;$1+$2&gt;50&#123;print $1&#125;&#x27;</span> file</span><br></pre></td></tr></table></figure></li><li>按字符串 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;/^[a-z]+/&#123;print $1&#125;&#x27;</span> file</span><br></pre></td></tr></table></figure></li><li>不同方式组合 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;/error/ &amp;&amp; $2&gt;50&#123;print $1&#125;&#x27;</span> file</span><br></pre></td></tr></table></figure></li><li>当awk从输入读取数据之前，BEGIN的语句开始执行。当所有输入数据被读取完毕，END的语句开始执行。</li><li>对从 pattern1 的行开始，到 pattern2 的行结束的所有行应用 action（包括这两行）。 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;NR==5,NR==10&#123;i=1; while(i&lt;=NF)&#123;print $i; i++&#125; &#125;&#x27;</span> file</span><br></pre></td></tr></table></figure></li></ol><h2 id="action-的输出方式"><a href="#action-的输出方式" class="headerlink" title="action 的输出方式"></a>action 的输出方式</h2><ol><li>print</li><li>printf：与 C 语言的用法基本相同。</li><li>结合其他命令，使用管道。<code>awk &#39;{print $1}&#39; file.txt | sort</code></li></ol><h2 id="action-的控制流"><a href="#action-的控制流" class="headerlink" title="action 的控制流"></a>action 的控制流</h2><ol><li>条件分支 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;if($1&gt;50)print &quot;H&quot;;else print &quot;L&quot;&#125;&#x27;</span> file</span><br></pre></td></tr></table></figure></li><li>while循环 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;NR==1&#123;i=1; while(i&lt;=NF)&#123;print $i; i++&#125;&#125;&#x27;</span> file</span><br></pre></td></tr></table></figure></li><li>for循环 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;for(i=1;i&lt;=NF;++i)sum[i]+=$i&#125; END&#123;for (i in sum)&#123;print &quot;Column:&quot;, i, &quot; sum:&quot;, sum[i]&#125;&#125;&#x27;</span> file</span><br></pre></td></tr></table></figure></li></ol><h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><ol><li>打印文档的第 10 行到第 15 行 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;NR==10,NR==15&#123;print $0&#125;&#x27;</span> file</span><br></pre></td></tr></table></figure></li><li>将所有字段取绝对值并求和 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN&#123;sum=0;&#125;&#123;for(i=1;i&lt;=NF;++i)&#123;sum+=($i&gt;0?$i:-$i)&#125; &#125; END&#123;print sum&#125;&#x27;</span> file</span><br></pre></td></tr></table></figure></li><li>提取所有目录 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lha | awk <span class="string">&#x27;&#123;if (substr($1, 1, 1)==&quot;d&quot;)print $8&#125;&#x27;</span></span><br></pre></td></tr></table></figure></li><li>清除bash历史记录中不需要的部分<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | awk <span class="string">&#x27;!/wxSerialData/ &amp;&amp; !/make/ &#123;s = &quot;&quot;;&#123;for (i=2;i&lt;=NF;++i) s=s $i &quot; &quot; &#125; print s;&#125;&#x27;</span></span><br></pre></td></tr></table></figure></li><li>字符串替换（查看gcc搜索库的路径）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-gcc -print-search-dirs | grep libraries | awk <span class="string">&#x27;BEGIN&#123;FS=&quot;:&quot;&#125; &#123;for (i=2;i&lt;=NF;++i) &#123;gsub(/ =/, &quot;&quot;);printf(&quot;%2d: %s\n&quot;, i-1, $i)&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure></li><li>获取依赖项的文件名（包含函数使用）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd libstdc++.so.6 | awk <span class="string">&#x27;function basename(file) &#123;sub(&quot;.*/&quot;, &quot;&quot;, file);return file;&#125;&#123;if (match($3,&quot;/&quot;))&#123;print  basename($3)&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> awk语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bash </tag>
            
            <tag> awk </tag>
            
            <tag> 文本处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Debian12上安装dhcp服务</title>
      <link href="/2024/12/29/%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5/debian%20with%20dhcp/"/>
      <url>/2024/12/29/%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5/debian%20with%20dhcp/</url>
      
        <content type="html"><![CDATA[<h2 id="一、安装服务软件"><a href="#一、安装服务软件" class="headerlink" title="一、安装服务软件"></a>一、安装服务软件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install isc-dhcp-server</span><br></pre></td></tr></table></figure><p>注意在安装完软件后，这个程序会尝试自启动。由于我们没有正确编写软件的配置文件，所以启动不会成功，会留下一大堆红色的报错信息。</p><h2 id="二、编写软件配置文件"><a href="#二、编写软件配置文件" class="headerlink" title="二、编写软件配置文件"></a>二、编写软件配置文件</h2><p>首先要配置<code>/etc/default/isc-dhcp-server</code>文件。指定 dhcp 配置文件位置和提供服务的网卡。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Defaults for isc-dhcp-server (sourced by /etc/init.d/isc-dhcp-server)</span><br><span class="line"></span><br><span class="line"># Path to dhcpd&#x27;s config file (default: /etc/dhcp/dhcpd.conf).</span><br><span class="line">DHCPDv4_CONF=/etc/dhcp/dhcpd.conf</span><br><span class="line">DHCPDv6_CONF=/etc/dhcp/dhcpd6.conf</span><br><span class="line"></span><br><span class="line"># Path to dhcpd&#x27;s PID file (default: /var/run/dhcpd.pid).</span><br><span class="line">#DHCPDv4_PID=/var/run/dhcpd.pid</span><br><span class="line">#DHCPDv6_PID=/var/run/dhcpd6.pid</span><br><span class="line"></span><br><span class="line"># Additional options to start dhcpd with.</span><br><span class="line">#       Don&#x27;t use options -cf or -pf here; use DHCPD_CONF/ DHCPD_PID instead</span><br><span class="line">#OPTIONS=&quot;&quot;</span><br><span class="line"></span><br><span class="line"># On what interfaces should the DHCP server (dhcpd) serve DHCP requests?</span><br><span class="line">#       Separate multiple interfaces with spaces, e.g. &quot;eth0 eth1&quot;.</span><br><span class="line">INTERFACESv4=&quot;end0&quot;</span><br><span class="line">#INTERFACESv6=&quot;end0&quot;</span><br></pre></td></tr></table></figure><p>dhcp服务是由系统中的<code>/usr/sbin/dhcpd</code>这个文件提供的。与 isc-dhcp-server 功能相关的配置文件均在<code>/etc/dhcp/</code>目录中。IPV4和IPV6的 dhcp 配置分别在 <code>dhcpd.conf</code>和<code>dhcpd6.conf</code>中。一个示例配置文件如下，文件中只用到了最基础的配置，语法不是非常复杂。更多 dhcpd.conf 的配置详见本文下方参考文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"># dhcpd.conf</span><br><span class="line">#</span><br><span class="line"># Sample configuration file for ISC dhcpd</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># option definitions common to all supported networks...</span><br><span class="line">option domain-name &quot;debian02.redleaves.org&quot;;</span><br><span class="line">option domain-name-servers 192.168.0.1, 192.168.0.114;</span><br><span class="line"></span><br><span class="line">default-lease-time 600;</span><br><span class="line">max-lease-time 7200;</span><br><span class="line"></span><br><span class="line"># The ddns-updates-style parameter controls whether or not the server will</span><br><span class="line"># attempt to do a DNS update when a lease is confirmed. We default to the</span><br><span class="line"># behavior of the version 2 packages (&#x27;none&#x27;, since DHCP v2 didn&#x27;t</span><br><span class="line"># have support for DDNS.)</span><br><span class="line">ddns-update-style none;</span><br><span class="line"></span><br><span class="line"># If this DHCP server is the official DHCP server for the local</span><br><span class="line"># network, the authoritative directive should be uncommented.</span><br><span class="line">#authoritative;</span><br><span class="line"></span><br><span class="line"># Use this to send dhcp log messages to a different log file (you also</span><br><span class="line"># have to hack syslog.conf to complete the redirection).</span><br><span class="line">#log-facility local7;</span><br><span class="line"></span><br><span class="line"># No service will be given on this subnet, but declaring it helps the </span><br><span class="line"># DHCP server to understand the network topology.</span><br><span class="line"></span><br><span class="line">subnet 192.168.0.0 netmask 255.255.255.0 &#123;</span><br><span class="line">    range 192.168.0.2 192.168.0.240;</span><br><span class="line">    option broadcast-address 192.168.0.255;</span><br><span class="line">    option routers 0.0.0.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#subnet 10.152.187.0 netmask 255.255.255.0 &#123;</span><br><span class="line">#&#125;</span><br><span class="line"></span><br><span class="line"># This is a very basic subnet declaration.</span><br><span class="line"></span><br><span class="line">#subnet 10.254.239.0 netmask 255.255.255.224 &#123;</span><br><span class="line">#  range 10.254.239.10 10.254.239.20;</span><br><span class="line">#  option routers rtr-239-0-1.example.org, rtr-239-0-2.example.org;</span><br><span class="line">#&#125;</span><br><span class="line"></span><br><span class="line"># This declaration allows BOOTP clients to get dynamic addresses,</span><br><span class="line"># which we don&#x27;t really recommend.</span><br><span class="line"></span><br><span class="line">#subnet 10.254.239.32 netmask 255.255.255.224 &#123;</span><br><span class="line">#  range dynamic-bootp 10.254.239.40 10.254.239.60;</span><br><span class="line">#  option broadcast-address 10.254.239.31;</span><br><span class="line">#  option routers rtr-239-32-1.example.org;</span><br><span class="line">#&#125;</span><br><span class="line"></span><br><span class="line"># A slightly different configuration for an internal subnet.</span><br><span class="line">#subnet 10.5.5.0 netmask 255.255.255.224 &#123;</span><br><span class="line">#  range 10.5.5.26 10.5.5.30;</span><br><span class="line">#  option domain-name-servers ns1.internal.example.org;</span><br><span class="line">#  option domain-name &quot;internal.example.org&quot;;</span><br><span class="line">#  option routers 10.5.5.1;</span><br><span class="line">#  option broadcast-address 10.5.5.31;</span><br><span class="line">#  default-lease-time 600;</span><br><span class="line">#  max-lease-time 7200;</span><br><span class="line">#&#125;</span><br><span class="line"></span><br><span class="line"># Hosts which require special configuration options can be listed in</span><br><span class="line"># host statements.   If no address is specified, the address will be</span><br><span class="line"># allocated dynamically (if possible), but the host-specific information</span><br><span class="line"># will still come from the host declaration.</span><br><span class="line"></span><br><span class="line">#host passacaglia &#123;</span><br><span class="line">#  hardware ethernet 0:0:c0:5d:bd:95;</span><br><span class="line">#  filename &quot;vmunix.passacaglia&quot;;</span><br><span class="line">#  server-name &quot;toccata.example.com&quot;;</span><br><span class="line">#&#125;</span><br><span class="line"></span><br><span class="line"># Fixed IP addresses can also be specified for hosts.   These addresses</span><br><span class="line"># should not also be listed as being available for dynamic assignment.</span><br><span class="line"># Hosts for which fixed IP addresses have been specified can boot using</span><br><span class="line"># BOOTP or DHCP.   Hosts for which no fixed address is specified can only</span><br><span class="line"># be booted with DHCP, unless there is an address range on the subnet</span><br><span class="line"># to which a BOOTP client is connected which has the dynamic-bootp flag</span><br><span class="line"># set.</span><br><span class="line">#host fantasia &#123;</span><br><span class="line">#  hardware ethernet 08:00:07:26:c0:a5;</span><br><span class="line">#  fixed-address fantasia.example.com;</span><br><span class="line">#&#125;</span><br><span class="line"></span><br><span class="line"># You can declare a class of clients and then do address allocation</span><br><span class="line"># based on that.   The example below shows a case where all clients</span><br><span class="line"># in a certain class get addresses on the 10.17.224/24 subnet, and all</span><br><span class="line"># other clients get addresses on the 10.0.29/24 subnet.</span><br><span class="line"></span><br><span class="line">#class &quot;foo&quot; &#123;</span><br><span class="line">#  match if substring (option vendor-class-identifier, 0, 4) = &quot;SUNW&quot;;</span><br><span class="line">#&#125;</span><br><span class="line"></span><br><span class="line">#shared-network 224-29 &#123;</span><br><span class="line">#  subnet 10.17.224.0 netmask 255.255.255.0 &#123;</span><br><span class="line">#    option routers rtr-224.example.org;</span><br><span class="line">#  &#125;</span><br><span class="line">#  subnet 10.0.29.0 netmask 255.255.255.0 &#123;</span><br><span class="line">#    option routers rtr-29.example.org;</span><br><span class="line">#  &#125;</span><br><span class="line">#  pool &#123;</span><br><span class="line">#    allow members of &quot;foo&quot;;</span><br><span class="line">#    range 10.17.224.10 10.17.224.250;</span><br><span class="line">#  &#125;</span><br><span class="line">#  pool &#123;</span><br><span class="line">#    deny members of &quot;foo&quot;;</span><br><span class="line">#    range 10.0.29.10 10.0.29.230;</span><br><span class="line">#  &#125;</span><br><span class="line">#&#125;</span><br></pre></td></tr></table></figure><p>配置文件的语法如果不正确，后续执行<code>systemctl start</code>命令会执行错误。查看错误的方式：</p><ol><li>检查服务运行状态<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl status isc-dhcp-server</span><br><span class="line">× isc-dhcp-server.service - LSB: DHCP server</span><br><span class="line">    Loaded: loaded (/etc/init.d/isc-dhcp-server; generated)</span><br><span class="line">    Active: failed (Result: exit-code) since Sun 2024-12-29 01:45:41 CST; 34min ago</span><br><span class="line">    Docs: man:systemd-sysv-generator(8)</span><br><span class="line">    Process: 1233 ExecStart=/etc/init.d/isc-dhcp-server start (code=exited, status=1/FAILURE)</span><br><span class="line">        CPU: 97ms</span><br><span class="line"></span><br><span class="line">Dec 29 01:45:39 orangepizero3 dhcpd[1265]: bugs on either our web page at www.isc.org or <span class="keyword">in</span> the README file</span><br><span class="line">Dec 29 01:45:39 orangepizero3 dhcpd[1265]: before submitting a bug.  These pages explain the proper</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>检查错误日志详细信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ journalctl _PID=1265</span><br><span class="line">Dec 29 00:22:54 orangepizero3 dhcpd[1265]: Wrote 1 leases to leases file.</span><br><span class="line">Dec 29 00:22:54 orangepizero3 dhcpd[1265]: </span><br><span class="line">Dec 29 00:22:54 orangepizero3 dhcpd[1265]: No subnet declaration <span class="keyword">for</span> end0 (no IPv4 addresses).</span><br><span class="line">Dec 29 00:22:54 orangepizero3 dhcpd[1265]: ** Ignoring requests on end0.  If this is not what</span><br><span class="line">Dec 29 00:22:54 orangepizero3 dhcpd[1265]:    you want, please write a subnet declaration</span><br><span class="line">Dec 29 00:22:54 orangepizero3 dhcpd[1265]:    <span class="keyword">in</span> your dhcpd.conf file <span class="keyword">for</span> the network segment</span><br><span class="line">Dec 29 00:22:54 orangepizero3 dhcpd[1265]:    to <span class="built_in">which</span> interface end0 is attached. **</span><br><span class="line">Dec 29 00:22:54 orangepizero3 dhcpd[1265]: </span><br><span class="line">Dec 29 00:22:54 orangepizero3 dhcpd[1265]: </span><br><span class="line">Dec 29 00:22:54 orangepizero3 dhcpd[1265]: Not configured to listen on any interfaces!</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、配置系统网卡静态IP地址"><a href="#三、配置系统网卡静态IP地址" class="headerlink" title="三、配置系统网卡静态IP地址"></a>三、配置系统网卡静态IP地址</h2><p>我们可以看到上面的错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No subnet declaration <span class="keyword">for</span> end0 (no IPv4 addresses).</span><br></pre></td></tr></table></figure><p>当时我有一个疑问，我已经通过<code>NetworkManager</code>服务提供的<code>nmtui</code>向网卡<code>end0</code>分配了地址，为什么这条错误依旧会产生？通过分析和实验，发现原因可能是<code>NetworkManager</code>程序配置文件加载完成的时间比<code>dhcpd</code>启动的时间长。所以我应该直接在<code>/etc/network/interface</code>配置文件中加入以下内容指定网卡<code>end0</code>的静态 IP 地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto end0</span><br><span class="line">iface end0 inet static</span><br><span class="line">    address 192.168.0.1</span><br><span class="line">    netmask 255.255.255.0</span><br></pre></td></tr></table></figure><h2 id="四、启动并验证-DHCP-服务是否启动、"><a href="#四、启动并验证-DHCP-服务是否启动、" class="headerlink" title="四、启动并验证 DHCP 服务是否启动、"></a>四、启动并验证 DHCP 服务是否启动、</h2><p>完成上述步骤后，服务运行正常。可用下面的命令检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start isc-dhcp-server</span><br><span class="line">$ systemctl status isc-dhcp-server</span><br><span class="line">● isc-dhcp-server.service - LSB: DHCP server</span><br><span class="line">     Loaded: loaded (/etc/init.d/isc-dhcp-server; generated)</span><br><span class="line">     Active: active (running) since Sun 2024-12-29 02:34:01 CST; 16s ago</span><br><span class="line">       Docs: man:systemd-sysv-generator(8)</span><br><span class="line">    Process: 1251 ExecStart=/etc/init.d/isc-dhcp-server start (code=exited, status=0/SUCCESS)</span><br><span class="line">      Tasks: 1 (<span class="built_in">limit</span>: 4539)</span><br><span class="line">     Memory: 6.6M</span><br><span class="line">        CPU: 138ms</span><br><span class="line">     CGroup: /system.slice/isc-dhcp-server.service</span><br><span class="line">             └─1303 /usr/sbin/dhcpd -4 -q -cf /etc/dhcp/dhcpd.conf end0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后将服务添加到开机自启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> isc-dhcp-server</span><br><span class="line"><span class="comment"># 相对的，关闭自启动</span></span><br><span class="line"><span class="comment"># systemctl disable isc-dhcp-server</span></span><br></pre></td></tr></table></figure><p>自此，dhcp 功能配置完成。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://blog.csdn.net/qq_45042462/article/details/120230453">Debian10搭建dhcp服务</a></li><li><a href="https://www.cnblogs.com/wajika/p/6535175.html">linux中DHCP服务配置文件&#x2F;etc&#x2F;dhcpd.conf详细说明</a></li><li><a href="https://blog.csdn.net/bell_love/article/details/105680281">Debian的dhcp服务器安装、配置及启动失败问题</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络工程 </tag>
            
            <tag> dhcp </tag>
            
            <tag> Debian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由聚合的两种方法及原理</title>
      <link href="/2024/12/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5/net_01/"/>
      <url>/2024/12/25/%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5/net_01/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要路由聚合"><a href="#为什么需要路由聚合" class="headerlink" title="为什么需要路由聚合"></a>为什么需要路由聚合</h2><p>先说结论：<strong>减少路由表的条目</strong>。</p><p>路由器会查询路由表来决定如何转发到来的数据包，而路由器生成路由表的方法有静态和动态两种。一般来说，在一个比较复杂的网络中，我们会更倾向于使用动态路由的方式。这种方式虽然便于配置，但在一定程度上会带来路由表中信息的冗余。举例来说，如果一个用户拥有一个掩码为 24 位的网段 192.168.1.0&#x2F;24，而用户又将这个网段拆分成了 3 个 Vlan：192.168.1.0&#x2F;25，192.168.1.128&#x2F;26，192.168.1.192&#x2F;26，则 ospf 产生的动态路由表会包含这三个网段共三条路由信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Destination/Mask    Proto    Pre     Cost   Flags    NextHop       Interface</span><br><span class="line">192.168.1.0/25      ospf     10        1      D      10.0.1.1       GE0/0/1</span><br><span class="line">192.168.1.128/26    ospf     10        1      D      10.0.1.1       GE0/0/1</span><br><span class="line">192.168.1.192/26    ospf     10        1      D      10.0.1.1       GE0/0/1</span><br></pre></td></tr></table></figure><p>实际上，这三条信息可以合并为一条。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Destination/Mask    Proto    Pre     Cost   Flags    NextHop       Interface</span><br><span class="line">192.168.1.0/24      O_ASE    10       1       D      10.0.1.1       GE0/0/1</span><br></pre></td></tr></table></figure><p>一般来说，我们会在路由器上对发布路由的掩码位数进行限制来减少路由表条目。用户一般会被分配一个 24 位的地址，所以发布的掩码位数被限制在 24 位。在用户已拆分子网，且子网掩码均小于 24 位的情况下，路由聚合就是必须的。</p><h2 id="聚合方法一：ospf-abr-summary-汇总"><a href="#聚合方法一：ospf-abr-summary-汇总" class="headerlink" title="聚合方法一：ospf abr-summary 汇总"></a>聚合方法一：ospf abr-summary 汇总</h2><p>如果使用了 ospf 协议，那么可以在边界路由器配置 abr-summary 命令对当前路由表进行汇总。边界路由器是指一端连接骨干区域，一端连接非骨干区域的路由器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">area 1</span><br><span class="line">    abr-summary 192.168.1.0 255.255.255.0</span><br></pre></td></tr></table></figure><p>该方法的原理是：ospf 协议中，非骨干区域路由器与骨干区域路由器使用的是 LSA3 报文，此报文不像 LSA1,LSA2 一样传输链路状态信息，而是直接传输路由表，所以可以在此过程对路由表数据进行更改和汇总。汇总完成后，在骨干区域路由器上即可查询到汇总好的路由信息。必须发布 24 位掩码的限制条件也可以满足。</p><blockquote><p>注：ospf 同区域内的路由表是根据 LSA1 和 LSA2 计算的。同区域内交换的是链路状态信息。</p></blockquote><h2 id="聚合方法二：使用黑洞静态路由"><a href="#聚合方法二：使用黑洞静态路由" class="headerlink" title="聚合方法二：使用黑洞静态路由"></a>聚合方法二：使用黑洞静态路由</h2><p>这个方法比较取巧（tricky），但实践证明其确实有效，且无需划分骨干和非骨干区域。用户的网络结构如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- R1 -- R2 -- SW1</span><br></pre></td></tr></table></figure><p>路由器 R1 限制只向外发布 24 位的路由条目（假设 R1 与 R2 之外的路由器使用的不是 ospf，而是 IS-IS 协议）。<br>下面是 R2 的路由表中 ospf 的部分内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Destination/Mask    Proto    Pre     Cost   Flags    NextHop       Interface</span><br><span class="line">192.168.1.0/25      ospf     10        1      D      10.0.1.1       GE0/0/1</span><br><span class="line">192.168.1.128/26    ospf     10        1      D      10.0.1.1       GE0/0/1</span><br><span class="line">192.168.1.192/26    ospf     10        1      D      10.0.1.1       GE0/0/1</span><br></pre></td></tr></table></figure><p>我们必须让 R1 得到一个掩码为 24 位的路由条目。此时，我们可以在 R2 中配置一条如下的路由条目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route-static 192.168.1.0 255.255.255.0 NULL0</span><br></pre></td></tr></table></figure><p>然后将这条路由引入 ospf 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ospf 1</span><br><span class="line">    import-route static</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>此时，R2 的路由表如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Destination/Mask    Proto    Pre     Cost   Flags    NextHop       Interface</span><br><span class="line">192.168.1.0/25      ospf     10        1      D      10.0.1.1       GE0/0/1</span><br><span class="line">192.168.1.128/26    ospf     10        1      D      10.0.1.1       GE0/0/1</span><br><span class="line">192.168.1.192/26    ospf     10        1      D      10.0.1.1       GE0/0/1</span><br><span class="line">192.168.1.0/24      O_ASE    150       1      RD     NULL0          GE0/0/1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>ospf 链路信息随后传到 R1 路由器，路由器 R1 过滤掉掩码多于 24 位的路由条目，将其引入 IS-IS 协议。R1 路由表上的路由条目为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Destination/Mask    Proto    Pre     Cost   Flags    NextHop       Interface</span><br><span class="line">192.168.1.0/24      O_ASE    150       1      D      10.0.1.2       GE0/0/2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此时，向外发布 24 位掩码的限制条件已经满足。但数据包会正确传输到指定位置吗？答案是没问题的，可以正确传输。</p><p>首先考虑数据包从 SW1 传出的情况。</p><ol><li>SW1 查 ospf 路由表，查到去目的地的下一跳为 R2，然后数据包到达 R2。</li><li>R2 再查询 ospf 路由表，同理，数据包到达 R1。</li><li>R1 查询其路由表中 IS-IS 形成的条目，数据即可送到外部。</li></ol><p>然后考虑数据包从外部送到 SW1 的情况。</p><ol><li>R1 查询路由表，发现到<code>192.168.1.0/24</code>网段的路由的下一跳是 R2，于是将数据包送至 R2。</li><li>R2查询其路由表，由于路由表中，ospf 产生的路由优先级要高一些（Pre 的值小），R2 会先匹配 Pre 小的，也就是上面展示的 R2 路由表的前三条。所以，数据包被发送到 SW1 而不是 NULL0。</li><li>最终该数据包会被 SW1 传送到正确的位置。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.xh86.me/?p=6321">OSPF引入直连路由时巧借静态黑洞路由做汇总</a></li><li><a href="https://blog.csdn.net/qq_45443704/article/details/128533697">OSPF的三张表（邻居表、LSDB表、路由表）、LSA、LSDB、SPF与路由表之间的关联、OSPF建立的8种必要条件</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络工程 </tag>
            
            <tag> 路由器 </tag>
            
            <tag> 交换机 </tag>
            
            <tag> 路由聚合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 GDB 动态分析程序</title>
      <link href="/2024/12/18/Sharp%20Tools/gdb_summary/"/>
      <url>/2024/12/18/Sharp%20Tools/gdb_summary/</url>
      
        <content type="html"><![CDATA[<h2 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb ./program_name</span><br><span class="line">run <span class="comment"># 运行至断点所在位置</span></span><br></pre></td></tr></table></figure><p>分析前可以检查一下是否安装了 <code>libc6-dbg</code>，安装后对于<code>glibc</code>库的调试效果会更好。</p><h2 id="指定源码位置"><a href="#指定源码位置" class="headerlink" title="指定源码位置"></a>指定源码位置</h2><p>为了方便源码和汇编代码对照，可以指定源码位置，假如源码存在<code>/root/source</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加源码位置</span></span><br><span class="line"><span class="built_in">dir</span> /root/source</span><br><span class="line"><span class="comment"># 查看源码位置</span></span><br><span class="line">show <span class="built_in">dir</span></span><br><span class="line"><span class="comment"># 删除全部位置</span></span><br><span class="line"><span class="built_in">dir</span></span><br></pre></td></tr></table></figure><p>可以在用户家目录下建立一个<code>.gdbinit</code>的文件，把添加源码位置的命令写进去，这样 gdb 每次启动都会自动执行这条命令添加源码位置。</p><h2 id="断点相关操作"><a href="#断点相关操作" class="headerlink" title="断点相关操作"></a>断点相关操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b _start <span class="comment"># 在符号名下断点</span></span><br><span class="line">b *0x400580 <span class="comment"># 在内存空间对应的指令下断点</span></span><br><span class="line">(gdb) b src/main.cpp:5 <span class="keyword">if</span> cnt==10 <span class="comment"># 条件断点</span></span><br><span class="line"></span><br><span class="line">info breakpoints <span class="comment"># 查看所有断点列表</span></span><br><span class="line">delete 1 <span class="comment"># 删除断点列表编号为1的断点</span></span><br></pre></td></tr></table></figure><h2 id="打印变量"><a href="#打印变量" class="headerlink" title="打印变量"></a>打印变量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> /d[x,o] <span class="variable">$sp</span> <span class="comment"># 以10[或16,8]进制打印栈指针的值</span></span><br><span class="line"><span class="comment"># 打印栈顶的值(16进制)，注意打印 void* 类型的变量时，要强制转换。</span></span><br><span class="line"><span class="comment"># 直接打印会出现 Attempt to dereference a generic pointer. 的错误</span></span><br><span class="line"><span class="built_in">print</span> /x *(long*)<span class="variable">$sp</span> </span><br><span class="line"><span class="comment"># 打印从一个地址开始连续的 16 个值</span></span><br><span class="line"><span class="built_in">print</span> *(char*)(0xfffff7ffb202)@16</span><br><span class="line"></span><br><span class="line">display /i <span class="variable">$pc</span> <span class="comment"># 每次执行命令后都会打印 pc 对应的指令</span></span><br><span class="line">info display <span class="comment"># 查看所有自动 display 的项目</span></span><br><span class="line">undisplay 1 <span class="comment"># 删除自动 display 的项目中的一号项目</span></span><br><span class="line"></span><br><span class="line">disas <span class="comment"># 打印当前指令之后的 20 条指令</span></span><br><span class="line">disassemble 0x00402200, +16 <span class="comment"># 打印 0x00402200 之后的16字节指令，或使用 disassemble 0x00402200, 0x00402210。</span></span><br><span class="line">disas <span class="variable">$pc</span>, +20</span><br><span class="line"></span><br><span class="line">bt <span class="comment"># backtrace的简写，列出调用栈</span></span><br><span class="line"></span><br><span class="line">shell clear <span class="comment"># 清除屏幕显示内容</span></span><br></pre></td></tr></table></figure><h2 id="打印源码"><a href="#打印源码" class="headerlink" title="打印源码"></a>打印源码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list -n <span class="comment"># 显示行号</span></span><br><span class="line">list <span class="comment"># 继续打印</span></span><br><span class="line">list 5,10 <span class="comment"># 打印第5行到第10行的源码</span></span><br><span class="line">list + <span class="comment"># 打印下一个部分</span></span><br><span class="line">list -20 <span class="comment"># 打印上一个部分的代码，行数为20行</span></span><br></pre></td></tr></table></figure><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s <span class="comment"># 进入每个函数，调试每一行代码 （step into）</span></span><br><span class="line">n <span class="comment"># 跳过函数的内部，直接调试函数调用后的代码</span></span><br><span class="line">si <span class="comment"># 进入每个函数，调试每一条机器指令 （step into）</span></span><br><span class="line">ni <span class="comment"># 跳过函数的内部，直接调试函数调用后的机器指令 next</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">continue</span>  <span class="comment"># 继续执行程序，直到下一个断点或程序结束</span></span><br><span class="line">finish <span class="comment"># 当前函数执行到结束</span></span><br></pre></td></tr></table></figure><h2 id="输出文件"><a href="#输出文件" class="headerlink" title="输出文件"></a>输出文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> logging file &lt;filename&gt; <span class="comment"># 设置输出文件名</span></span><br><span class="line">(gdb) <span class="built_in">set</span> logging enabled on <span class="comment"># 此后的调试信息将输出到文件</span></span><br><span class="line">(gdb) <span class="built_in">set</span> logging enabled off</span><br><span class="line">(gdb) <span class="built_in">set</span> thread apply all bt <span class="comment"># 打印所有线程栈信息</span></span><br></pre></td></tr></table></figure><h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><h3 id="3-1-整齐打印"><a href="#3-1-整齐打印" class="headerlink" title="3.1 整齐打印"></a>3.1 整齐打印</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> pretty on <span class="comment"># 启用整齐打印</span></span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> pretty off <span class="comment"># 关闭整齐打印</span></span><br><span class="line">show <span class="built_in">print</span> pretty <span class="comment"># 查看整齐打印状态</span></span><br></pre></td></tr></table></figure><p>还有一些打印设置，与上面相同</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show <span class="built_in">print</span> address</span><br><span class="line">Printing of addresses is on.</span><br><span class="line">(gdb) show <span class="built_in">print</span> array</span><br><span class="line">Pretty formatting of arrays is off.</span><br><span class="line">(gdb) show <span class="built_in">print</span> elements</span><br><span class="line">Limit on string chars or array elements to <span class="built_in">print</span> is 200.</span><br><span class="line">(gdb) show <span class="built_in">print</span> union</span><br><span class="line">Printing of unions interior to structures is on.</span><br></pre></td></tr></table></figure><h3 id="3-2-layout-模式"><a href="#3-2-layout-模式" class="headerlink" title="3.2 layout 模式"></a>3.2 layout 模式</h3><p>layout：用于分割窗口，可以一边查看代码，一边测试。主要有以下几种用法：</p><p>layout src：显示源代码窗口</p><p>layout asm：显示汇编窗口</p><p>layout regs：显示源代码&#x2F;汇编和寄存器窗口</p><p>layout next：显示下一个layout</p><p>layout prev：显示上一个layout</p><p><code>Ctrl + L</code>：刷新窗口</p><p><code>Ctrl + x</code>，再按<code>1</code>：单窗口模式，显示一个窗口</p><p><code>Ctrl + x</code>，再按<code>2</code>：双窗口模式，显示两个窗口</p><p>layout asm ：在上方显示编辑器窗口<br><code>Ctrl + x</code>，再按<code>a</code> ：回到传统模式，即退出layout，回到执行layout之前的调试窗口。 </p><p>info win 查看窗口状态<br>fs prev 切换上一个窗口<br>fs next 切换下一个窗口</p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
            <tag> gdb </tag>
            
            <tag> 调试工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开启并操作orangePi的i2c外设</title>
      <link href="/2024/12/07/EE%20and%20SoC/%E6%93%8D%E4%BD%9CorangePi%E7%9A%84i2c%E5%A4%96%E8%AE%BE/"/>
      <url>/2024/12/07/EE%20and%20SoC/%E6%93%8D%E4%BD%9CorangePi%E7%9A%84i2c%E5%A4%96%E8%AE%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="安装操作系统"><a href="#安装操作系统" class="headerlink" title="安装操作系统"></a>安装操作系统</h2><p>本次我使用的是 Orange Pi Zero3 这款开发板，这款开发板的 CPU 是 arm 架构的全志 H618，使用 Cortex-A53 架构，板上配置 4GB 内存和相当数量的外设，价格适中。</p><p>按照官方文档，烧录官方修改后的 armbian <a href="https://github.com/leeboby/armbian-images?tab=readme-ov-file">镜像</a>，然后使用 dd 命令烧录 boot，替换<a href="https://github.com/leeboby/opizero3-uboot-dtb?tab=readme-ov-file">设备树</a>，镜像就可以正常使用了。具体操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压</span></span><br><span class="line">xz -dk Armbian_23.08.0-trunk_Orangepizero3_bookworm_current_6.1.31_xfce_desktop-1GB-2GB.img.xz</span><br><span class="line"><span class="comment"># 烧录（使用 balena-etcher 或 dd 命令，使用 dd 命令可能会烧录失败，balena-etcher 比较稳定）</span></span><br><span class="line"><span class="built_in">sudo</span> ./balena-etcher-electron</span><br><span class="line"><span class="comment"># 安装设备树（选择对应 4GB 内存的设备树）</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> sun50i-h616-orangepi-zero3-4gb.dtb /media/redleaves/armbi_root/boot/dtb/allwinner/sun50i-h616-orangepi-zero3.dtb</span><br><span class="line"><span class="comment"># 烧录 u-boot</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">dd</span> bs=1k seek=8 <span class="keyword">if</span>=u-boot-sunxi-with-spl-opizero3-4gb.bin of=/dev/sda</span><br></pre></td></tr></table></figure><p>复制完镜像后，根目录的空间只有5.8G，如果使用大容量磁盘需要扩容，至少16G。</p><p>使用时发现系统的 wifi 功能不好用，即使输入正确的密码仍然会显示连接失败，需要使用串口或桌面模式配置有线网络（或使用手机的 usb 共享网络功能）。可以使用基于命令行的<code>nmcli</code>命令，不过，如果安装了<code>nmcli</code>，一般来说，终端图形化的<code>nmtui</code>命令也会安装，使用这个命令更加直观方便，注意运行此命令需要 root 权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmtui</span><br></pre></td></tr></table></figure><p>然后重新安装新版固件包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install armbian-firmware</span><br></pre></td></tr></table></figure><p>如果安装速度慢，可以手动更换软件源为清华源或中科大源。注意安装好系统后，不要使用<code>apt upgrade</code>大更新，系统桌面模式会无法启动。请一定要按需进行更新。</p><h2 id="安装交叉编译工具链"><a href="#安装交叉编译工具链" class="headerlink" title="安装交叉编译工具链"></a>安装交叉编译工具链</h2><p>进入 arm developer <a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">官网</a>，下载最新的工具链编译产物或源代码。源代码的编译方式在 arm developer 上有详细介绍，这里直接下载 x86-64 架构下 Linux 系统的工具链，然后将其解压至指定文件夹并添加环境变量。这样我们就可以在终端中直接使用工具链的组件了。在终端中输入以下命令验证工具链已经成功安装，如果成功安装，将输出版本信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-gcc --version</span><br></pre></td></tr></table></figure><p>不同于我之前入手的 milkv-duo 开发板，这款开发板的硬件限制比较少，这使得这块板能够运行功能更多，更加复杂的操作系统。板上的操作系统包含的程序解释器可以适配官方的工具链，而无需在交叉编译工具上使用其他的编译选项。开发复杂度降低不少。</p><h2 id="打开系统的外设"><a href="#打开系统的外设" class="headerlink" title="打开系统的外设"></a>打开系统的外设</h2><p>输入<code>ls -l /dev</code>命令，发现系统显示的外设数量少于开发板实际的外设数量，比如说系统引脚图上标注的 I2C3 就没有开启。为了开启指定的外设，需要输入<code>sudo armbian-config</code>命令进入系统配置模块（这是一个在 bash 中“图形化”的界面），进入<code>system-&gt;Hardware</code>单元，这样就可以开启隐藏的外设。注意开启 I2C3 后，原有的 I2C0 和 I2C1 会依次转变为 I2C4 和 I2C5。原因暂时不明，不过并不影响使用。注意，选项之间可能产生冲突，开启外设时要结合引脚图检查冲突。如果发生冲突，会导致在所有引脚冲突的外设中，只有一个外设能够启用。</p><p>修改结束后，重新启动系统，配置即可生效。</p><h2 id="使用SHTC3温度传感器"><a href="#使用SHTC3温度传感器" class="headerlink" title="使用SHTC3温度传感器"></a>使用SHTC3温度传感器</h2><p>SHTC3 是一款高精度的温湿度传感器，它使用的通信协议正是 I2C 总线协议。我将利用 Orange Pi Zero3 上的 I2C3 外设向其发送测量指令并读取其测量数据。首先，将 SHTC3 的四个引脚连接到对应的位置。然后，使用 armbian 系统上的 i2c 工具包检查 SHTC3 是否在 I2C3 上，操作方式及输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出 i2c3 上所有设备的地址</span></span><br><span class="line">i2cdetect -y 3</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f</span><br><span class="line">00:                         -- -- -- -- -- -- -- -- </span><br><span class="line">10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- </span><br><span class="line">20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- </span><br><span class="line">30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- </span><br><span class="line">40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- </span><br><span class="line">50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- </span><br><span class="line">60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- </span><br><span class="line">70: 70 -- -- -- -- -- -- --                         </span><br></pre></td></tr></table></figure><p>SHTC3 的数据手册上明确了设备地址为 0x70，所以 SHTC3 设备存在在总线 I2C3 上。</p><p>如果SHTC3 设备存在在总线 I2C3 上，由于 Linux 内核“一切皆文件的特点”，我们可以通过操作系统的设备文件<code>/dev/i2c-3</code>实现收发总线 I2C3 上的数据（参考 Advance Programming in the Unix Environment 这本书）。</p><p>阅读 SHTC3 的数据手册，通过手册上给定的示意图，了解到一次测量过程包括唤醒，发送测量指令，开始测量，等待测量结果和睡眠共五个阶段。根据这五个阶段，向 I2C3 总线发送对应的指令，再根据手册设定好等待 SHTC3 相应指令和程序接收测量结果需等待的时间，即可获取 SHTC3 一次测量的返回结果。具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filename: rwi2c.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c-dev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHTC3_DEVICE <span class="string">&quot;/dev/i2c-3&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHTC3_ADDRESS 0x70</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_LENGTH 8</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Measure_TH</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> time_interval_s)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> rd_buf[CMD_LENGTH];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> wr_buf[CMD_LENGTH];</span><br><span class="line">    <span class="built_in">memset</span>(rd_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(rd_buf));</span><br><span class="line">    <span class="built_in">memset</span>(wr_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(wr_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wake up the SHTC3 device.</span></span><br><span class="line">    wr_buf[<span class="number">0</span>] = <span class="number">0xE0</span>;</span><br><span class="line">    write(fd, wr_buf, <span class="number">1</span>);</span><br><span class="line">    usleep(<span class="number">400</span>); <span class="comment">// delay 400us</span></span><br><span class="line"></span><br><span class="line">    wr_buf[<span class="number">0</span>] = <span class="number">0x35</span>;</span><br><span class="line">    wr_buf[<span class="number">1</span>] = <span class="number">0x17</span>;</span><br><span class="line">    write(fd, wr_buf, <span class="number">2</span>);</span><br><span class="line">    usleep(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write measure command.</span></span><br><span class="line">    wr_buf[<span class="number">0</span>] = <span class="number">0xE0</span>;</span><br><span class="line">    write(fd, wr_buf, <span class="number">1</span>);</span><br><span class="line">    usleep(<span class="number">400</span>); <span class="comment">// delay 400us</span></span><br><span class="line"></span><br><span class="line">    wr_buf[<span class="number">0</span>] = <span class="number">0x5c</span>;</span><br><span class="line">    wr_buf[<span class="number">1</span>] = <span class="number">0x24</span>;</span><br><span class="line">    write(fd, wr_buf, <span class="number">2</span>);</span><br><span class="line">    usleep(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use read command to start measurement process.</span></span><br><span class="line">    read(fd, rd_buf, <span class="number">1</span>);</span><br><span class="line">    usleep(<span class="number">1000</span> * <span class="number">20</span>); <span class="comment">// delay 20ms to finish the measurement procedure.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the return value of measurement.</span></span><br><span class="line">    read(fd, rd_buf, <span class="number">6</span>);</span><br><span class="line">    usleep(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%x &quot;</span>, rd_buf[i]);</span><br><span class="line">    &#125;<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate the Humidity and tempature.</span></span><br><span class="line">    <span class="type">double</span> S_RH = (rd_buf[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) + rd_buf[<span class="number">1</span>];</span><br><span class="line">    <span class="type">double</span> S_T = (rd_buf[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) + rd_buf[<span class="number">4</span>];</span><br><span class="line">    <span class="type">double</span> Humidity = <span class="number">100.0</span> * S_RH  /  (<span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line">    <span class="type">double</span> Tempature = <span class="number">-45.0</span> + <span class="number">175</span> * S_T / (<span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Humidity = %.2f%%, Tempature = %.2fC.\n&quot;</span>, Humidity, Tempature);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// let SHT3C device sleep to save the power.</span></span><br><span class="line">    wr_buf[<span class="number">0</span>] = <span class="number">0xE0</span>;</span><br><span class="line">    write(fd, wr_buf, <span class="number">1</span>);</span><br><span class="line">    usleep(<span class="number">400</span>); <span class="comment">// delay 400us</span></span><br><span class="line"></span><br><span class="line">    wr_buf[<span class="number">0</span>] = <span class="number">0xB0</span>;</span><br><span class="line">    wr_buf[<span class="number">1</span>] = <span class="number">0x98</span>;</span><br><span class="line">    write(fd, wr_buf, <span class="number">2</span>);</span><br><span class="line">    usleep(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// time_interval</span></span><br><span class="line">    sleep(time_interval_s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;SHTC3 Temperature Sensor Driver. Starting...&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(SHTC3_DEVICE, O_RDWR)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Open &quot;</span>SHTC3_DEVICE<span class="string">&quot; Failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, I2C_SLAVE_FORCE, SHTC3_ADDRESS) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Set SHTC3_ADDRESS 0x%x Failed.\n&quot;</span>, SHTC3_ADDRESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        Measure_TH(fd, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序在 x86-64 Linux 编写完成后，使用下列命令进行编译，传送到开发板上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aarch64-none-linux-gnu-gcc rwi2c.c -o rwi2c.arm</span><br><span class="line">scp rwi2c.arm root@192.168.0.1:~/programs</span><br></pre></td></tr></table></figure><p>注意读取 I2C 设备需要 root 权限，所以我传入 root 的 home 目录中。运行程序，发现温度和湿度都可以正常显示了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./rwi2c.arm</span><br><span class="line">SHTC3 Temperature Sensor Driver. Starting...</span><br><span class="line">0x6e 0xf9 0xb3 0x65 0xa 0x78 </span><br><span class="line">Humidity = 43.35%, Tempature = 24.07C.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于系统已经实现了 I2C 硬件驱动， 所以 Linux 使用外设（如I2C）比起单片机容易多了。无论什么硬件，只要驱动存在，在软件层面（如本文的 SHTC3 驱动）只要使用<code>read,write,ioctl</code>这些统一的接口就可以了。大大增加了软件的可移植性。这也是我第一次在 Linux 系统上编写 SHTC3 的软件驱动程序，不过，或许称作上位机程序更恰当些。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Advance Programming in the Unix Environment : Chapter 03<br><a href="http://www.orangepi.cn/html/hardWare/computerAndMicrocontrollers/details/Orange-Pi-Zero-3.html">Orange Pi Zero3</a><br><a href="https://uniondong.github.io/docs/linux/linux_driver_develop_basic/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82linux%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/">【一文秒懂】Linux设备树详解 </a><br><a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">Arm GNU Toolchain Downloads</a><br><a href="http://www.b7.net.cn/archives/31.html">Armbian下驱动各种rtl无线网卡驱动 </a><br><a href="https://blog.csdn.net/Running_free/article/details/103901199">Orangepi切换国内源以及spi使能问题</a><br><a href="https://github.com/leeboby/raspberry-pi-os-images/issues/10">Enable i2c3 and&#x2F;or implement orangepi-config?</a><br><a href="https://sensirion.com/cn/products/product-catalog/SHTC3">SHTC3</a><br><a href="https://blog.csdn.net/mj475002864/article/details/114027993">温湿度传感器SHTC3驱动开发（一）小白也能轻松理解</a><br><a href="https://blog.csdn.net/weixin_55023180/article/details/126631452">学习笔记4 orangepi的i2c和oled屏幕显示</a></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 交叉编译 </tag>
            
            <tag> SoC </tag>
            
            <tag> arm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Milkv-duo 开发板上运行程序</title>
      <link href="/2024/11/30/EE%20and%20SoC/milkv-duo-start/"/>
      <url>/2024/11/30/EE%20and%20SoC/milkv-duo-start/</url>
      
        <content type="html"><![CDATA[<h2 id="0-和RISC-V的故事"><a href="#0-和RISC-V的故事" class="headerlink" title="0.和RISC-V的故事"></a>0.和RISC-V的故事</h2><h3 id="0-1-了解RISC-V并编写一个简单RISCV-CPU"><a href="#0-1-了解RISC-V并编写一个简单RISCV-CPU" class="headerlink" title="0.1 了解RISC-V并编写一个简单RISCV-CPU"></a>0.1 了解RISC-V并编写一个简单RISCV-CPU</h3><p>在上大学时，我们计科专业有一门必修课，叫做计算机系统设计。刚刚上这门课时，我还对 RISC-V 完全没有概念。这门课没有指定的教材，只有老师做的用 A4 纸打印的实验指导，和一本北航出版社的 Verilog 程序设计作为参考。上课之前，给我们发了一个 Xlinix FPGA 的开发板。当时的我只听说过单片机，不知道 FPGA 是什么。第一节课，懵懵懂懂的做了一个流水灯的实验，认为 FPGA 这东西和单片机功能上并没有什么差别，也并不懂老师说的 FPGA 编程是纯硬件而不是软件编程是什么意思，这个全新的概念来的太突然，一时间还有点接受不了。之后就一直带着这个疑惑度过了很多节课和很多次实验。</p><p>离课程结束大概五节课左右，老师公布了最后一个实验题目：实现一个支持基本 RISC-V 指令的 CPU。当时我非常惊讶，因为在我这个大二计算机系学生的视角里，CPU 仍然是一大堆复杂电路构成的复杂系统，应该是我们当前水平还不能触及的领域才对。不过，经过之前的学习，我觉得老师布置这个任务应该是我力所能及的，于是我开始了我人生中第一个 CPU 的设计工作。</p><p>这个课程的正课从8月中旬开始，9月初就结束了。但是从完全不理解 FPGA 的概念，到学会 Verilog 设计语言，在到设计一个 CPU 花费的时间，远远超过半个月。在设计的时候，我遇到过很多的错误，尤其是在深夜，因为语言不熟悉导致连续好多次遇到 99+ 个错误和警告时，因为程序不按预期运行时，代码运行崩溃，人的精神也崩溃了。我上网搜集了很多资料，打印了一份 RISC-V 的标准指令集，每次有空时就拿出来看看，想想代码怎么实现，如果想好就在纸上做上标注，实现完就打一个勾。国庆之后，我实现了 CPU 中的基本器件和所有指令，纸上也被勾满了。但这时，另一个棘手的问题出现了，就是流水线。我实现了大约40条指令，就算实现二级流水线，也需要考虑大量指令冲突的情况。我曾经考虑过列出所有情况，但因为太复杂，又放弃了。</p><p>我所就读的学校，在整个大三阶段的排课是非常不合理的，在8月和10月两个半月时间，要上完9门课并考试。除去上课之外，需要强制性保证规律作息，需要强制保证每天2小时的运动时间，还要忍受休息时间被各种活动强制占用，自己的时间很少。最后，直到课程作业验收，我也没有考虑过流水线的事情。这是我在大三时留下的第一个遗憾，这个遗憾，我总想填上它，但没有时间，没有机会，自身也没有继续的动力。慢慢的，课程结束，时光飞逝，忙碌的大学生活如同阵阵浪花，冲散了写在记忆沙滩上的文字。</p><p>这就是2021年秋天，我使用 Verilog 语言设计了一个支持 RISC-V 基础指令的简单CPU的故事。非常不成熟的代码（可能有一些位置bug）在<a href="https://github.com/RedLeaves699/Multi-Cycle-CPU">这里</a>可以找到。</p><h3 id="0-2-重新开始RISC-V研究"><a href="#0-2-重新开始RISC-V研究" class="headerlink" title="0.2 重新开始RISC-V研究"></a>0.2 重新开始RISC-V研究</h3><p>2023年10月份左右，我重新想起了 RISC-V ，想深入研究一下基于 RISC-V 的产品，所以对 RISC-V 开发板产生了兴趣。于是上网搜索，找到了 milkv-duo 这个能够运行 SoC 的小巧的开发板（当然，也因为它当时只卖35块钱）。于是购买两块板和 IO 扩展，正式开始研究。买回开发板后，因工作繁忙，这两块板一直在箱子里吃灰。最近整理物品时发现了它们，遂继续深入研究一番。</p><h2 id="1-最初的工作"><a href="#1-最初的工作" class="headerlink" title="1.最初的工作"></a>1.最初的工作</h2><h3 id="1-1-烧录"><a href="#1-1-烧录" class="headerlink" title="1.1 烧录"></a>1.1 烧录</h3><p>本文不会介绍裸机编程。我们将把 milkv-duo 官方镜像烧录到开发板中，并使用串口或网络连接到 milkv-duo 以控制系统。在此基础上，在本地构建交叉编译环境，使得我们能够编写在官方镜像上运行的程序。这个板子可用资料也比较少（比起树莓派，Arduino之类的），如果想要充分了解，需要自己收集很多东西。</p><p>烧录系统镜像的过程暂且略去，官网上已有介绍。如果烧录的系统运行成功，板子上蓝灯会不停闪烁。</p><h3 id="1-2-终端连接milkv-duo上的操作系统"><a href="#1-2-终端连接milkv-duo上的操作系统" class="headerlink" title="1.2 终端连接milkv-duo上的操作系统"></a>1.2 终端连接milkv-duo上的操作系统</h3><p>如果仅使用原开发板，按照官网教程操作即可。USB连接即可获取网络</p><p>如果使用串口终端需要注意，如果使用了 IO 板，4针接口靠近网口第一针为 GND引脚，第二针为 RXD 引脚，第三针为 TXD 引脚，第四针为 5v&#x2F;3v3 引脚，第四针接 5v 可以为整个系统供电，接 3v3 系统不能正常启动，但板上红灯亮。如果不使用 IO 板，需要自己根据官网上的引脚图焊接引脚。</p><p>另外，如果为 milkv-duo 安装了 IO 板，直接使用 RJ45 接头网线网口，即使此时计算机与 192.168.42.1 在同一网段，也是无法连接上的。使用串口终端输入命令<code>ip address show</code>查看 eth0 的ip地址配置，发现是一个 169 开头的地址，usb0 网卡的地址才是 192.168.42.1。这说明 IO 板网口对应网卡的名称为 eth0,而 usb 网口对应的网卡名称为 usb0，但 usb0 因 IO 板的存在无法使用了。此时有两种解决方案：</p><ol><li><p>使用串口配置网卡 eth0 的 ip 地址。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr add 192.168.42.12/24 dev eth0 <span class="comment"># 设置eth0网卡IP地址192.168.42.12</span></span><br></pre></td></tr></table></figure></li><li><p>如果想永久更改设置，可以修改 milkv-duo 系统中的 <code>/etc/dhcpcd.conf</code>文件达到为 eth0 网卡设置永久ip的效果。</p><p> 修改如下（<code>/etc/dhcpcd.conf</code>）：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Persist interface configuration when dhcpcd exits.</span></span><br><span class="line">persistent</span><br><span class="line"></span><br><span class="line">interface eth0</span><br><span class="line">static ip_address=192.168.42.12/24</span><br><span class="line">static routers=192.168.42.12</span><br><span class="line">static domain_name_servers=192.168.42.12 8.8.8.8 1.1.1.1 114.114.114.114</span><br></pre></td></tr></table></figure></li></ol><p>此时即可通过本机终端进入 milkv-duo 操作系统。</p><blockquote><p>本篇内容参考以下链接：<br>使用IO底板时的注意事项：<a href="https://milkv.io/zh/docs/duo/io-board/usb-ethernet-iob">https://milkv.io/zh/docs/duo/io-board/usb-ethernet-iob</a><br>使用usb口登录注意事项：<a href="https://milkv.io/zh/docs/duo/getting-started/setup">https://milkv.io/zh/docs/duo/getting-started/setup</a><br>使用网口登录注意事项：<a href="https://forum.sophgo.com/t/ssh-milkv-duo-ip/253">https://forum.sophgo.com/t/ssh-milkv-duo-ip/253</a></p></blockquote><h2 id="2-构建交叉编译环境工具"><a href="#2-构建交叉编译环境工具" class="headerlink" title="2.构建交叉编译环境工具"></a>2.构建交叉编译环境工具</h2><h3 id="2-1-编译工具链"><a href="#2-1-编译工具链" class="headerlink" title="2.1 编译工具链"></a>2.1 编译工具链</h3><p>我使用的操作系统环境为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">uname</span> -a</span><br><span class="line">Linux debian 6.1.0-28-amd64 <span class="comment">#1 SMP PREEMPT_DYNAMIC Debian 6.1.119-1 (2024-11-22) x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure><p>将基于如下的 GCC 版本构建交叉编译工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc --version</span><br><span class="line">gcc (Debian 12.2.0-14) 12.2.0</span><br><span class="line">Copyright (C) 2022 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><p>首先从 riscv 工具链官网下载官方工具链。使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/riscv/riscv-gnu-toolchain</span><br></pre></td></tr></table></figure><p>官方工具链有很多子模块，如果只使用这条语句，下载内容不全，还需要使用下面的命令更新子模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>如果更新的速度很慢（我在这里花费了一下午加一晚上时间，晚上下载子模块时才想到换源），可以进入<code>.gitmodules</code>文件中修改子模块 url,或者直接拉取<a href="https://gitee.com/mirrors/riscv-gnu-toolchain">gitee镜像</a>或<a href="https://help.mirrors.cernet.edu.cn/riscv-toolchains">中科院镜像</a>。</p><p>下载快要完成的时候，一个 qemu 的子模块会提示需要输入 github 账号密码进行身份验证。不需要验证，这个模块我们也不需要，因为 qemu 移除了这个模块。<code>ctrl+c</code> 或三次验证失败后结束即可。</p><p>在集齐全部的模块后，就可以开展编译的工作。编译使用 <code>configure + make</code> 的形式。首先先编译基于 newlib 的 RISC-V 裸机运行编译器。编译命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立存放编译产物目录</span></span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line"><span class="comment"># 配置编译最终结果安装路径，允许使用 multilib（仅gnu支持，musl默认关闭此选项）</span></span><br><span class="line">../configure --prefix=/opt/riscv64 --enable-multilib --target=riscv64-linux-multilib</span><br><span class="line"><span class="comment"># 使用16线程编译（使用sudo保证非root也能读写/opt/riscv64目录）</span></span><br><span class="line"><span class="built_in">sudo</span> make -j16</span><br></pre></td></tr></table></figure><p>因为 milkv-duo 使用的操作系统支持的运行库为 musl 所以我们再编译 musl 的交叉编译工具链：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清除之前的编译产物</span></span><br><span class="line"><span class="built_in">sudo</span> make distclean</span><br><span class="line"><span class="comment"># 使用16线程编译</span></span><br><span class="line"><span class="built_in">sudo</span> make musl -j16</span><br></pre></td></tr></table></figure><h3 id="2-2-使用工具链编译用户程序"><a href="#2-2-使用工具链编译用户程序" class="headerlink" title="2.2 使用工具链编译用户程序"></a>2.2 使用工具链编译用户程序</h3><p>这次用作示例的用户程序是一个简单的<code>hello world</code>程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写好程序后，就可以使用 musl 工具链编译程序，然后使用 scp 命令传入 milkv-duo 的操作系统了，注意，scp 必须添加 <code>-O</code> 选项确保与 milkv-duo 操作系统搭载的 dropbear 兼容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">riscv64-unknown-linux-musl-gcc hello.c -o hello</span><br><span class="line">scp -O hello  root@192.168.0.45:/root</span><br></pre></td></tr></table></figure><h3 id="2-3-程序不能运行，怎么办"><a href="#2-3-程序不能运行，怎么办" class="headerlink" title="2.3 程序不能运行，怎么办"></a>2.3 程序不能运行，怎么办</h3><p>写入后，发现 hello 没法运行，报错<code>-sh: ./hello not found</code>。这表示我们编译器生成的文件不是可运行的，这多半是 <code>execve</code> 对可执行文件的文件头处理有问题。在本机使用下面的命令查看文件头：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">riscv64-unknown-linux-musl-readelf -l hello</span><br></pre></td></tr></table></figure><p>输出如下，发现其需要的动态加载器（program interpreter）为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                ......</span><br><span class="line">INTERP          0x0000000000000238 0x0000000000010238 0x0000000000010238</span><br><span class="line">                0x000000000000001a 0x000000000000001a   R      0x1</span><br><span class="line">      [Requesting program interpreter: /lib/ld-musl-riscv64.so.1]</span><br><span class="line">RISCV_ATTRIBUT  0x000000000000104a 0x0000000000000000 0x0000000000000000</span><br><span class="line">                0x0000000000000066 0x0000000000000000   R      0x1</span><br><span class="line">                ......</span><br></pre></td></tr></table></figure><p>从milkv-duo 上提取一个可执行文件，发现 milkv-duo 操作系统的动态加载器为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                ......</span><br><span class="line">[Requesting program interpreter: /lib/ld-musl-riscv64v0p7_xthead.so.1]</span><br><span class="line">                ......</span><br></pre></td></tr></table></figure><p>所以只需在编译时，使用如下参数指定动态加载器（program interpreter），程序就可以在 milkv-duo 上运行了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">riscv64-unknown-linux-musl-gcc hello.c -o hello -Wl,-dynamic-linker,/lib/ld-musl-riscv64v0p7_xthead.so.1</span><br></pre></td></tr></table></figure><p>如果没有可执行文件的源码，或不想重新编译程序，也可以使用下面的命令修改程序的动态加载器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-interpreter /lib/ld-musl-riscv64v0p7_xthead.so.1 hello</span><br></pre></td></tr></table></figure><p>也可以在<code>/lib</code>目录中创建软连接，令<code>/lib/ld-musl-riscv64.so.1 -&gt; /lib/ld-musl-riscv64v0p7_xthead.so.1</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /lib/ld-musl-riscv64v0p7_xthead.so.1 /lib/ld-musl-riscv64.so.1</span><br></pre></td></tr></table></figure><h3 id="2-4-其他处理"><a href="#2-4-其他处理" class="headerlink" title="2.4 其他处理"></a>2.4 其他处理</h3><p>C906 芯片使用的指令集为：rv64gc_xthead。GNU GCC 在 2022 年年底增加了对 C906 xthead 扩展的支持，所以我们可以在编译器中使用<code>-mcpu=thead-c906</code>生成支持 xthead 指令的代码。</p><p>为了避免计算机上系统原有库对工具链造成的影响，可以在编译时指定使用的头文件，依赖库等，编译器需要输入的具体编译参数可以参看 <a href="https://github.com/milkv-duo/duo-examples">milkv-duo 官方示例</a>每个示例的Makefile：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-I/opt/riscv64-musl/sysroot/usr/include \</span><br><span class="line"></span><br><span class="line">-L/opt/riscv64-musl/sysroot/lib \</span><br><span class="line">-L/opt/riscv64-musl/sysroot/usr/lib</span><br></pre></td></tr></table></figure><p>不过这种问题大多不必担心，因为编译时已指定<code>sysroot</code>的位置<code>--with-sysroot=/opt/riscv64-musl/sysroot</code>。</p><p>在程序编译通过和在 milkv-duo 上运行成功的基础上，可加入如下参数实现大文件编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64</span><br></pre></td></tr></table></figure><p>为使程序可以处理大文件的能力，在gcc编译时，加入的大文件(大于2G)支持参数：<code>-D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE</code>。这些编译参数让编译后的程序支持64bit的系统调用操作，从而是程序处理没有2G文件的限制。</p><p>自此，我们就依托官方 riscv-gnu-toolchain 提供的交叉编译工具链，编写出了能够在 milkv-duo 系统上运行的程序。</p><p>之所以未直接使用玄铁 fork 的 riscv-gnu-toolchain，是因为虽然能够开箱即用，但可能在我心中，这种定制不太标准，未来更换其他处理器时可能有不兼容的地方。毕竟 RISC-V 处理器厂家不少。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>折腾这个问题，又花费了三天的时间，算上今天写博客已经花费了四天时间。工作之余，我将时间全部投入在折腾上面的问题上，不过还好，通过不断查资料，搜索，终于进一步了解了手头上的这块开发板、CV1800B 和 C906、RISC-V 应用层架构，和日益发展的 RISC-V 生态。</p><p>临近2024年底，RISC-V 的生态正在肉眼可见的变好。作为一款开源指令集，我比较看好它的未来，PC 时代 intel 独占鳌头，移动时代 arm 一家独大，IoT 时代，RISC-V 能否成为后起之秀呢？</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h2><blockquote><p><a href="https://www.runoob.com/linux/linux-comm-ip.html">IP命令</a><br><a href="https://www.cnblogs.com/sxrxlnss/articles/16477694.html">自定义ELF程序的动态加载器(program interpreter)</a><br><a href="https://blog.csdn.net/qq_41683305/article/details/105375214">objdump命令</a><br><a href="https://blog.csdn.net/yfldyxl/article/details/81566279">readelf命令</a><br><a href="https://redleaves699.github.io/2021/09/09/apps/Operating%20System/Educoder%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%AE%AD2.x/">gdb调试</a><br><a href="https://github.com/riscv-collab/riscv-gnu-toolchain">RISCV-gnu-Toolchain</a><br><a href="https://www.cnblogs.com/lvzh/p/17892179.html">riscv gnu编译器</a><br><a href="https://www.cnblogs.com/maomaotou-thu/p/17765721.html#%E6%89%8B%E5%8A%A8%E5%90%88%E6%88%90fipbin%E5%92%8Cbootsd">milkv-duo启动流程分析：手动构建fip.bin</a><br><a href="https://milkv.io/zh/docs/duo/io-board/usb-ethernet-iob">Duo IOB</a><br><a href="https://soc.ustc.edu.cn/CECS/lab0/riscv/">USTC CECS 2023 - 安装 RISC-V 交叉编译工具链</a><br><a href="https://gcc.gnu.org/pipermail/gcc-patches/2022-December/608710.html"> RISC-V: Add XThead* extension support</a><br><a href="https://github.com/milkv-duo/duo-examples">milkv-duo 官方示例</a><br><a href="https://blog.csdn.net/zvvzxzko2006/article/details/110467542">gcc交叉编译时设置了“–sysroot“会产生哪些影响</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 嵌入式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> RISC-V </tag>
            
            <tag> 交叉编译 </tag>
            
            <tag> SoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言不定参数</title>
      <link href="/2024/07/04/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E4%B8%8D%E5%AE%9A%E5%8F%82%E6%95%B0/"/>
      <url>/2024/07/04/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E4%B8%8D%E5%AE%9A%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="不定参数的例子"><a href="#不定参数的例子" class="headerlink" title="不定参数的例子"></a>不定参数的例子</h2><p>C语言标准库中，向<code>printf</code>这样的函数，参数似乎没有限制。查看函数原型，发现参数列表中除了一个字符常量，还有一个省略号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">printf</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__restrict __format, ...)</span>;</span><br></pre></td></tr></table></figure><p>这个省略号，表示<code>printf</code>应用了C语言的变长参数特性。</p><h2 id="不定参数的解析"><a href="#不定参数的解析" class="headerlink" title="不定参数的解析"></a>不定参数的解析</h2><p>C语言函数参数在函数执行时被压入栈中，由于不知道参数数量和参数在栈中的位置。所以我们必须确定栈顶参数的位置，然后按照类型从栈顶到栈底一个个读取（注意，C语言函数左数第一个参数最后压栈，所以它在栈顶，这也是含变长参数的参数列表必须从左数有至少一个参数的原因）。而下面将介绍的<code>va_start()</code>，<code>va_arg()</code>，<code>va_end()</code>宏就分别与确定栈顶元素、按类型读取元素、清理参数列表指针占用的内存有关。</p><p>下面是一个接收$n$个整形参数并取平均值的函数。在这个函数中，我们通过下面的方法获取可变长参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">average</span><span class="params">(<span class="type">int</span> num,...)</span> &#123;</span><br><span class="line">    <span class="comment">/* 指向可变长参数列表的第一个元素的指针 */</span></span><br><span class="line">    va_list valist; </span><br><span class="line">    <span class="comment">/* 通过va_start，限制读参数过程最大能读出参数的数量 */</span></span><br><span class="line">    va_start(valist, num); </span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">/* 访问所有赋给 valist 的参数 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="comment">/* va_arg，每次读取一个整形参数，读取后，vallist的值增加sizeof(int) */</span></span><br><span class="line">        sum += va_arg(valist, <span class="type">int</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 清理为 valist 保留的内存 */</span></span><br><span class="line">    va_end(valist);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> sum/num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="va-arg-能传入的类型和参数提升"><a href="#va-arg-能传入的类型和参数提升" class="headerlink" title="va_arg()能传入的类型和参数提升"></a>va_arg()能传入的类型和参数提升</h2><p>问：当我们使用<code>va_arg(valist, char)</code>读取参数时，编译器会发出如下的警告：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">warning: ‘char’ is promoted to ‘int’ when passed through ‘...’</span><br><span class="line">  14 |                 a = va_arg(arglist, char);</span><br></pre></td></tr></table></figure><p>这个警告的意思是<code>char</code>类型将被提升为<code>int</code>类型。为什么编译器会这样做？</p><p>答：在函数中，<code>foo(int n, ...)</code>的输入参数假定为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(x, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">103</span>, <span class="number">0x4096fe</span>);</span><br></pre></td></tr></table></figure><p>在 C 语言中，调用不带原型声明或声明为变参的函数时，主调函数<code>foo</code>会对 x 后参数应用“类型提升规则（default argument promotions）”，<code>char</code>，<code>short</code>会被提升为<code>int</code>类型，<code>float</code>会被提升为<code>double</code>类型。所以在<code>va_arg</code>中传入<code>char</code>，<code>short</code>，<code>float</code>一定是无效的。</p><h2 id="为什么需要类型提升？"><a href="#为什么需要类型提升？" class="headerlink" title="为什么需要类型提升？"></a>为什么需要类型提升？</h2><h3 id="兼容性考量"><a href="#兼容性考量" class="headerlink" title="兼容性考量"></a>兼容性考量</h3><p>早期C语言（K&amp;R C）未严格定义函数原型，参数存在类型依赖调用方约定。ANSI C引入函数原型后，为兼容旧代码，规定可变参数需遵循类型提升规则。例如，printf(“%c”, 0x41);中，0x00000041（int）被正确解释为字符’A’，而非截断为char导致错误。（小端序会把这个数的末字节 0x41 储存在虚拟内存地址的低位。然而堆栈是从高到低生长的，如果从堆栈用 va_arg 取 char 类型，会把这个数的最高一字节0x00取走）。</p><h3 id="效率考量"><a href="#效率考量" class="headerlink" title="效率考量"></a>效率考量</h3><p>x86架构的浮点运算单元（FPU）默认以double（64位）精度进行运算，且double在内存布局和寄存器传递上更统一，避免精度丢失或额外转换开销。</p><p>在x86架构中，函数调用通过栈传递参数，栈帧对齐通常以int&#x2F;指针大小（如4&#x2F;8字节）为单位。类型提升确保参数占用空间一致，避免因对齐问题导致性能下降。例如，传递char时若直接使用1字节，可能破坏栈帧的16字节对齐（SSE指令要求），影响SIMD指令效率。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言声明规则与示例</title>
      <link href="/2024/07/03/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%A3%B0%E6%98%8E%E8%A7%84%E5%88%99%E4%B8%8E%E7%A4%BA%E4%BE%8B/"/>
      <url>/2024/07/03/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%A3%B0%E6%98%8E%E8%A7%84%E5%88%99%E4%B8%8E%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="C语言声明规则"><a href="#C语言声明规则" class="headerlink" title="C语言声明规则"></a>C语言声明规则</h2><p>C语言的声明由类型（type）与声明符（declarator）组成。<br>声明符的形式是一个<strong>表达式</strong>。</p><h3 id="C语言声明举例"><a href="#C语言声明举例" class="headerlink" title="C语言声明举例"></a>C语言声明举例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> f, g; <span class="comment">// (1)</span></span><br><span class="line"><span class="type">float</span> ((fg)); <span class="comment">// (2)</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">ff</span><span class="params">()</span>; <span class="comment">// (3)</span></span><br><span class="line"><span class="type">float</span> *pf; <span class="comment">// (4)</span></span><br><span class="line"><span class="type">float</span> *<span class="title function_">g</span><span class="params">()</span>; <span class="comment">// (5)</span></span><br><span class="line"><span class="type">float</span> (*h)(); <span class="comment">// (6)</span></span><br></pre></td></tr></table></figure><p>(1) 的格式为最常见的单变量表达式。<br>(2) 声明时，先计算右侧表达式，得到右侧表达式计算结果<code>fg</code>，此时(2)等同于<code>float fg;</code>。<br>(3) 是一个函数表达式，计算时，<code>ff</code>与右侧括号结合，形成函数，最终的意义是声明一个返回值为<code>float</code>类型的函数。<br>(4) 是一个指针表达式，表示对地址<code>pf</code>取内容的结果为float类型。此时的<code>pf</code>被我们称为“浮点型指针”。<br>(5) 是一个组合表达式。因为<code>()</code>的优先级比<code>*</code>高，所以<code>()</code>先与变量<code>g</code>结合，此时的<code>g()</code>表示一个函数。<code>*</code>后与<code>g()</code>结合，最终形成<code>float *(g())</code>。这表示对函数<code>g()</code>的返回值取内容的结果为<code>float</code>类型。此时的<code>g</code>被我们称为“返回指向<code>float</code>类型指针的函数”。<br>(6) 也是一个组合表达式。右<code>()</code>与<code>(*h)</code>结合形成一个返回值为<code>float</code>且无参数输入的函数。此时的<code>h</code>是指向该函数的指针。</p><h3 id="声明类型（type）和类型别名"><a href="#声明类型（type）和类型别名" class="headerlink" title="声明类型（type）和类型别名"></a>声明类型（type）和类型别名</h3><ol><li><p>声明类型的方法</p><p> C语言声明类型，只需要在变量声明中，去掉变量名即可，形式如下：<code>float (*h)() -&gt; float (*)()</code>。</p><p> 有了声明类型的方法，就可以对常量进行转换，使之成为函数入口，使用如下方式访问存储在<code>0x0</code>地址的函数：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将0转化为函数指针型</span></span><br><span class="line">(<span class="type">float</span> (*)())<span class="number">0</span></span><br><span class="line"><span class="comment">// 访问地址0处的函数/调用函数</span></span><br><span class="line">(*(<span class="type">float</span> (*)())<span class="number">0</span>)()</span><br></pre></td></tr></table></figure></li><li><p><code>typedef</code>声明类型别名</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL x;</span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*funcptr)</span><span class="params">()</span>;</span><br><span class="line">funcptr fp;</span><br></pre></td></tr></table></figure><p> 替换方案：将自定义类型名后的变量 ( 示例中为 x, fp ) 替换到对应类型的<code>typedef</code>定义式中自定义类型名 ( 示例中为 LL, funcptr ) 所在的位置，然后取代该声明语句。如图所示：</p><p> <img src="/assets/typedef.svg" alt="typedef替换过程"></p><p> 举例：声明返回函数指针的函数<code>signal</code>：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span>, <span class="type">void</span> (*)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure><p> 使用<code>typedef</code>可以简化函数声明：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*HANDLER)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">HANDLER <span class="title function_">signal</span><span class="params">(<span class="type">int</span>, HANDLER)</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="应用：区分指针组成的数组和指向数组的指针"><a href="#应用：区分指针组成的数组和指向数组的指针" class="headerlink" title="应用：区分指针组成的数组和指向数组的指针"></a>应用：区分指针组成的数组和指向数组的指针</h2><h3 id="有何不同？"><a href="#有何不同？" class="headerlink" title="有何不同？"></a>有何不同？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p[<span class="number">10</span>]; <span class="comment">// (1)</span></span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">10</span>]; <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure><p>(1) p 优先与 [] 结合，表示 p 是一个数组。<code>*p[10]</code>是一个整形数组，表示数组 p 中的元素是指向整形的指针。<br>(2) <code>(*p)[10]</code>是一个整形数组，<code>(*p)</code>是指向数组第一个元素的指针，p 是指向该数组的指针。</p><h3 id="补充：高维数组指针的类型"><a href="#补充：高维数组指针的类型" class="headerlink" title="补充：高维数组指针的类型"></a>补充：高维数组指针的类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b[<span class="number">2</span>][<span class="number">3</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> (*pb)[<span class="number">3</span>][<span class="number">5</span>] = b;</span><br></pre></td></tr></table></figure><ol><li><code>b[0]</code>等价于<code>*(b + 0)</code>。</li><li>C语言指定指针类型是为了方便 +1 运算。</li><li><code>&amp;b</code>的类型是整个数组<code>b</code>的类型，即<code>int (*)[2][3][5]</code>。</li><li><code>b</code>是一个常量，其值为数组中第一个元素的地址，类型为<strong>指向数组第一个元素的指针</strong>。</li><li><code>b[2][3][5]</code>是一个具有两个元素的<code>b[0], b[1]</code>的一维数组，只是这两个元素又是两个二维数组。</li><li><code>b[]</code>数组的第一个元素是一个起始地址为<code>b</code>的二维数组，所以<code>b</code>的类型为<code>int (*)[3][5]</code>。</li></ol><h3 id="应用：C语言二维数组如何作为函数的参数"><a href="#应用：C语言二维数组如何作为函数的参数" class="headerlink" title="应用：C语言二维数组如何作为函数的参数"></a>应用：C语言二维数组如何作为函数的参数</h3><p>C语言函数调用二维数组时，为了能找到每一行函数的头指针，要填入列数，多维数组原理与之类似</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">toposort</span><span class="params">(<span class="type">int</span> G[][MAXN], <span class="type">int</span> n, <span class="type">int</span> *in, <span class="type">int</span> *out)</span> </span>&#123;</span><br><span class="line">    std::queue &lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">1</span>; p &lt;= n &amp;&amp; in[p]; q.<span class="built_in">push</span>(p), ++p);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 指针 </tag>
            
            <tag> 声明 </tag>
            
            <tag> 类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习PostgreSQL</title>
      <link href="/2024/06/12/Sharp%20Tools/PostgreSql/"/>
      <url>/2024/06/12/Sharp%20Tools/PostgreSql/</url>
      
        <content type="html"><![CDATA[<p>PostgreSQL在未创建新用户时，默认登录用户是超级用户postgres。</p><h2 id="数据库服务"><a href="#数据库服务" class="headerlink" title="数据库服务"></a>数据库服务</h2><ol><li><p>启动，关闭，重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start postgresql</span><br><span class="line">systemctl stop postgresql</span><br><span class="line">systemctl restart postgresql</span><br></pre></td></tr></table></figure></li><li><p>查看一个服务的状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status postgresql</span><br></pre></td></tr></table></figure></li><li><p>开机时启用一个服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> postgresql</span><br></pre></td></tr></table></figure></li><li><p>开机时关闭一个服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> postgresql</span><br></pre></td></tr></table></figure></li><li><p>查看服务是否开机启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-enabled postgresql</span><br></pre></td></tr></table></figure></li></ol><h2 id="数据库用户操作"><a href="#数据库用户操作" class="headerlink" title="数据库用户操作"></a>数据库用户操作</h2><ol start="0"><li><p>登陆postgre用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="operator">-</span>u postgres psql</span><br></pre></td></tr></table></figure></li><li><p>输入登录命令，输入正确的账号密码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">psql <span class="operator">-</span>U postgres <span class="operator">-</span>d postgres</span><br><span class="line">psql <span class="operator">-</span>U <span class="operator">&lt;</span>用户名<span class="operator">&gt;</span> <span class="operator">-</span>d <span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>PostgreSQL 用户在postgresql中的对等身份验证失败问题的<a href="https://deepinout.com/postgresql/postgresql-questions/381_postgresql_peer_authentication_failed_for_user_in_postgresql.html">解决办法</a>:<br>修改<code>/etc/postgresql/15/main/pg_hba.conf</code>，增加允许验证的用户名，如下（第一行是默认配置，可以不修改）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Database administrative login by Unix domain socket</span></span><br><span class="line"><span class="built_in">local</span>   all             postgres                                peer</span><br><span class="line"><span class="comment"># add the line below to allow primer login</span></span><br><span class="line"><span class="built_in">local</span>   all             primer                                  md5 </span><br><span class="line"><span class="comment"># TYPE  DATABASE        USER            ADDRESS                 METHOD</span></span><br></pre></td></tr></table></figure></li><li><p>创建数据库新用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> Username <span class="keyword">WITH</span> PASSWORD <span class="string">&#x27;*****&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>创建数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE <span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></li><li><p>授予用户数据库全部权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> DATABASE <span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span> <span class="keyword">TO</span> <span class="operator">&lt;</span>用户名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></li><li><p>设置年月日输入格式（在线有效，离线无效）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> datestyle <span class="keyword">TO</span> <span class="string">&#x27;DMY&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除，添加，修改属性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> SC <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> grade;</span><br><span class="line"><span class="keyword">ALTER TABLE</span> SC <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> grade <span class="type">NUMERIC</span>(<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">ALTER TABLE</span> S <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> sage TYPE <span class="type">NUMERIC</span>(<span class="number">3</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p>删除，添加约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> S <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> &quot;s_sage_check&quot;;</span><br><span class="line"><span class="keyword">ALTER TABLE</span> SC <span class="keyword">ADD CONSTRAINT</span> &quot;sc_grade_check&quot; <span class="keyword">CHECK</span>(grade <span class="operator">&gt;=</span> <span class="number">0</span> <span class="keyword">AND</span> grade <span class="operator">&lt;=</span> <span class="number">100</span>);</span><br><span class="line"><span class="keyword">ALTER TABLE</span> SC <span class="keyword">ADD</span> <span class="keyword">PRIMARY KEY</span>(sno, cno);</span><br></pre></td></tr></table></figure></li><li><p>回收用户权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> SCHEMA SCHEMA1 <span class="keyword">FROM</span> role_a;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">all</span> <span class="keyword">ON</span> <span class="keyword">all</span> tables <span class="keyword">IN</span> SCHEMA SCHEMA1 <span class="keyword">FROM</span> role_a;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">all</span> <span class="keyword">ON</span> DATABASE postgres <span class="keyword">FROM</span> role_a;</span><br></pre></td></tr></table></figure></li><li><p>授权用户(primer)操作数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> usage <span class="keyword">ON</span> SCHEMA public <span class="keyword">TO</span> primer;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">all</span> privileges <span class="keyword">ON</span> <span class="keyword">all</span> tables <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> primer;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">all</span> privileges <span class="keyword">ON</span> <span class="keyword">all</span> sequences <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> primer;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> <span class="keyword">all</span> tables <span class="keyword">IN</span> SCHEMA public <span class="keyword">TO</span> primer;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">all</span> <span class="keyword">ON</span> SCHEMA public <span class="keyword">TO</span> primer;</span><br></pre></td></tr></table></figure></li></ol><h2 id="数据库资源操作"><a href="#数据库资源操作" class="headerlink" title="数据库资源操作"></a>数据库资源操作</h2><ol><li><p>显示所有表名称和结构</p><p>命令 :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\d</span><br><span class="line">\d <span class="operator">&lt;</span>TableName<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [列级完整性约束条件]</span><br><span class="line">[,<span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [列级完整性约束条件]]</span><br><span class="line">…</span><br><span class="line">[,<span class="operator">&lt;</span>表级完整性约束条件<span class="operator">&gt;</span>…]);</span><br></pre></td></tr></table></figure></li></ol><h2 id="数据库的查询操作"><a href="#数据库的查询操作" class="headerlink" title="数据库的查询操作"></a>数据库的查询操作</h2><ol><li><p>查询的一般格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span>目标列表达式列表<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>基本表或视图列表<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名列表<span class="operator">&gt;</span> [<span class="keyword">HAVING</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]];</span><br></pre></td></tr></table></figure></li></ol><h2 id="数据库的增删改操作"><a href="#数据库的增删改操作" class="headerlink" title="数据库的增删改操作"></a>数据库的增删改操作</h2><ol><li><p>插入元组：</p><ul><li><p>不能违背完整性约束！</p></li><li><p>如果没有指定元组某个元素的值，系统默认将其赋值为空。</p></li><li><p>如果表明后添加(属性)，那么属性列的顺序可与表中不一样，只要和常量相对应即可</p></li></ul><p>语法和示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>[(<span class="operator">&lt;</span>属性列<span class="number">1</span><span class="operator">&gt;</span> [,<span class="operator">&lt;</span>属性列<span class="number">2</span><span class="operator">&gt;</span>]…)]<span class="operator">&lt;</span>子查询<span class="operator">&gt;</span>;</span><br><span class="line"><span class="keyword">INSERT INTO</span> S(Sno, Sname, Ssex, Sage) <span class="keyword">VALUES</span> (<span class="string">&#x27;S14&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;M&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> S(Sno, Sname, Ssex) <span class="keyword">VALUES</span> (<span class="string">&#x27;S14&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;M&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>插入子查询结果：</p><p>例：计算每门课的平均分，存入如下数据库表中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> AvgGrade(</span><br><span class="line">   Cno <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">   grade <span class="type">INT</span>;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> AvgGrade</span><br><span class="line">   <span class="keyword">SELECT</span> Cno, <span class="built_in">AVG</span>(grade)</span><br><span class="line">   <span class="keyword">FROM</span> SC</span><br><span class="line">   <span class="keyword">GROUP</span> <span class="keyword">BY</span> Cno;</span><br></pre></td></tr></table></figure></li><li><p>修改内容</p><p>语法和示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">SET</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;=</span><span class="operator">&lt;</span>表达式<span class="number">1</span><span class="operator">&gt;</span> [, <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;=</span><span class="operator">&lt;</span>表达式<span class="number">2</span><span class="operator">&gt;</span>]…</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> SC</span><br><span class="line"><span class="keyword">SET</span> grade <span class="operator">=</span> grade <span class="operator">*</span> <span class="number">1.3</span></span><br><span class="line"><span class="keyword">WHERE</span> Cno <span class="keyword">IN</span></span><br><span class="line">   (<span class="keyword">SELECT</span> Cno <span class="keyword">FROM</span> C <span class="keyword">WHERE</span> Cname <span class="operator">=</span> <span class="string">&#x27;DB&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>删除内容</p><p>语法和示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno <span class="keyword">IN</span> (<span class="keyword">SELECT</span> Cno <span class="keyword">FROM</span> C</span><br><span class="line"><span class="keyword">WHERE</span> Cname<span class="operator">=</span><span class="string">&#x27;DB&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="数据库理论知识"><a href="#数据库理论知识" class="headerlink" title="数据库理论知识"></a>数据库理论知识</h2><h3 id="一，-数据库的空值"><a href="#一，-数据库的空值" class="headerlink" title="一， 数据库的空值"></a>一， 数据库的空值</h3><ol><li>一般需特殊处理，常用的空值处理方法：NULLIF(p, v) : 若p非空值，返回p，否则返回v</li><li>空值与其它值的算术运算结果为空值，如：NULL+3&#x3D;NULL</li><li>空值进行比较的结果为UNKNOWN。</li><li>UNKNOWN可进行逻辑运算<ul><li>如：3&gt;NULL的结果不为真也不为假，结果为UNKNOWN</li><li>如：UNKNOWN OR TRUE&#x3D;TRUE、UNKNOWN AND TRUE&#x3D;UNKNOWN</li></ul></li></ol><h3 id="二，-数据库视图"><a href="#二，-数据库视图" class="headerlink" title="二， 数据库视图"></a>二， 数据库视图</h3><ol><li><p>视图</p><p>可以理解成数据库的“窗口”，是一个“虚表”，只能看到视图定义的信息，数据实际存放在基本表中。</p><p>在视图中的增删改相当于对数据的增删改。</p></li><li><p>创建视图：</p><p>语法和示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">VIEW</span></span><br><span class="line"><span class="operator">&lt;</span>视图名<span class="operator">&gt;</span> [(<span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span>[, <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span>]…)]</span><br><span class="line"><span class="keyword">AS</span> <span class="operator">&lt;</span>子查询<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION]; <span class="comment">/* 防止插入非法数据 */</span></span><br></pre></td></tr></table></figure></li><li><p>删除视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span> [CASCADE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> M_C1 CASCADE <span class="keyword">CONSTRAINT</span>;</span><br></pre></td></tr></table></figure><ul><li>如选择了CASCADE，则级联删除由该视图导出的其它视图。</li><li>若未选择，则保留由其导出的视图，但这些导出的视图将无法使用，除非重新定义该视图。</li><li>SQL没有提供修改视图的方法，修改需要先删除后创建。</li></ul></li><li><p>在视图中查询和更新：与基本表的查询和更新相同</p><ul><li><p>目前多数DBMS对行列子集视图的查询能够进行正确转换，但对非行列子集视图的查询不一定能够转换</p></li><li><p>一些的视图是不可更新的，因为对这些视图的更新不能唯一地、有意义地转换成对相应基本表的更新</p></li></ul></li><li><p>视图种类：</p><p>(1) 行列子集视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span></span><br><span class="line">M_S(Sno, Sname, Ssex, Sage)</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> Sno, Sname, Ssex, Sage</span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> Ssex<span class="operator">=</span><span class="string">&#x27;M&#x27;</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION;</span><br></pre></td></tr></table></figure><p>(2) 基于多表的视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span></span><br><span class="line">M_C1</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> S.Sno, Sname, grade</span><br><span class="line"><span class="keyword">FROM</span> S, SC</span><br><span class="line"><span class="keyword">WHERE</span> S.Sno<span class="operator">=</span>SC.Sno <span class="keyword">AND</span></span><br><span class="line">S.Ssex<span class="operator">=</span><span class="string">&#x27;M&#x27;</span> <span class="keyword">AND</span></span><br><span class="line">SC.Cno<span class="operator">=</span><span class="string">&#x27;C1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(3) 基于视图的视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> M_C1_A</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> Sno, Sname, grade</span><br><span class="line"><span class="keyword">FROM</span> M_C1</span><br><span class="line"><span class="keyword">WHERE</span> grade<span class="operator">&gt;=</span><span class="number">90</span>;</span><br></pre></td></tr></table></figure><p>(4) 带表达式的视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span></span><br><span class="line">Birth_S</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> Sno, Sname, Ssex, <span class="number">2021</span><span class="operator">-</span>Sage Sbirth</span><br><span class="line"><span class="keyword">FROM</span> S;</span><br></pre></td></tr></table></figure><p>(5) 分组视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span></span><br><span class="line">S_G(Sno, Gavg)</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> Sno, <span class="built_in">AVG</span>(grade)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Sno <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure></li><li><p>为什么需要视图？</p><p>(1) 简化查询操作，一次定义，多次使用。</p><p>(2) 分别满足不同用户的需求，使不同用户从不同角度看待同一数据</p><p>(3) 提供逻辑独立性</p><p>   数据库模式对应关系：模式 $\stackrel{对应}{\rightarrow}$ 表，外模式 $\stackrel{对应}{\rightarrow}$ 视图</p><p>   应用程序使用外模式访问数据库。如果改变了表，那么只需改变模式与外模式的映射，这样应用程序就不用发生改变。</p><p>(4) 对机密数据提供安全保护</p><p>(5) 适当利用视图可以更清晰地表达查询</p></li></ol><h3 id="三，触发器"><a href="#三，触发器" class="headerlink" title="三，触发器"></a>三，触发器</h3><ol><li><p>触发器：一种<strong>完整性控制</strong>机制</p></li><li><p>定义触发器：不同数据库略有不同</p></li><li><p>应用：对外码的修改</p><p>举例：在表T上定义触发器，如修改教师工号，则级联修改C表中的教师工号。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">TRIGGER</span> t1</span><br><span class="line">AFTER <span class="comment">-- 触发时机</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">OF</span> Tno <span class="keyword">ON</span> T <span class="comment">-- 触发事件</span></span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="comment">-- 触发器类型：行级触发器</span></span><br><span class="line"><span class="keyword">BEGIN</span> <span class="comment">-- 触发器执行的动作</span></span><br><span class="line">   <span class="keyword">UPDATE</span> C <span class="keyword">SET</span> Tno<span class="operator">=</span>:NEW.Tno</span><br><span class="line">   <span class="keyword">WHERE</span> Tno<span class="operator">=</span>:OLD.Tno</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>注释：</p><ul><li><p>Before：触发事件执行之前调用触发器。</p></li><li><p>After：触发事件执行之后调用触发器。</p></li><li><p>NEW：数据类型是RECORD。对于行级触发器，它存有INSERT或UPDATE操作产生的新的数据行。对于语句级触发器，它的值是NULL。</p></li><li><p>OLD：数据类型是RECORD。对于行级触发器，它存有被UPDATE或DELETE操作修改或删除的旧的数据行。对于语句级触发器，它的值是NULL。</p></li></ul></li></ol><h2 id="其他可能用到的命令"><a href="#其他可能用到的命令" class="headerlink" title="其他可能用到的命令"></a>其他可能用到的命令</h2><ol><li>寻找相关配置文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql -c <span class="string">&quot;show config_file&quot;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA算法</title>
      <link href="/2024/04/14/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/RSA%E7%AE%97%E6%B3%95/"/>
      <url>/2024/04/14/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/RSA%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="RSA过程"><a href="#RSA过程" class="headerlink" title="RSA过程"></a>RSA过程</h2><h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><ol><li>计算N<br> $$<br> N&#x3D;a\times b (a, b\in \mathbb{P})<br> $$</li><li>计算中间值L<br> $$<br> L &#x3D; \varphi(N) &#x3D; (a-1)(b-1)<br> $$</li><li>选择一个公钥Pub，满足下列条件（为了使第四步有解）<br> $$<br> \gcd(Pub, L)&#x3D;1\ (1&lt;Pub&lt;L)<br> $$</li><li>计算私钥Pri<br> $$<br> Pub \times Pri \equiv 1(\bmod\ L)\ (1&lt;Pri&lt;L)<br> $$</li></ol><h3 id="加解密算法"><a href="#加解密算法" class="headerlink" title="加解密算法"></a>加解密算法</h3><ol><li>加密<br> $$<br> Msg &#x3D; msg^{Pub}\ \bmod\ N<br> $$</li><li>解密<br> $$<br> msg &#x3D; Msg^{Pri}\ \bmod\ N<br> $$</li></ol><h2 id="RSA原理"><a href="#RSA原理" class="headerlink" title="RSA原理"></a>RSA原理</h2><h3 id="前置数论"><a href="#前置数论" class="headerlink" title="前置数论"></a>前置数论</h3><p>在说明RSA原理之前，先介绍几个数论知识</p><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>欧拉函数$\varphi(n)$表示与$n$互质元素的数量。可用集合描述为：</p><p>$$<br>\varphi(n)&#x3D;\vert {m|\gcd(m,n)&#x3D;1且m &lt; n且m,n\in \mathbb{N}} \vert<br>$$</p><p>求解方法：使用筛法，先将$n$做质因子分解，得到如下形式：</p><p>$$<br>n&#x3D;p_1^{k_1}p_2^{k_2}\cdots p_r^{k_r}<br>$$</p><p>然后对于$1\sim n$的每一个整数，筛除包含质因数$p_1,p_2\cdots p_r$的倍数。$p_i$的倍数有$\lfloor\frac{n}{p_i}\rfloor$个。但由于每次筛除都会筛到几个质数的公倍数，所以计算时要补回缺失的数量，即使用<strong>容斥原理</strong>求出$\varphi(n)$。</p>$$\begin{align*}\varphi(n)&=n-\sum_{i=1}^{r}\lfloor\frac{n}{p_i}\rfloor+\sum_{i=1,j\neq i}^{r}\lfloor\frac{n}{p_ip_j}\rfloor-\sum_{i=1,j\neq i,k\neq i,j}^{r}\lfloor\frac{n}{p_ip_jp_k}\rfloor+\cdots \\&=n(1-\frac{1}{p_1}+\frac{1}{p_1p_2}-\frac{1}{p_2}+\cdots+\frac{1}{p_2p_3}-\frac{1}{p_1p_2p_3}+\cdots+\frac{1}{p_1p_2p_3p_4}-\frac{1}{p_2p_3p_4}+\cdots) \\&=n(1-\frac{1}{p_1})(1-\frac{1}{p_2}+\frac{1}{p_2p_3}-\frac{1}{p_3}+\cdots+\frac{1}{p_3p_4}-\frac{1}{p_2p_3p_4}+\cdots+\frac{1}{p_2p_3p_4p_5}-\frac{1}{p_3p_4p_5}+\cdots) \\&=\cdots \\&=n(1-\frac{1}{p_1})(1-\frac{1}{p_2})\cdots(1-\frac{1}{p_r})\end{align*}$$<p>可以从$r&#x3D;2,r&#x3D;3$的简单情况推测出上面式子的化简方法。</p><p>欧拉函数具有积性，即$\varphi(N)&#x3D;\varphi(n)\varphi(m)$，其中$N&#x3D;nm, \gcd(m,n)&#x3D;1$。</p><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>欧拉定理表示如下：</p><p>若$\gcd(a,n)&#x3D;1$，则$a^{\varphi(n)} \equiv 1 (\bmod\ n)$</p><h3 id="扩展欧拉定理"><a href="#扩展欧拉定理" class="headerlink" title="扩展欧拉定理"></a>扩展欧拉定理</h3><p>当a为任意值，有扩展欧拉定理表示如下：</p>$$a^c \equiv\begin{cases}  a^{c \bmod \varphi(m)} &\gcd(a,m)=1 \\  a^c &\gcd(a,m) \neq 1,c<\varphi(m) \\  a^{\left(c \bmod \varphi(m)\right)+\varphi(m)} &\gcd(a,m) \neq 1,c \geq \varphi(m)\end{cases}\pmod m$$<p>这两个定理的证明过于复杂，偏离本文主题，故略去。</p><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><p>如果$\gcd(a,n)&#x3D;1$，则一定存在$b$，满足下列条件：</p><p>$$<br>ab\equiv 1 (\bmod\ n)<br>$$</p><p>此时$b$称为$a$的逆元，也可记作$a^{-1}$。欧拉定理可以证明逆元存在性。<br>也可得到以下推论：（若$n$为质数，$a^{\varphi(n)-1}$一定是a的逆元）。</p><h2 id="解释与证明"><a href="#解释与证明" class="headerlink" title="解释与证明"></a>解释与证明</h2><h3 id="加解密算法可逆的解释"><a href="#加解密算法可逆的解释" class="headerlink" title="加解密算法可逆的解释"></a>加解密算法可逆的解释</h3><p>已知加解密算法如下</p>$$Msg = msg^{Pub}\ \bmod\ N \\msg = Msg^{Pri}\ \bmod\ N$$<p>若两式同时成立，为了找到公钥和私钥的关系，可以做如下变换（虽然看起来可以从欧拉定理想出，这个加解密的算法只能说是妙手偶得了）。</p>$$msg = msg^{Pub\times Pri}\ \bmod\ N \Leftrightarrow msg \equiv msg^{Pub \times Pri} (\bmod\ N) \tag{1}$$<p>我们的目的是寻找一对合理的$Pub,Pri$，满足$(1)$的条件。</p><ol><li><p>当$\gcd(m,N)&#x3D;1$时，$m^{-1} (\bmod\ N)$存在，则条件$(1)$可化简为：</p><p> $$<br> msg^{Pub\times Pri-1} \equiv 1 (\bmod\ N)<br> $$</p><p> 此时，由同余相乘的性质和欧拉定理，当$Pub,Pri$满足下列条件时，满足条件$(1)$：</p><p> $$<br> Pub\times Pri-1&#x3D;k\varphi(N)<br> $$</p></li><li><p>当$\gcd(m,N)&gt;1$时，$m^{-1} (\bmod\ N)$不存在，此时，令$p&#x3D;\gcd(m,N),q&#x3D;\frac{N}{p},k_m &#x3D; \frac{m}{p}$。此时，改写$(1)$为其等价形式：</p><p> $$<br> m^{Pub\times Pri}&#x3D;k*N+m<br> $$</p><p> 同除$p$，得到下式：</p>     $$    \begin{align*}    m^{Pub\times Pri-1} * \frac{m}{p}&=k*\frac{N}{p}+\frac{m}{p} \\    \Leftrightarrow m^{Pub\times Pri-1} * k_m&=k*q+k_m \\    \Leftrightarrow m^{Pub\times Pri-1} * k_m&\equiv k_m (\bmod\ q) \tag{2}    \end{align*}    $$    <p> 由于$\gcd(k_m, q)&#x3D;1$，$k_m^{-1} (\bmod\ q)$存在，所以式$(2)$又等价于：</p><p> $$<br> m^{Pub\times Pri-1}\equiv 1 (\bmod\ q)  \tag{3}<br> $$</p><p> 这就得到了$(1)\Leftrightarrow(2)\Leftrightarrow(3)$<br> 此时，$\gcd(q, m)&#x3D;1$，可以像上一种情况一样使用欧拉定理了。<br> 满足下面条件的$Pub,Pri$均满足$(1)$：</p><p> $$<br> Pub\times Pri-1&#x3D;k\varphi(q)<br> $$</p></li><li><p>要想$Pub,Pri$同时满足上述情况，需要对上述两种情况的$Pub,Pri$解集求交集（也可以说情况2中$p&#x3D;1$的情况就是情况1），即：</p>     $$    A=\{(Pub, Pri)|Pub\times Pri=k_1\varphi(N)+1\} \\    B=\{(Pub, Pri)|Pub\times Pri=k_2\varphi(q)+1\}    $$    <p> 求$A\cap B$。<br> 解决该问题需要用到欧拉函数的积性（证明略）。由欧拉函数的积性，可知$\varphi(N)&#x3D;\varphi(p)\varphi(q)$，令$k_2&#x3D;k_1\times \varphi(p)$，即可得$A\cap B$，表示如下：</p><p> $$<br> A\cap B&#x3D;{(Pub, Pri)|Pub\times Pri&#x3D;k\varphi(N)+1}<br> $$</p><p> 综上，要满足条件$(1)$，$Pub,Pri$的一组合理值应满足如下条件：</p><p> $$<br> Pub\times Pri&#x3D;k\varphi(N)+1<br> $$</p><p> 也可等价表示为：</p><p> $$<br> Pub\times Pri\equiv 1 (\bmod\ \varphi(N))<br> $$</p></li></ol><h3 id="加解密算法的详细证明"><a href="#加解密算法的详细证明" class="headerlink" title="加解密算法的详细证明"></a>加解密算法的详细证明</h3><p><a href="https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_theory/">RSA 介绍 - CTF Wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> 信息安全 </tag>
            
            <tag> 非对称加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非对称加密简介</title>
      <link href="/2024/04/14/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
      <url>/2024/04/14/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="非对称加密算法的出现"><a href="#非对称加密算法的出现" class="headerlink" title="非对称加密算法的出现"></a>非对称加密算法的出现</h2><p>对称加密解密一般需要双方确定一个或一组共同的密钥。但这种方式存在漏洞。在确定密钥的过程中，双方需要通信，但通信双方不能保障信道安全性。此时，攻击者可以窃听通信信道从而获取双方商议的密钥。这种如何保证密钥传输保密性的问题被称为<strong>密钥配送问题</strong>。非对称加密是解决该问题的一种思想。</p><p>非对称加密，就是通过在信道中传递公开的密钥从而绕过密钥配送问题的思想。非对称加密双方各保存一对公钥(Public Key)和私钥(Private Key)。发送方给接收方发送信息时，使用接收方的公钥将该信息加密后传给接收方。接收方受到加密信息后，使用自己的私钥解密信息。完成一次信息传递。非对称加密的加解密运算是可逆的。</p>$$Msg_{encrypted}=f(msg, \text{ReceiverPub}) \\msg=f(Msg_{encrypted}, \text{ReceiverPri})$$<h2 id="代表性算法"><a href="#代表性算法" class="headerlink" title="代表性算法"></a>代表性算法</h2><p>特点：正向计算容易，逆向计算（未知密钥的情况）困难</p><p>算法：RSA, ECC, EI Gamal, Knapsack</p><h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><h3 id="针对算法的暴力破解"><a href="#针对算法的暴力破解" class="headerlink" title="针对算法的暴力破解"></a>针对算法的暴力破解</h3><p>算法经过了精心设计，但原理公开，使得暴力破解理论上可行，然而以当前计算机算力，很难在短时间内运算出结果，目前通行的算法均具有一定安全性。</p><h3 id="中间人攻击——伪造接收者"><a href="#中间人攻击——伪造接收者" class="headerlink" title="中间人攻击——伪造接收者"></a>中间人攻击——伪造接收者</h3><p>绕开了信道的问题就绝对安全了吗？并不是。试想，如果对端的那个人，计算机不是我们期望的那个呢？单靠非对称加密好像并没有办法确定对端的身份。攻击者可以利用这样的漏洞，插入通信双方之间作为“中间人”。这个“中间人”同时向双方发送自己的公钥，这样，通信双方都会认为该公钥是对方的，从而使用攻击者的公钥进行加密，这样，攻击者就会使用自己的私钥解密出双方的信息。这个漏洞被称为“中间人攻击”。</p><h3 id="信息篡改——伪造发送者发送的信息"><a href="#信息篡改——伪造发送者发送的信息" class="headerlink" title="信息篡改——伪造发送者发送的信息"></a>信息篡改——伪造发送者发送的信息</h3><p>当了解到通信双方非对称加密算法后，攻击者还有另外一种攻击方式。不同于上一段的伪造接收人，这一次，攻击者拦截了发送者的消息。把自己的消息使用接收者的公钥进行加密发送给接收者，接收者不知道这个信息是否被篡改过，会正常解密收到的文件。这个漏洞被称为“信息篡改”。</p><h2 id="增强安全性"><a href="#增强安全性" class="headerlink" title="增强安全性"></a>增强安全性</h2><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>为了解决中间人攻击的问题，必须要验证接收方的公钥是否是接收方的。此时就需要一个权威的公证机构提供接收方的公钥信息，发送方比对机构提供的接收方公钥和收到的接收方公钥，然后确认接收方没有被中间人代替。</p><p>数字证书的验证过程如下：</p><ol><li>接收方生成一对公钥和私钥。</li><li>接收方将其公钥提供给认证机构 (Certificate Authority, CA)，认证机构进行验证并用自己的私钥生成接收方公钥的签名。<br> $$<br> sig &#x3D; f(\text{ReceiverPub}, \text{CAPri})<br> $$</li><li>发送方使用认证机构的公钥解密证书中的公钥签名，得到认证机构提供的接收方的公钥。<br>$$<br> \text{ReceiverPub}&#x3D;f(sig, \text{CAPub})<br>$$</li><li>比对认证机构提供的接收方的公钥与通信获取的接收方公钥，如果相同，则正常发送信息。</li></ol><p>除了公钥签名外，数字证书包含的全部信息如下（x.509v3标准[^1]）：</p><ol><li>证书申请者，证书发放机构信息</li><li>数字签名，签名算法，签名值</li><li>证书协议版本，证书序列号，证书失效时间</li><li>唯一身份标识</li></ol><p>关于证书的信任问题：</p><ol><li><p>如果有人伪造证书发放机构呢？</p><p> 机构可以查询，一些著名机构的信息会加入系统文件保存在本地。</p></li><li><p>最可信的CA机构是哪个？</p><p> CA认证是一个树形结构，根CA是各个子CA的树根，根CA是最可信的，数字证书安全的前提就是根CA可信。</p></li></ol><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>为了解决数据篡改的问题，接收方必须确认接收的数据与发送方发送的数据相同。一般来讲，在实际工程应用中，一般通过哈希的方式验证信息的完整性。但发送方如何确保接收方接收由发送方生成且正确的哈希值呢？</p><p>首先，这个哈希值不能使用公钥加密，因为攻击者知道公钥，这样就给了攻击者伪造数据的机会。所以发送方应该使用私钥加密生成的哈希值。接收方对比哈希值的方法与上一小节相同。即先计算收到数据（未解密）的哈希值$H_1$，然后用自己的私钥解密数据得到解密数据$D$，之后用发送方的公钥解密$D$中的哈希值$H_2$，最后比较$H_1$，$H2$，若$H_1&#x3D;H_2$，可以确认数据是未经篡改的。</p><h2 id="加密算法的应用实验"><a href="#加密算法的应用实验" class="headerlink" title="加密算法的应用实验"></a>加密算法的应用实验</h2><p>GnuPG是一款Unix系统加密工具。该工具可以实现密钥生成和加密解密。参照下面链接文章中展示的步骤即可完成对一个文件的加解密。下面是一些基本操作。<br>获取GnuPG的全部加密方式，然后生成密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --expert --full-generate-key</span><br></pre></td></tr></table></figure><p>使用下面的命令查看用户使用GnuPG生成的所有密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --list-keys</span><br></pre></td></tr></table></figure><p>导出公钥和私钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpg --armor --output public-key.txt --<span class="built_in">export</span> </span><br><span class="line">gpg --armor --output private-key.txt --export-secret-keys</span><br></pre></td></tr></table></figure><p>加密和解密</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpg --recipient 用户HashID或邮箱地址 --output demo.en.txt --encrypt demo.txt</span><br><span class="line">gpg --output demo.de.txt --decrypt demo.en.txt </span><br></pre></td></tr></table></figure><p>删除密钥，先删除私钥，然后删除公钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpg --delete-secret-keys &lt;key-id&gt;</span><br><span class="line">gpg --delete-keys &lt;key-id&gt;</span><br></pre></td></tr></table></figure><p><a href="http://ruanyifeng.com/blog/2013/07/gpg.html">GPG入门教程-阮一峰的网络日志</a><br><a href="https://www.gnupg.org/documentation/manuals/gnupg/">GnuPG Manual</a></p><p>参考资料[^5]：</p><p>[^1]: <a href="https://www.rfc-editor.org/rfc/rfc5280#page-16">RFC 5280: Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a></p><p>[^5]: <a href="https://icodebook.com/tags/crypt/">密码学 - 爱码叔-iCodeBook</a></p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> 信息安全 </tag>
            
            <tag> 非对称加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言答疑</title>
      <link href="/2023/12/05/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98/"/>
      <url>/2023/12/05/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-C语言关键字"><a href="#1-C语言关键字" class="headerlink" title="1.C语言关键字"></a>1.C语言关键字</h2><h3 id="1-1-关键字static"><a href="#1-1-关键字static" class="headerlink" title="1.1 关键字static"></a>1.1 关键字static</h3><ol><li>在<strong>函数体内</strong> ，一个被声明为静态的变量 在这一函数被调用过程中维持其值不变。</li><li>在文件域内（但在函数体外），一个被声明为静态的变量 可以被文件域内所有函数访问，但不能被文件域外其它函数访问。它是一个<strong>本地的全局变量</strong>。</li><li>在文件域内 ，一个被声明为静态的函数只可被这一文件域内的其它函数调用。那就是，这个函数被限制在<strong>声明它的文件的本地范围内使用</strong>。</li></ol><h3 id="1-2-关键字const"><a href="#1-2-关键字const" class="headerlink" title="1.2 关键字const"></a>1.2 关键字const</h3><p>只读 ：不能简单说 “常数”<br>使用关键字 const 能产生更紧凑的代码。使编译器保护那些不希望被改变的参数，防止其被无意的代码修改。<br>最简单读懂const变量类型的方法，就是直接从右向左阅读。<br>以<code>const int *a</code>为例，<code>*a</code>表示<code>a</code>是指针，<code>int *a</code>表示指针<code>a</code>指向整形，<code>const int *a</code>表示指针<code>a</code>指向常整形。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a; <span class="comment">// a 是整数，a 是常量                       ---&gt;  a 是一个常整数</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> a; <span class="comment">//  a 是常量，a 是整数                      ---&gt;  a 是一个常整数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *a; <span class="comment">// a 是指针，指针指向整形，这个整形是常量      ---&gt;  a 是一个指向常整数的指针</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *a; <span class="comment">// a 是指针，指针是常量，这个常量的类型是整数   ---&gt;  a 是一个指向整数的常指针</span></span><br></pre></td></tr></table></figure><h3 id="1-3-关键字volatile"><a href="#1-3-关键字volatile" class="headerlink" title="1.3 关键字volatile"></a>1.3 关键字volatile</h3><ol><li><p>阻止编译器优化<br> 定义为 volatile 的变量是说这变量可能会被意想不到地改变<br> 优化器在用到这个变量时必须每次都重新读取这个变量的值，而不是使用保存在寄存器里的备份。</p></li><li><p>volatile 变量使用的几种情况（主要用于嵌入式系统）</p><ul><li>I&#x2F;O 接口电路的硬件寄存器 （如：状态寄存器）</li><li>中断服务子程序中会访问到的非自动变量</li><li>多任务中被几个任务共享的变量</li></ul></li><li><p>举例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> eventI2C;</span><br><span class="line"><span class="comment">// 声明只读的无符号字符变量 eventI2C</span></span><br><span class="line"><span class="comment">// const ：本程序不应该试图去修改它</span></span><br><span class="line"><span class="comment">// volatile ：可能被外界（硬件、其他进程）改变</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="2-访问绝对地址"><a href="#2-访问绝对地址" class="headerlink" title="2.访问绝对地址"></a>2.访问绝对地址</h2><p>单片机编程时，经常需要访问一个绝对的地址，结合类型声明规则，强制类型转换规则，可以将地址转化为需要的类型后直接使用该地址。示例如下，这是 stm32 单片机寄存器方式操作 UART 的方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UART寄存器定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULCON0 (*(volatile unsigned long*) 0x01D00000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UCON0 (*(volatile unsigned long*) 0x01D00004)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UFCON0 (*(volatile unsigned long*) 0x01D00008)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UMCON0 (*(volatile unsigned long*) 0x01D0000C)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line">*pULCON0 = <span class="number">0x03</span>; <span class="comment">// 帧长度 8 位，停止位 1 位，无校验</span></span><br><span class="line">*pUFCON0 = <span class="number">0x21</span>; <span class="comment">// 启用 FIFO ，发送 FIFO 触发级别为空，</span></span><br><span class="line">                 <span class="comment">// 接收 FIFO 触发级别为 12 字节</span></span><br><span class="line">*pUCON0 = <span class="number">0xC5</span>;  <span class="comment">// 接收中断 查询允许，发送中断 查询允许</span></span><br><span class="line">                 <span class="comment">// 允许接收错误中断，允许接收超时中断</span></span><br></pre></td></tr></table></figure><h2 id="3-C语言定义和声明结构体"><a href="#3-C语言定义和声明结构体" class="headerlink" title="3.C语言定义和声明结构体"></a>3.C语言定义和声明结构体</h2><h3 id="3-1-一般的结构体"><a href="#3-1-一般的结构体" class="headerlink" title="3.1 一般的结构体"></a>3.1 一般的结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">21</span>];<span class="comment">//学生姓名</span></span><br><span class="line">    <span class="type">int</span> age;      <span class="comment">//学生年龄</span></span><br><span class="line">&#125;stu5,stu6,stu7;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu2</span>,<span class="title">stu3</span>,<span class="title">stu4</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>* <span class="title">stu_ptr</span> =</span> new Student; <span class="comment">//结构体指针</span></span><br></pre></td></tr></table></figure><h3 id="3-2-匿名结构体"><a href="#3-2-匿名结构体" class="headerlink" title="3.2 匿名结构体"></a>3.2 匿名结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">21</span>];<span class="comment">//学生姓名</span></span><br><span class="line">    <span class="type">int</span> age;      <span class="comment">//学生年龄</span></span><br><span class="line">&#125;stu8,stu9;</span><br></pre></td></tr></table></figure><h3 id="3-3-C语言结构体的初始化"><a href="#3-3-C语言结构体的初始化" class="headerlink" title="3.3 C语言结构体的初始化"></a>3.3 C语言结构体的初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> age;      <span class="comment">//学生年龄</span></span><br><span class="line">    <span class="type">int</span> grade;    <span class="comment">//学生年级</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">21</span>];<span class="comment">//学生姓名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-4-成员变量单个初始化"><a href="#3-4-成员变量单个初始化" class="headerlink" title="3.4 成员变量单个初始化"></a>3.4 成员变量单个初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student s;</span><br><span class="line">s.age   = <span class="number">16</span>;</span><br><span class="line">s.grade = <span class="number">1</span>;</span><br><span class="line">s.name  = <span class="string">&quot;Jack&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="3-5-顺序初始化"><a href="#3-5-顺序初始化" class="headerlink" title="3.5 顺序初始化"></a>3.5 顺序初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student s = &#123;<span class="number">16</span>, <span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-头文件不应该定义变量的原因"><a href="#4-头文件不应该定义变量的原因" class="headerlink" title="4.头文件不应该定义变量的原因"></a>4.头文件不应该定义变量的原因</h2><p>预编译时，<code>#include &quot;xx.h&quot;</code>会被<code>.h</code>文件中的内容替换。如果<code>.h</code>文件中定义了变量并被多个文件引用，对该变量的定义在链接时会在不同的目标文件中出现。链接器会报重复定义变量的错误。</p><p>下面的情况就会出现链接错误。</p><p>文件一：<code>a.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>文件二：<code>a.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件三：<code>b.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免这种链接错误，在<code>.h</code>中应该只出现对变量的声明或静态变量的定义。若在<code>a.c</code>中定义了变量 a ，在<code>a.h</code>中应如下声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br></pre></td></tr></table></figure><p>当然，除了精心设计之外，使用 <code>ifdef</code> 可以更省心的解决问题。</p><h2 id="5-位域"><a href="#5-位域" class="headerlink" title="5.位域"></a>5.位域</h2><p>在结构体中遇到了类似这样的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Example</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_find_object_processed:<span class="number">1</span>;  <span class="comment">// 1 bit for this flag</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_find_object_ok:<span class="number">1</span>;  <span class="comment">// 1 bit for this flag</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体变量后面的<code>:1</code>标记被称为“位域”。位域允许我们只使用部分字节或更小的内存空间来存储数据。在这里，l_find_object_processed 只占用 1 位，可以存储 0 或 1 这样的二进制值。在上面的示例中，l_find_object_processed 会被压缩到 unsigned int 类型的内存空间中，但该变量只使用其中的 1 位。</p><h2 id="6-C语言运算符的优先级顺序"><a href="#6-C语言运算符的优先级顺序" class="headerlink" title="6.C语言运算符的优先级顺序"></a>6.C语言运算符的优先级顺序</h2><table><thead><tr><th align="center">运算符</th><th align="center">结合性</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center"><code>() [] -&gt; .</code></td><td align="center">自左向右</td><td align="center">a.b.c &#x3D;&gt; (a.b).c</td></tr><tr><td align="center"><code>! ~ ++ -- - (type) * &amp; sizeof</code></td><td align="center">自右向左</td><td align="center">a.b.c &#x3D;&gt; a.(b.c)</td></tr><tr><td align="center"><code>* / %</code></td><td align="center">自左向右</td><td align="center"></td></tr><tr><td align="center"><code>+ -</code></td><td align="center">自左向右</td><td align="center"></td></tr><tr><td align="center"><code>&lt;&lt; &gt;&gt;</code></td><td align="center">自左向右</td><td align="center"></td></tr><tr><td align="center"><code>&lt; &lt;= &gt; &gt;=</code></td><td align="center">自左向右</td><td align="center"></td></tr><tr><td align="center"><code>== !=</code></td><td align="center">自左向右</td><td align="center"></td></tr><tr><td align="center"><code>&amp;</code></td><td align="center">自左向右</td><td align="center"></td></tr><tr><td align="center"><code>^</code></td><td align="center">自左向右</td><td align="center"></td></tr><tr><td align="center"><code>|</code></td><td align="center">自左向右</td><td align="center"></td></tr><tr><td align="center"><code>&amp;&amp;</code></td><td align="center">自左向右</td><td align="center"></td></tr><tr><td align="center"><code>||</code></td><td align="center">自左向右</td><td align="center"></td></tr><tr><td align="center"><code>？:</code></td><td align="center">自右向左</td><td align="center"></td></tr><tr><td align="center"><code>assignments</code></td><td align="center">自右向左</td><td align="center"></td></tr><tr><td align="center"><code>,</code></td><td align="center">自左向右</td><td align="center"></td></tr></tbody></table><h2 id="7-结构体末尾的一个零长度数组左右是什么？——-allocator-function"><a href="#7-结构体末尾的一个零长度数组左右是什么？——-allocator-function" class="headerlink" title="7.结构体末尾的一个零长度数组左右是什么？—— allocator function"></a>7.结构体末尾的一个零长度数组左右是什么？—— allocator function</h2><p>UNIX系统高级编程chapter12 在recursive lock节提到的 allocator function 技术：在结构体末尾使用一个零长度数组，使用指针传入函数参数时，编译器不知道结构体实际大小，所以可以在不改变函数参数类型的情况下多传入一个参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Info</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> nums;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> lock[<span class="number">0</span>];</span><br><span class="line">&#125;Info_t;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    Info_t *pinfo = (Info_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Info_t) + <span class="keyword">sizeof</span>(<span class="type">pthread_mutex_t</span>));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学学写字</title>
      <link href="/2023/04/12/%E6%84%9F%E6%83%B3%E9%9A%8F%E7%AC%94/handwrite/"/>
      <url>/2023/04/12/%E6%84%9F%E6%83%B3%E9%9A%8F%E7%AC%94/handwrite/</url>
      
        <content type="html"><![CDATA[<h2 id="如何写粗体字母"><a href="#如何写粗体字母" class="headerlink" title="如何写粗体字母"></a>如何写粗体字母</h2><p><img src="/assets/others/handwriting/alphabet_capital_bold.svg" alt="大写"></p><p><img src="/assets/others/handwriting/alphabet_small_bold.svg" alt="小写"></p><h2 id="如何写希腊字母"><a href="#如何写希腊字母" class="headerlink" title="如何写希腊字母"></a>如何写希腊字母</h2><p><img src="/assets/others/handwriting/Greek.jpg" alt="希腊字母手写图一"></p><p><img src="/assets/others/handwriting/Greek2.jpg" alt="希腊字母手写图二"></p>]]></content>
      
      
      <categories>
          
          <category> 感想随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anaconda Python工具的使用</title>
      <link href="/2023/02/05/Sharp%20Tools/Anaconda%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"/>
      <url>/2023/02/05/Sharp%20Tools/Anaconda%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="1-更换conda软件源"><a href="#1-更换conda软件源" class="headerlink" title="1. 更换conda软件源"></a>1. 更换conda软件源</h2><h3 id="1-1-显示conda的json配置文件"><a href="#1-1-显示conda的json配置文件" class="headerlink" title="1.1  显示conda的json配置文件"></a>1.1  显示conda的json配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --show</span><br></pre></td></tr></table></figure><h3 id="1-2-添加镜像源"><a href="#1-2-添加镜像源" class="headerlink" title="1.2  添加镜像源"></a>1.2  添加镜像源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure><p>运行<code>conda clean -i</code>清除索引缓存，保证用的是镜像站提供的索引。</p><h3 id="1-3-恢复默认镜像源"><a href="#1-3-恢复默认镜像源" class="headerlink" title="1.3 恢复默认镜像源"></a>1.3 恢复默认镜像源</h3><p>删除单个链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --remove channels &lt;your_url&gt;</span><br></pre></td></tr></table></figure><p>恢复默认镜像源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --remove-key channels</span><br></pre></td></tr></table></figure><h2 id="2-配置虚拟环境"><a href="#2-配置虚拟环境" class="headerlink" title="2. 配置虚拟环境"></a>2. 配置虚拟环境</h2><h4 id="2-1-什么是虚拟环境"><a href="#2-1-什么是虚拟环境" class="headerlink" title="2.1 什么是虚拟环境"></a>2.1 什么是虚拟环境</h4><h4 id="2-2-新建虚拟环境的方法"><a href="#2-2-新建虚拟环境的方法" class="headerlink" title="2.2 新建虚拟环境的方法"></a>2.2 新建虚拟环境的方法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查看所有虚拟环境： conda info -e </span><br><span class="line">启动虚拟环境：conda activate &lt;env_name&gt;</span><br><span class="line">创建：conda create -n &lt;env_name&gt; ，如，conda create -n amd_dml python=3.8</span><br><span class="line">删除：conda remove -n rcnn --all</span><br></pre></td></tr></table></figure><h4 id="2-3-在虚拟环境中安装必要依赖"><a href="#2-3-在虚拟环境中安装必要依赖" class="headerlink" title="2.3 在虚拟环境中安装必要依赖"></a>2.3 在虚拟环境中安装必要依赖</h4><p>这是机器学习的库，注意要按顺序安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">conda install pandas</span><br><span class="line">conda install tensorboard </span><br><span class="line">conda install matplotlib </span><br><span class="line">conda install tqdm </span><br><span class="line">conda install pyyaml </span><br><span class="line">pip install opencv-python</span><br><span class="line">pip install wget</span><br><span class="line">pip install torchvision==0.9.0</span><br><span class="line"></span><br><span class="line">pip install torch-directml</span><br></pre></td></tr></table></figure><h3 id="2-4-检查torch-directml是否安装好"><a href="#2-4-检查torch-directml是否安装好" class="headerlink" title="2.4 检查torch-directml是否安装好"></a>2.4 检查torch-directml是否安装好</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch_directml</span><br><span class="line"></span><br><span class="line">dml = torch_directml.device()</span><br><span class="line">tensor1 = torch.tensor([<span class="number">7</span>]).to(dml)</span><br><span class="line">tensor2 = torch.tensor([<span class="number">2</span>]).to(dml)</span><br><span class="line"></span><br><span class="line">dml_algebra = tensor1 + tensor2</span><br><span class="line"><span class="built_in">print</span>(dml_algebra.item())</span><br></pre></td></tr></table></figure><h2 id="2-x-其他问题"><a href="#2-x-其他问题" class="headerlink" title="2.x 其他问题"></a>2.x 其他问题</h2><ol><li><p>如果powershell不支持虚拟环境，可以在powershell中执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda init</span><br></pre></td></tr></table></figure><p>如果powershell报错，一般都是Windows PowerShell 执行的默认策略“Restricted”所致。</p><p>我们可以修改安全策略为：”REMOTESIGNED“。</p></li><li><p>Anaconda 的pkg目录占用空间太大</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从可写包缓存中删除未使用的包。警告：这不会检查已安装的软件包使用符号链接返回包缓存。</span></span><br><span class="line">conda clean -p</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除缓存的包 tarbal</span></span><br><span class="line">conda clean -t</span><br></pre></td></tr></table></figure></li><li><p>备份与重新安装部署命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">激活虚拟环境</span><br><span class="line">source activate hugebig</span><br><span class="line">查看当前包</span><br><span class="line">python -m pip list</span><br><span class="line">备份环境</span><br><span class="line">python -m pip freeze &gt; ./myrequirements.txt</span><br><span class="line">安装环境</span><br><span class="line">pip install -r ./myrequirements.txt</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-使用pip的相关技巧"><a href="#3-使用pip的相关技巧" class="headerlink" title="3. 使用pip的相关技巧"></a>3. 使用pip的相关技巧</h2><h3 id="3-1-加速技巧"><a href="#3-1-加速技巧" class="headerlink" title="3.1 加速技巧"></a>3.1 加速技巧</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scikit-learn -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><h3 id="3-2-更新包"><a href="#3-2-更新包" class="headerlink" title="3.2 更新包"></a>3.2 更新包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade scikit-learn -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><h2 id="4-打包二进制文件"><a href="#4-打包二进制文件" class="headerlink" title="4. 打包二进制文件"></a>4. 打包二进制文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -F &#x27;xxx.py&#x27;</span><br></pre></td></tr></table></figure><h2 id="5-查看所有包"><a href="#5-查看所有包" class="headerlink" title="5. 查看所有包"></a>5. 查看所有包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Anaconda </tag>
            
            <tag> Python </tag>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平面最近点对 POJ-3714 Raid</title>
      <link href="/2022/06/20/%E7%AE%97%E6%B3%95/%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9/"/>
      <url>/2022/06/20/%E7%AE%97%E6%B3%95/%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定$n(n \leq 100000)$个标记为$s$的点$(xs_{i},ys_{i})$和$n$个标记为$a$的点$(xa_{i},ya_{i})$，求两种点之间的最小距离。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题很像平面最近点对，不同点仅仅是本题中的点上是有标签的，所以仍然考虑平面最近点对用到的分治法。</p><p>下面的图片是一个平面最近点对问题的图示。用分治法解决此问题的总体思想，就是先求出黑色直线左右两端点集的最近点对，然后在对结果进行合并，之所以要合并，是因为最近的点对中的两个点可能一个在左侧集合，一个在右侧集合。</p><p>既然我们已经求出了左右两端的最近点对的距离（$d_1,d_2$，以及$d &#x3D; \min(d_1,d_2)$，本例中$d&#x3D;1$），我们当然要充分利用这个已知信息，从而排除不可能的点对，减少枚举的数量。在图中，我们选定的中心分割点是$V$点（它在之前被划分到左侧子问题）。</p><p>如果左右两侧的点的连线长度小于$d$，那么就意味着这两个点一定被包含在一个圆中，这个圆满足圆心在黑色直线上，且半径为$d$。而这些圆包络的面积，就是一个以分割点横坐标$V_x$为中心，宽度为$2d$的一个无限长矩形。如图中橙色直线所示。</p><p>在合并过程中，我们只需要关心矩形内的点即可，可以使用<strong>鸽巢原理</strong>证明，对于矩形中的一个点$M$，与它连接后得到长度小于$d$的线段$MP$的点$P$最多有7个。</p><p>严谨的证明见<a href="https://oi-wiki.org/geometry/nearest-points/">oi-wiki 平面最近点对</a></p><p><img src="/assets/mdpics/h8547e62c2.png" alt="平面最近点对问题图示"></p><p>回到本题，点之间增加了标签，该怎么办呢？那就只计算和更新标签不同的点的距离就好了。其他的做法和平面最近点对并无不同。</p><h2 id="代码实现及注释"><a href="#代码实现及注释" class="headerlink" title="代码实现及注释"></a>代码实现及注释</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USE_METHOD 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN (100000 + 50)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 99999999999999.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span> &#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span> points[MAXN * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span> buffer[MAXN * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpx</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> point &amp;x, <span class="type">const</span> <span class="keyword">struct</span> point &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.x &lt; y.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpy</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> point &amp;x, <span class="type">const</span> <span class="keyword">struct</span> point &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.y &lt; y.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dist</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> point &amp;p1, <span class="type">const</span> <span class="keyword">struct</span> point &amp;p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((p<span class="number">1.</span>x - p<span class="number">2.</span>x) * (p<span class="number">1.</span>x - p<span class="number">2.</span>x) + (p<span class="number">1.</span>y - p<span class="number">2.</span>y) * (p<span class="number">1.</span>y - p<span class="number">2.</span>y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span> INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> midx = points[mid].x;</span><br><span class="line">    <span class="type">double</span> d = std::<span class="built_in">min</span>(<span class="built_in">solve</span>(l, mid), <span class="built_in">solve</span>(mid + <span class="number">1</span>, r));</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_METHOD == 1</span></span><br><span class="line">    <span class="comment">// method 1: merge sort</span></span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, sz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (points[i].y &lt;= points[j].y) buffer[sz++] = points[i++];</span><br><span class="line">        <span class="keyword">else</span> buffer[sz++] = points[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) buffer[sz++] = points[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) buffer[sz++] = points[j++];</span><br><span class="line">    <span class="keyword">for</span> (i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        points[i] = buffer[i - l];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">abs</span>(points[i].x - midx) &lt; d) &#123;</span><br><span class="line">            buffer[cnt++] = points[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_METHOD == 2</span></span><br><span class="line">    <span class="comment">// method 2: std::sort</span></span><br><span class="line">    std::<span class="built_in">sort</span>(buffer, buffer + cnt, cmpy);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; cnt; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer[j].y - buffer[i].y &gt; d) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (buffer[j].type != buffer[i].type) &#123;</span><br><span class="line">                d = std::<span class="built_in">min</span>(d, <span class="built_in">dist</span>(buffer[j], buffer[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf&quot;</span>, &amp;points[i].x, &amp;points[i].y);</span><br><span class="line">            points[i].type = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt; n * <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf&quot;</span>, &amp;points[i].x, &amp;points[i].y);</span><br><span class="line">            points[i].type = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::<span class="built_in">sort</span>(points, points + <span class="number">2</span> * n, cmpx);</span><br><span class="line">        <span class="type">double</span> ans = <span class="built_in">solve</span>(<span class="number">0</span>, <span class="number">2</span> * n - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.3f\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 分治法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java高速输入输出</title>
      <link href="/2022/06/18/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java%E9%AB%98%E9%80%9F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
      <url>/2022/06/18/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java%E9%AB%98%E9%80%9F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="Scanner类的问题"><a href="#Scanner类的问题" class="headerlink" title="Scanner类的问题"></a>Scanner类的问题</h2><p>对于一般情况来说，<code>java.util.scanner</code>类可以解决输入的大部分需求。那么，这个类是如何解决输入格式化问题的？答案是使用正则表达式匹配。正则表达式的解析速度是有瓶颈的，使用正则表达式，虽然可以尽可能保证输入数据的合法性，但会严重影响输入的性能。尤其是面对大数据时。所以，有没有一种办法，既不用手写输入函数，又可以提高输入的速度呢？答案当然是肯定的。</p><h2 id="Java-Stream-Tokenizer类实现快速输入"><a href="#Java-Stream-Tokenizer类实现快速输入" class="headerlink" title="Java Stream Tokenizer类实现快速输入"></a>Java Stream Tokenizer类实现快速输入</h2><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><ol><li><p>使用的输入文本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python之字符串</span><br><span class="line">阅读 293</span><br><span class="line">python基础知识（一）：入门必备</span><br><span class="line">阅读 574</span><br><span class="line">JS中ArrayBuffer、Uint8Array、Blob与文本字符之间的相互转换</span><br></pre></td></tr></table></figure></li><li><p>使用方法如下，注意使用StreamTokenizer的函数要增加一个<code>throws IOException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">token</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 显示当前目录</span></span><br><span class="line">        <span class="comment">// System.out.println(System.getProperty(&quot;user.dir&quot;));</span></span><br><span class="line">        <span class="comment">// System.out.println(directory);</span></span><br><span class="line">        <span class="comment">//通过传入一个FileReader来构建一个StreamTokenizer。这里读取的是本地的一个txt文件。</span></span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">stk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span></span><br><span class="line">            <span class="comment">// (new File(&quot;D:\\Source Files\\Java training\\learning\\src\\main\\java\\com\\java\\io\\text.in&quot;)));</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;learning\\src\\main\\java\\com\\java\\io\\text.in&quot;</span>)));</span><br><span class="line">        <span class="comment">//1     stk.resetSyntax();</span></span><br><span class="line">        <span class="comment">//2     stk.ordinaryChar(&#x27;\&quot;&#x27;);</span></span><br><span class="line">        <span class="comment">//3     stk.ordinaryChar(&#x27;/&#x27;);</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//当没有读取到文件结尾时，不停调用nextToken方法，然后将每一个token及其行号打印出来。</span></span><br><span class="line">            <span class="keyword">while</span> (stk.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">switch</span> (stk.ttype) &#123;</span><br><span class="line">                <span class="keyword">case</span> StreamTokenizer.TT_WORD:</span><br><span class="line">                    s = stk.sval;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> StreamTokenizer.TT_NUMBER:</span><br><span class="line">                    s = String.valueOf(stk.nval);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    s = stk.sval;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(stk.toString());</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//将标准输入流传入StreamTokenizer中。</span></span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="keyword">while</span>(in.nextToken() != StreamTokenizer.TT_EOF)</span><br><span class="line">        &#123;</span><br><span class="line">            a = (<span class="type">int</span>)in.nval;</span><br><span class="line">            in.nextToken();</span><br><span class="line">            b = (<span class="type">int</span>)in.nval;</span><br><span class="line">            <span class="comment">//out.println(a + b);</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a + b = &quot;</span>+(a+b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将缓存区中的数据真实写出。</span></span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        token();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Token[python之字符串], line 1</span><br><span class="line">python之字符串</span><br><span class="line">Token[阅读], line 2</span><br><span class="line">阅读</span><br><span class="line">Token[n=293.0], line 2</span><br><span class="line">293.0</span><br><span class="line">Token[python基础知识（一）：入门必备], line 3</span><br><span class="line">python基础知识（一）：入门必备</span><br><span class="line">Token[阅读], line 4</span><br><span class="line">阅读</span><br><span class="line">Token[n=574.0], line 4</span><br><span class="line">574.0</span><br><span class="line">Token[JS中ArrayBuffer、Uint8Array、Blob与文本字符之间的相互转换], line 5</span><br><span class="line">JS中ArrayBuffer、Uint8Array、Blob与文本字符之间的相互转换</span><br></pre></td></tr></table></figure></li></ol><h3 id="更多使用方法"><a href="#更多使用方法" class="headerlink" title="更多使用方法"></a>更多使用方法</h3><p>更多的介绍<a href="https://www.runoob.com/manual/jdk11api/java.base/java/io/StreamTokenizer.html">在此</a></p><p>另一些应用详见代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTokenizerInput</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">// Input(); // 输入字符串和数字</span></span><br><span class="line"><span class="comment">// LoopInputString(); // 循环输入字符串</span></span><br><span class="line">LoopInputDouble(); <span class="comment">// 循环输入数字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输入字符串和数字 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Input</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)));</span><br><span class="line"></span><br><span class="line">in.nextToken(); <span class="comment">// 解析下一个标记。每次调用sval或nval时候都需要调用一下</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> in.sval; <span class="comment">// 输入字符串</span></span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line">in.nextToken(); <span class="comment">// 解析下一个标记。每次调用sval或nval时候都需要调用一下</span></span><br><span class="line"><span class="type">double</span> <span class="variable">num</span> <span class="operator">=</span> in.nval; <span class="comment">// 输入数字</span></span><br><span class="line">System.out.println(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 循环输入字符串 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">LoopInputString</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)));</span><br><span class="line"><span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOL) &#123; <span class="comment">// 当下一个输入不是行末尾时</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> in.sval; <span class="comment">// 输入字符串</span></span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 循环输入数字 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">LoopInputDouble</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)));</span><br><span class="line"><span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOL) &#123; <span class="comment">// 当下一个输入不是行末尾时</span></span><br><span class="line"><span class="type">double</span> <span class="variable">num</span> <span class="operator">=</span> in.nval; <span class="comment">// 输入数字</span></span><br><span class="line">System.out.println(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/weixin_44034328/article/details/103447203">https://blog.csdn.net/weixin_44034328/article/details/103447203</a></p><h3 id="算法题目应用"><a href="#算法题目应用" class="headerlink" title="算法题目应用"></a>算法题目应用</h3><p><a href="https://www.luogu.com.cn/record/list?pid=P5995">题目地址</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.icpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rect</span> &#123;</span><br><span class="line">    <span class="type">int</span> lw, rw, lh, rh;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">P5995</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">1000010</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> rect[] rs = <span class="keyword">new</span> <span class="title class_">rect</span>[MAXN];</span><br><span class="line">    <span class="comment">// private static Scanner in = new Scanner(System.in);</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span> lw, <span class="type">int</span> rw, <span class="type">int</span> lh, <span class="type">int</span> rh, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs[i].lh &lt;= lh &amp;&amp; rh &lt;= rs[i].rh &amp;&amp; rs[i].lw &lt;= lw &amp;&amp; rw &lt;= rs[i].rw) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        in.nextToken();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) in.nval;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lw</span> <span class="operator">=</span> <span class="number">0</span>, rw = <span class="number">0</span>, lh = <span class="number">0</span>, rh = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            rs[i] = <span class="keyword">new</span> <span class="title class_">rect</span>();</span><br><span class="line">            in.nextToken();rs[i].lw = (<span class="type">int</span>) in.nval;</span><br><span class="line">            in.nextToken();rs[i].rw = (<span class="type">int</span>) in.nval;</span><br><span class="line">            in.nextToken();rs[i].lh = (<span class="type">int</span>) in.nval;</span><br><span class="line">            in.nextToken();rs[i].rh = (<span class="type">int</span>) in.nval;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                lw = rs[i].lw;rw = rs[i].rw;</span><br><span class="line">                lh = rs[i].lh;rh = rs[i].rh;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lw = Math.min(lw, rs[i].lw);rw = Math.max(rw, rs[i].rw);</span><br><span class="line">                lh = Math.min(lh, rs[i].lh);rh = Math.max(rh, rs[i].rh);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (judge(lw, rw, lh, rh, n)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;TAK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;NIE&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        in.nextToken();</span><br><span class="line">        <span class="type">int</span> <span class="variable">T</span> <span class="operator">=</span> (<span class="type">int</span>) in.nval;</span><br><span class="line">        <span class="keyword">while</span> (T &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            solve();</span><br><span class="line">            T--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="PrintWriterOutput快速输出"><a href="#PrintWriterOutput快速输出" class="headerlink" title="PrintWriterOutput快速输出"></a>PrintWriterOutput快速输出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintWriterOutput</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;This is the string you want to output.&quot;</span>;</span><br><span class="line">out.print(str);</span><br><span class="line">out.println(str);</span><br><span class="line">out.printf(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">out.flush(); <span class="comment">// 记得刷新一下在控制台输出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令行实现的浏览器——curl</title>
      <link href="/2022/04/28/Sharp%20Tools/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E5%85%B7curl/"/>
      <url>/2022/04/28/Sharp%20Tools/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E5%85%B7curl/</url>
      
        <content type="html"><![CDATA[<h2 id="一，发送请求"><a href="#一，发送请求" class="headerlink" title="一，发送请求"></a>一，发送请求</h2><p>下载单个文件，默认将输出打印到标准输出中(STDOUT)中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl www.baidu.com</span><br></pre></td></tr></table></figure><h2 id="二，下载文件"><a href="#二，下载文件" class="headerlink" title="二，下载文件"></a>二，下载文件</h2><p>Windows PowerShell中自带的curl实际上是Invoke-WebRequest的软链接，并不是像Linux一样的curl。如果想安装curl，需要先下载curl for windows。输入以下命令即可。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">curl</span> <span class="literal">-o</span> <span class="built_in">curl</span><span class="literal">-7</span>.<span class="number">83.0</span><span class="literal">-win64-mingw</span>.zip https://curl.se/windows/dl<span class="literal">-7</span>.<span class="number">83.0</span>/<span class="built_in">curl</span><span class="literal">-7</span>.<span class="number">83.0</span><span class="literal">-win64-mingw</span>.zip</span><br></pre></td></tr></table></figure><p>之后配置环境变量，然后使用下面的命令删除软链接（或将所有的curl替换为curl.exe）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">del</span> Alias:\curl</span><br></pre></td></tr></table></figure><p>此时执行curl（如果不删除软链接，则应执行curl.exe），如果输出如下，说明已经配置好了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl: try &#x27;curl --help&#x27; for more information</span><br></pre></td></tr></table></figure><p>为了不让命令特别长，也为了更直观的显示各种命令的作用，下面的命令是换行展示的，在实际使用中应该全部使用空格隔开并写在一行。</p><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>-o：最基本的下载功能。将文件按指定的名称保存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl </span><br><span class="line">-o mygettext.html </span><br><span class="line">http://www.gnu.org/software/gettext/manual/gettext.html</span><br></pre></td></tr></table></figure><p>-O：将文件按照服务器上的文件名保存在本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl </span><br><span class="line">-O </span><br><span class="line">http://www.gnu.org/software/gettext/manual/gettext.html</span><br></pre></td></tr></table></figure><p>另一种效果相同的方法是输出重定向</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://www.yahoo.com &gt; mygettext.html </span><br></pre></td></tr></table></figure><h3 id="使用代理进行下载"><a href="#使用代理进行下载" class="headerlink" title="使用代理进行下载"></a>使用代理进行下载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl </span><br><span class="line">-x 123.45.67.89:1080 </span><br><span class="line">-o page.html </span><br><span class="line">http://www.yahoo.com </span><br></pre></td></tr></table></figure><h3 id="cookie相关的信息"><a href="#cookie相关的信息" class="headerlink" title="cookie相关的信息"></a>cookie相关的信息</h3><ol><li>-D参数，保存cookie信息</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl </span><br><span class="line">-x 123.45.67.89:1080 </span><br><span class="line">-o page1.html </span><br><span class="line">-D cookie0002.txt </span><br><span class="line">http://www.yahoo.com </span><br></pre></td></tr></table></figure><ol start="2"><li>-b参数，追加cookie信息</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl </span><br><span class="line">-x 123.45.67.89:1080 </span><br><span class="line">-o page1.html -D cookie0002.txt </span><br><span class="line">-b cookie0001.txt </span><br><span class="line">http://www.yahoo.com </span><br></pre></td></tr></table></figure><h3 id="curl假扮浏览器"><a href="#curl假扮浏览器" class="headerlink" title="curl假扮浏览器"></a>curl假扮浏览器</h3><p>-A参数，为了防止curl请求被识别为爬虫，我们有时需要指定浏览器请求头：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl </span><br><span class="line">-A &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)&quot;</span><br><span class="line">-x 123.45.67.89:1080</span><br><span class="line">-o page.html</span><br><span class="line">-D cookie0001.txt</span><br><span class="line">http://www.yahoo.com</span><br></pre></td></tr></table></figure><h3 id="避开防盗链"><a href="#避开防盗链" class="headerlink" title="避开防盗链"></a>避开防盗链</h3><p>原理：设置refer从而通过http的refer检查</p><p>使用-e参数设置refer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl </span><br><span class="line">-A &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)&quot; </span><br><span class="line">-x 123.45.67.89:1080 </span><br><span class="line">-e &quot;mail.yahoo.com&quot; </span><br><span class="line">-o page.html </span><br><span class="line">-D cookie0001.txt </span><br><span class="line">http://www.yahoo.com</span><br></pre></td></tr></table></figure><h3 id="高级下载操作"><a href="#高级下载操作" class="headerlink" title="高级下载操作"></a>高级下载操作</h3><ul><li><p>批量下载：保存图片screen2.JPG、screen3.JPG、….、screen10.JPG</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O http://cgi2.tky.3web.ne.jp/~zzh/screen[2-10].JPG</span><br></pre></td></tr></table></figure></li><li><p>自定义文件名的下载：</p><p>采用上面的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O http://cgi2.tky.3web.ne.jp/~/[001-201].JPG</span><br></pre></td></tr></table></figure><p>由于zzh，nick下的文件名都是001，002…，201，下载下来的文件重名，后面的把前面的文件都给覆盖掉了。所以我们使用这样的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o #2_#1.jpg-600 http://cgi2.tky.3web.ne.jp/~/[001-201].JPG </span><br></pre></td></tr></table></figure><p>#1是变量，指的是这部分，第一次取值zzh，第二次取值nick<br>#2代表的变量，则是第二段可变部分—[001-201]，取值从001逐一加到201<br>这样，自定义出来下载下来的文件名，就变成了这样：<br>原来： ~zzh&#x2F;001.JPG —&gt; 下载后： 001-zzh.JPG<br>原来： ~nick&#x2F;001.JPG —&gt; 下载后： 001-nick.JPG</p></li><li><p>断点续传：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -c -O http://cgi2.tky.3wb.ne.jp/~zzh/screen1.JPG</span><br></pre></td></tr></table></figure></li><li><p>分块下载</p><p>不过并不支持合并。。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -r 0-10240 -o &quot;zhao.part1&quot; http:/cgi2.tky.3web.ne.jp/~zzh/zhao1.mp3 &amp;\</span><br><span class="line">curl -r 10241-20480 -o &quot;zhao.part1&quot; http:/cgi2.tky.3web.ne.jp/~zzh/zhao1.mp3 &amp;\</span><br><span class="line">curl -r 20481-40960 -o &quot;zhao.part1&quot; http:/cgi2.tky.3web.ne.jp/~zzh/zhao1.mp3 &amp;\</span><br><span class="line">curl -r 40961- -o &quot;zhao.part1&quot; http:/cgi2.tky.3web.ne.jp/~zzh/zhao1.mp3 </span><br></pre></td></tr></table></figure></li><li><p>FTP传输协议：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -u name:passwd ftp://ip:port/path/file</span><br><span class="line">curl ftp://name:passwd@ip:port/path/file </span><br></pre></td></tr></table></figure></li></ul><h2 id="三，上传文件"><a href="#三，上传文件" class="headerlink" title="三，上传文件"></a>三，上传文件</h2><p>上传的option是 -T。</p><h3 id="HTTP上传"><a href="#HTTP上传" class="headerlink" title="HTTP上传"></a>HTTP上传</h3><p>这时候，使用的协议是HTTP的PUT method。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -T localfile http://cgi2.tky.3web.ne.jp/~zzh/abc.cgi </span><br></pre></td></tr></table></figure><h3 id="FTP上传"><a href="#FTP上传" class="headerlink" title="FTP上传"></a>FTP上传</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -T localfile -u name:passwd ftp://upload_site:port/path/ </span><br></pre></td></tr></table></figure><h3 id="HTTP提交表单"><a href="#HTTP提交表单" class="headerlink" title="HTTP提交表单"></a>HTTP提交表单</h3><p>http提交一个表单，比较常用的是POST模式和GET模式：</p><ol><li><p>GET：GET模式什么option都不用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://www.yahoo.com/login.cgi?user=nickwolfe&amp;password=12345 </span><br></pre></td></tr></table></figure></li><li><p>POST：POST模式的option则是 -d </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d &quot;user=nickwolfe&amp;password=12345&quot; http://www.yahoo.com/login.cgi </span><br></pre></td></tr></table></figure><p>上面的操作就相当于向这个站点发出一次登陆申请。<br>用GET模式还是POST模式，要看对面服务器的程序设定。<br>POST模式下的文件上的文件上传，这样一个HTTP表单，我们要用curl进行模拟：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -F upload=@localfile -F nick=go http://cgi2.tky.3web.ne.jp/~zzh/up_file.cgi </span><br></pre></td></tr></table></figure></li></ol><h2 id="四，更多帮助和补充"><a href="#四，更多帮助和补充" class="headerlink" title="四，更多帮助和补充"></a>四，更多帮助和补充</h2><p>更多的帮助，在curl的<a href="https://curl.se/">官方网站</a>，和<code>curl --help</code>中。如果在使用中遇到了更多需求，我将会继续补充。</p><p>参考：</p><p><a href="https://www.html.cn/tools/88206.html">https://www.html.cn/tools/88206.html</a></p><p><a href="https://cloud.tencent.com/developer/news/359375">https://cloud.tencent.com/developer/news/359375</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马的周游问题(knight move circuit)</title>
      <link href="/2022/04/12/%E7%AE%97%E6%B3%95/%E9%A9%AC%E7%9A%84%E5%91%A8%E6%B8%B8/"/>
      <url>/2022/04/12/%E7%AE%97%E6%B3%95/%E9%A9%AC%E7%9A%84%E5%91%A8%E6%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个$n$行$m$列的棋盘，任意给出一个马的周游路线。周游路线是指从起始点开始，不重不漏的经过棋盘上的每一个格子，最后再回到起始点的路线。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 5</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 2   25   22   13    4</span><br><span class="line">23   12    3   30   21</span><br><span class="line">26    1   24    5   14</span><br><span class="line">11   16    9   20   29</span><br><span class="line"> 8   27   18   15    6</span><br><span class="line">17   10    7   28   19</span><br></pre></td></tr></table></figure><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>本题是一个哈密顿路问题，正常来说，哈密顿问题是一个NP完全问题。不过，由马的周游问题的特殊性，我们可以通过将问题分解为子问题的方式。</p><p>周游问题的特殊性见下图。</p><p><img src="/assets/al/horse-c.png" alt="周游问题的特性"></p><p>从图中可以看到，我们将问题分解后，得到的子问题的解法大致相同，而且两个子问题很容易合并。</p><h3 id="子问题合并"><a href="#子问题合并" class="headerlink" title="子问题合并"></a>子问题合并</h3><p>子问题合并的规则如下。令$p_1, p_2\in E$，$p_1’,p_2’ \in E’$：</p><ol><li>$p_1, p_2$之间，$p_1’,p_2’$之间都有无向边连接。</li><li>$p_1, p’_1$和$p_2,p_2’$可达，或$p_1, p’_2$和$p_1’, p_2$可达。</li></ol><p>之后去除原来的边，加上连接两个图的边，即可完成两个回路的连接。</p><p>程序中<code>void merge(struct subq q1, struct subq q2)</code>对应了此过程。</p><h3 id="子问题求解"><a href="#子问题求解" class="headerlink" title="子问题求解"></a>子问题求解</h3><p>将要求解的子问题$q$具有如下的性质：</p><ol><li>问题的范围可以通过四个变量描述，分别是子问题的起始位置$(x_0, y_0)$，子问题的规模$(n, m)$。</li><li>必须满足$n * m\ \text{mod}\ 2 &#x3D;&#x3D; 0, \min(n,m)\geq5$，问题才有解[^1]。</li><li>问题是可合并的。</li><li>当问题规模较小时，可以使用回溯法求解。</li></ol><p>回溯法的启发式优化：</p><ol><li>扩展节点时，优先扩展可能选择数目最小的节点。代码中的<code>int get_possible(int x, int y, struct subq q)</code>函数实现了计算一个节点的可能选择数目。</li><li>扩展节点时，在(1)的条件下，尽可能扩展离中点远的节点。</li><li>起始节点选在中间。</li></ol><p>程序中<code>void dfs(int x, int y, int cnt, struct subq q)</code>，<code>void solve(struct subq q)</code>对应了此过程。</p><h3 id="原问题分解"><a href="#原问题分解" class="headerlink" title="原问题分解"></a>原问题分解</h3><p>经过优化的回溯法非常适合求解$|m-n|\leq 3(5\leq m,n \leq 16)$的数据，所以在分解问题时，我们在保证分解后问题都有解的情况下，让子问题尽量接近一个正方形。</p><p>我们有如下的分解方法：</p><ol><li>如果$n,m$均为偶数，如果$n\geq m$，那么分解问题为两个$n&#x2F;2$，$m$的子问题。$n\leq m$同理。</li><li>如果$n$是奇数，$m$是偶数，如果$n\geq m$，那么分解问题为$\lfloor\frac{n}{2}\rfloor,m$与$n-\lfloor\frac{n}{2}\rfloor$的子问题。如果$n\leq m$，令$t$为最接近$\lfloor\frac{n}{2}\rfloor$的偶数，则将问题分解为$n, t$与$n, m - t$的子问题。另一种情况同理。</li><li>如果$n,m$均为奇数，无解。</li></ol><p>程序实现中<code>void div_conquer(struct subq q)</code>函数对应了此过程。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ol><li><p>分治法思想</p><p>令$n\times m$的周游问题规模为$N$。每次合并子问题需要的代价是图的合并和寻找满足合并条件的点产生的总代价，为子问题的规模。列出复杂度的递推方程：<br>$$<br>W(N)&#x3D;W(\frac{N}{2})+N<br>$$<br>通过主定理或换元迭代法，可以求出分治法思想的时间复杂度为$O(N\log N)$，也就是$O(nm\log nm)$</p></li><li><p>回溯法求解</p><p>对于最终的小规模问题，由于在暴力求解中使用了启发式函数进行搜索，时间复杂度变得难以估计，理论上的时间复杂度是$O(2^N)$的，但实际情况要好的多。这里假设解决所有子问题的总复杂度为$k$，它是一个不能忽略的很大的常数，它是远大于$\log N$的，但又远小于$2^N$。</p><p>通过单独运行回溯法程序，是可以在有限时间内求解100以内的问题的（大约30秒）。</p></li><li><p>结论</p><p>总时间复杂度为：<br>$$<br>O(nmk)<br>$$</p></li></ol><h2 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h2><p>下面的程序可以实现1s内对于$m,n\leq 260$的求解，可以在一分钟内求解$m,n\leq 1000$规模的问题。代码中的关键部分都添加了注释以说明各个模块的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file horse circuit problem.cpp</span></span><br><span class="line"><span class="comment"> * @author Redleaves699 (Algorithm_sort@163.com)</span></span><br><span class="line"><span class="comment"> * @brief A programme to solve horse circuit problem. </span></span><br><span class="line"><span class="comment"> * @details compiler options: g++ horse.cpp -o horse</span></span><br><span class="line"><span class="comment"> * @version 1.0</span></span><br><span class="line"><span class="comment"> * @date 2022-04-12</span></span><br><span class="line"><span class="comment"> * @copyright Copyright (c) 2022</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN (3000 + 10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a, b) ((a) &lt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> abs(a) ((a) &gt; 0 ? (a) : (-(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> book[MAXN][MAXN], book2[MAXN][MAXN]; <span class="comment">// book在暴力求解中标记点是否访问过，book2表示最终结果</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; G[MAXN * MAXN], G_[MAXN * MAXN]; <span class="comment">// G_在暴力求解中存储子图，G表示最终结果图</span></span><br><span class="line"><span class="comment">// 方向数组，用来表示马所有可能的前进方向</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dir[][<span class="number">2</span>] = &#123; &#123;<span class="number">-2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">1</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">// 问题的规模</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief subq结构体表示问题的形式</span></span><br><span class="line"><span class="comment"> * x0, y0 : 子问题右上角的坐标</span></span><br><span class="line"><span class="comment"> * n, m : 子问题的规模</span></span><br><span class="line"><span class="comment"> * startx, starty : 子问题中马开始行动的位置。我们总是选择中间位置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">subq</span>&#123;</span><br><span class="line">    <span class="type">int</span> x0, y0;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> startx, starty; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 这个结构体是为了启发式搜索服务的，它描述了马在某个位置的可能选择</span></span><br><span class="line"><span class="comment"> * x, y : 马当前的位置</span></span><br><span class="line"><span class="comment"> * possible : 马在当前位置能够跳到点的数目</span></span><br><span class="line"><span class="comment"> * distance : 距离子问题中点的距离</span></span><br><span class="line"><span class="comment"> * dirw : 马能够选择的方向</span></span><br><span class="line"><span class="comment"> * overload &lt; : for c++ stl priority_queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">choice</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y, possible, distance, dirw;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> <span class="keyword">struct</span> choice &amp;c) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (possible == c.possible) &#123;</span><br><span class="line">            <span class="keyword">if</span> (distance == c.distance) &#123;</span><br><span class="line">                <span class="keyword">return</span> dirw &gt; c.dirw;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> distance &lt; c.distance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> possible &gt; c.possible;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 一个计算矩阵中点编号的内联函数</span></span><br><span class="line"><span class="comment"> * @param x coodinate x</span></span><br><span class="line"><span class="comment"> * @param y coodinate y</span></span><br><span class="line"><span class="comment"> * @return int </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">num</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m * x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 判断一个点是否超过了子问题的范围</span></span><br><span class="line"><span class="comment"> * @param x coodinate x</span></span><br><span class="line"><span class="comment"> * @param y coodinate y</span></span><br><span class="line"><span class="comment"> * @param q 子问题信息</span></span><br><span class="line"><span class="comment"> * @return true/false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check_in_q</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="keyword">struct</span> subq q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q.x0 &lt;= x &amp;&amp; x &lt; q.x0 + q.n &amp;&amp; q.y0 &lt;= y &amp;&amp; y &lt; q.y0 + q.m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取马在某个位置所有可能的选择</span></span><br><span class="line"><span class="comment"> * @param x coodinate x</span></span><br><span class="line"><span class="comment"> * @param y coodinate y</span></span><br><span class="line"><span class="comment"> * @param q 子问题信息</span></span><br><span class="line"><span class="comment"> * @return int </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_possible</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="keyword">struct</span> subq q)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> x_ = x + dir[i][<span class="number">0</span>], y_ = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check_in_q</span>(x_, y_, q) &amp;&amp; !book[x_][y_]) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 计算一个点距离子问题中点的距离</span></span><br><span class="line"><span class="comment"> * @param x coodinate x</span></span><br><span class="line"><span class="comment"> * @param y coodinate y</span></span><br><span class="line"><span class="comment"> * @param q 子问题信息</span></span><br><span class="line"><span class="comment"> * @return int </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_distance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="keyword">struct</span> subq q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x - (<span class="number">2</span> * q.x0 + q.n) / <span class="number">2</span>) + <span class="built_in">abs</span>(y - (<span class="number">2</span> * q.y0 + q.m) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 判断图中编号num1,num2的点是否可达</span></span><br><span class="line"><span class="comment"> * @param num1 we define that num1 as the number of point (num1 / m, num1 % m)</span></span><br><span class="line"><span class="comment"> * @param num2 we define that num2 as the number of point (num2 / m, num2 % m)</span></span><br><span class="line"><span class="comment"> * @return true/false </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">existPath</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[num1].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G[num1][i] == num2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[num2].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G[num2][i] == num1) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 暴力寻找四个满足合并条件的点</span></span><br><span class="line"><span class="comment"> * @param q1 sub-question1</span></span><br><span class="line"><span class="comment"> * @param q2 sub-question2</span></span><br><span class="line"><span class="comment"> * @return struct subq (这里subq的意思不再是子问题，它仅仅是为这个函数返回多个值提供了便利)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">subq</span> <span class="built_in">find_pairs</span>(<span class="keyword">struct</span> subq q1, <span class="keyword">struct</span> subq q2) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">subq</span> ans = &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> s1, s2;</span><br><span class="line">    <span class="comment">// 看看应该枚举什么地方</span></span><br><span class="line">    <span class="keyword">if</span> (q<span class="number">1.</span>x0 == q<span class="number">2.</span>x0) &#123;</span><br><span class="line">        s2 = q<span class="number">2.</span>y0 - <span class="number">1</span>, s1 = q<span class="number">1.</span>x0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (q<span class="number">1.</span>y0 == q<span class="number">2.</span>y0) &#123;</span><br><span class="line">        s1 = q<span class="number">2.</span>x0 - <span class="number">1</span>, s2 = q<span class="number">1.</span>y0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 暴力寻找四个点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = s1; x &lt; q<span class="number">1.</span>x0 + q<span class="number">1.</span>n; ++x) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y = s2; y &lt; q<span class="number">1.</span>y0 + q<span class="number">1.</span>m; ++y) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                <span class="type">int</span> x_ = x + dir[i][<span class="number">0</span>], y_ = y + dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check_in_q</span>(x_, y_, q2)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                        <span class="type">int</span> x__ = x_ + dir[j][<span class="number">0</span>], y__ = y_ + dir[j][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">check_in_q</span>(x__, y__, q2) &amp;&amp; <span class="built_in">existPath</span>(<span class="built_in">num</span>(x_, y_), <span class="built_in">num</span>(x__, y__))) &#123;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; ++k) &#123;</span><br><span class="line">                                <span class="type">int</span> x4 = x__ + dir[k][<span class="number">0</span>], y4 = y__ + dir[k][<span class="number">1</span>];</span><br><span class="line">                                <span class="keyword">if</span> (<span class="built_in">check_in_q</span>(x4, y4, q1) &amp;&amp; <span class="built_in">existPath</span>(<span class="built_in">num</span>(x, y), <span class="built_in">num</span>(x4, y4))) &#123;</span><br><span class="line">                                    <span class="keyword">return</span> ans = &#123;x, y, i, j, k, <span class="number">0</span>&#125;;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> note[MAXN * MAXN]; <span class="comment">// 只被travel函数使用，用来标记某个点是否被访问</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 遍历新生成的图，将生成的图重新编号</span></span><br><span class="line"><span class="comment"> * @param x coodinate x</span></span><br><span class="line"><span class="comment"> * @param y coodinate y</span></span><br><span class="line"><span class="comment"> * @param q1 子问题1的信息</span></span><br><span class="line"><span class="comment"> * @param q2 子问题2的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">travel</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="keyword">struct</span> subq q1, <span class="keyword">struct</span> subq q2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> xx = x, yy = y;</span><br><span class="line">    <span class="built_in">memset</span>(note, <span class="number">0</span>, <span class="built_in">sizeof</span>(note));</span><br><span class="line">    note[<span class="built_in">num</span>(xx, yy)] = <span class="number">1</span>;</span><br><span class="line">    book2[xx][yy] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n = q<span class="number">1.</span>m * q<span class="number">1.</span>n + q<span class="number">2.</span>m * q<span class="number">2.</span>n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">2</span>; cnt &lt;= n; ++cnt) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> x_ = xx + dir[i][<span class="number">0</span>], y_ = yy + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">check_in_q</span>(x_, y_, q1) || <span class="built_in">check_in_q</span>(x_, y_, q2)) &amp;&amp; !note[<span class="built_in">num</span>(x_, y_)] </span><br><span class="line">                &amp;&amp; <span class="built_in">existPath</span>(<span class="built_in">num</span>(x_, y_), <span class="built_in">num</span>(xx, yy))) &#123;</span><br><span class="line">                note[<span class="built_in">num</span>(x_, y_)] = <span class="number">1</span>;</span><br><span class="line">                book2[x_][y_] = cnt;</span><br><span class="line">                xx = x_, yy = y_;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ok = <span class="number">0</span>; <span class="comment">// 如果dfs寻找到答案，就不再寻找了</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SmallestSize = <span class="number">16</span>; <span class="comment">// the smallest scale need to be solved by dfs</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 使用启发式搜索暴力解决数据规模为 5&lt;= n,m &lt;= SmallestSize(line : 197)的问题</span></span><br><span class="line"><span class="comment"> * @param x coodinate x</span></span><br><span class="line"><span class="comment"> * @param y coodinate y</span></span><br><span class="line"><span class="comment"> * @param cnt 被访问到的点的个数，用来标记点的访问次序</span></span><br><span class="line"><span class="comment"> * @param q 子问题信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> cnt, <span class="keyword">struct</span> subq q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ok) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (cnt == q.m * q.n &amp;&amp; !ok) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> x_ = x + dir[i][<span class="number">0</span>], y_ = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 检查并记录结果</span></span><br><span class="line">            <span class="keyword">if</span> (q.startx == x_ &amp;&amp; q.starty == y_) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = q.x0; i &lt; q.x0 + q.n; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = q.y0; j &lt; q.y0 + q.m; ++j) &#123;</span><br><span class="line">                        G[<span class="built_in">num</span>(i, j)] = G_[<span class="built_in">num</span>(i, j)];</span><br><span class="line">                        book2[i][j] = book[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                G[<span class="built_in">num</span>(q.startx,q.starty)].<span class="built_in">push_back</span>(<span class="built_in">num</span>(x, y));</span><br><span class="line">                G[<span class="built_in">num</span>(x, y)].<span class="built_in">push_back</span>(<span class="built_in">num</span>(q.startx,q.starty));</span><br><span class="line">                ok = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用stl的优先队列实现启发式搜索，方法在前面已经介绍</span></span><br><span class="line">    std::priority_queue&lt;choice&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> x_ = x + dir[i][<span class="number">0</span>], y_ = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check_in_q</span>(x_, y_, q) &amp;&amp; !book[x_][y_] &amp;&amp; ok == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">choice</span> c = &#123;x_, y_, <span class="built_in">get_possible</span>(x_, y_, q), <span class="built_in">get_distance</span>(x_, y_, q), i&#125;;</span><br><span class="line">            pq.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试搜索所有可能的情况</span></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">choice</span> c = pq.<span class="built_in">top</span>();pq.<span class="built_in">pop</span>();</span><br><span class="line">        book[c.x][c.y] = cnt + <span class="number">1</span>; <span class="comment">// 标记已经被访问</span></span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">num</span>(x, y), t_ = <span class="built_in">num</span>(c.x, c.y);</span><br><span class="line">        G_[t].<span class="built_in">push_back</span>(t_); <span class="comment">// 建立图</span></span><br><span class="line">        G_[t_].<span class="built_in">push_back</span>(t);</span><br><span class="line">        <span class="built_in">dfs</span>(c.x, c.y, cnt + <span class="number">1</span>, q);</span><br><span class="line">        <span class="comment">// 恢复原状</span></span><br><span class="line">        G_[t].<span class="built_in">pop_back</span>(); </span><br><span class="line">        G_[t_].<span class="built_in">pop_back</span>();</span><br><span class="line">        book[c.x][c.y] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印最终结果</span></span><br><span class="line"><span class="comment"> * @param q the information of the sub-question</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print_Ans</span><span class="params">(<span class="keyword">struct</span> subq q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = q.x0; i &lt; q.x0 + q.n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = q.y0; j &lt; q.y0 + q.m; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%6d&quot;</span>, book2[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 使用dfs解决5&lt;= n,m &lt;= SmallestSize(line : 202)子问题的前期准备工作</span></span><br><span class="line"><span class="comment"> * @param q 子问题信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">struct</span> subq q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q.n * q.m % <span class="number">2</span> == <span class="number">1</span> || <span class="built_in">min</span>(q.n, q.m) &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d) No answer!\n&quot;</span>, q.n, q.m);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    book[q.startx][q.starty] = <span class="number">1</span>;</span><br><span class="line">    ok = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(q.startx, q.starty, <span class="number">1</span>, q);</span><br><span class="line">    book[q.startx][q.starty] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 删除stl vector中数值为val的元素</span></span><br><span class="line"><span class="comment"> * @param v a c++ stl vector</span></span><br><span class="line"><span class="comment"> * @param val 数值val.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rmv</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;v, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*i == val) v.<span class="built_in">erase</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 合并子问题q1,q2</span></span><br><span class="line"><span class="comment"> * @param q1 子问题q1的信息</span></span><br><span class="line"><span class="comment"> * @param q2 子问题q2的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">struct</span> subq q1, <span class="keyword">struct</span> subq q2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">subq</span> ans = <span class="built_in">find_pairs</span>(q1, q2);</span><br><span class="line">    <span class="keyword">if</span> (ans.x0 == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">//如果什么结果都没返回，证明程序出了问题</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Assert!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;q1 = %d %d %d %d, q2 = %d %d %d %d\n&quot;</span>, q<span class="number">1.</span>x0, q<span class="number">1.</span>y0, q<span class="number">1.</span>n, q<span class="number">1.</span>m, q<span class="number">2.</span>x0, q<span class="number">2.</span>y0, q<span class="number">2.</span>n, q<span class="number">2.</span>m);</span><br><span class="line">        <span class="built_in">assert</span>(ans.x0 == <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到需要合并的四个点</span></span><br><span class="line">    <span class="type">int</span> x1 = ans.x0, y1 = ans.y0;</span><br><span class="line">    <span class="type">int</span> x2 = x1 + dir[ans.n][<span class="number">0</span>], y2 = y1 + dir[ans.n][<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> x3 = x2 + dir[ans.m][<span class="number">0</span>], y3 = y2 + dir[ans.m][<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> x4 = x3 + dir[ans.startx][<span class="number">0</span>], y4 = y3 + dir[ans.startx][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个子图，建立新图</span></span><br><span class="line">    <span class="built_in">rmv</span>(G[<span class="built_in">num</span>(x1, y1)], <span class="built_in">num</span>(x4, y4));</span><br><span class="line">    <span class="built_in">rmv</span>(G[<span class="built_in">num</span>(x4, y4)], <span class="built_in">num</span>(x1, y1));</span><br><span class="line">    <span class="built_in">rmv</span>(G[<span class="built_in">num</span>(x2, y2)], <span class="built_in">num</span>(x3, y3));</span><br><span class="line">    <span class="built_in">rmv</span>(G[<span class="built_in">num</span>(x3, y3)], <span class="built_in">num</span>(x2, y2));</span><br><span class="line">    G[<span class="built_in">num</span>(x2, y2)].<span class="built_in">push_back</span>(<span class="built_in">num</span>(x1, y1));G[<span class="built_in">num</span>(x1, y1)].<span class="built_in">push_back</span>(<span class="built_in">num</span>(x2, y2));</span><br><span class="line">    G[<span class="built_in">num</span>(x4, y4)].<span class="built_in">push_back</span>(<span class="built_in">num</span>(x3, y3));G[<span class="built_in">num</span>(x3, y3)].<span class="built_in">push_back</span>(<span class="built_in">num</span>(x4, y4));</span><br><span class="line">    <span class="comment">// remark the new graph</span></span><br><span class="line">    <span class="comment">// travel(q1.x0, q1.y0, q1, q2);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 使用分治法解决子问题q，原理已经在上面详细说明</span></span><br><span class="line"><span class="comment"> * @param q 子问题q的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">div_conquer</span><span class="params">(<span class="keyword">struct</span> subq q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;q = %d %d\n&quot;, q.n, q.m); // for debug use : watch divided sub-questions</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">5</span> &lt;= q.n &amp;&amp; q.n &lt;= SmallestSize &amp;&amp; <span class="number">5</span> &lt;= q.m &amp;&amp; q.m &lt;= SmallestSize) &#123;</span><br><span class="line">        <span class="built_in">solve</span>(q);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">subq</span> q1, q2;</span><br><span class="line">    <span class="keyword">if</span> ((q.m % <span class="number">2</span> == <span class="number">0</span>) &amp;&amp; (q.n % <span class="number">2</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.n &gt;= q.m) &#123;</span><br><span class="line">            q<span class="number">1.</span>x0 = q.x0, q<span class="number">1.</span>y0 = q.y0, q<span class="number">1.</span>n = q.n / <span class="number">2</span>, q<span class="number">1.</span>m = q.m;</span><br><span class="line">            q<span class="number">1.</span>startx = (<span class="number">2</span> * q<span class="number">1.</span>x0 + q<span class="number">1.</span>n) / <span class="number">2</span>, q<span class="number">1.</span>starty = (<span class="number">2</span> * q<span class="number">1.</span>y0 + q<span class="number">1.</span>m) / <span class="number">2</span>;</span><br><span class="line">            q<span class="number">2.</span>x0 = q.x0 + q.n / <span class="number">2</span>, q<span class="number">2.</span>y0 = q.y0, q<span class="number">2.</span>n = q.n / <span class="number">2</span>, q<span class="number">2.</span>m = q.m;</span><br><span class="line">            q<span class="number">2.</span>startx = (<span class="number">2</span> * q<span class="number">2.</span>x0 + q<span class="number">2.</span>n) / <span class="number">2</span>, q<span class="number">2.</span>starty = (<span class="number">2</span> * q<span class="number">2.</span>y0 + q<span class="number">2.</span>m) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            q<span class="number">1.</span>x0 = q.x0, q<span class="number">1.</span>y0 = q.y0, q<span class="number">1.</span>n = q.n, q<span class="number">1.</span>m = q.m / <span class="number">2</span>;</span><br><span class="line">            q<span class="number">1.</span>startx = (<span class="number">2</span> * q<span class="number">1.</span>x0 + q<span class="number">1.</span>n) / <span class="number">2</span>, q<span class="number">1.</span>starty = (<span class="number">2</span> * q<span class="number">1.</span>y0 + q<span class="number">1.</span>m) / <span class="number">2</span>;</span><br><span class="line">            q<span class="number">2.</span>x0 = q.x0, q<span class="number">2.</span>y0 = q.y0 + q.m / <span class="number">2</span>, q<span class="number">2.</span>n = q.n, q<span class="number">2.</span>m = q.m / <span class="number">2</span>;</span><br><span class="line">            q<span class="number">2.</span>startx = (<span class="number">2</span> * q<span class="number">2.</span>x0 + q<span class="number">2.</span>n) / <span class="number">2</span>, q<span class="number">2.</span>starty = (<span class="number">2</span> * q<span class="number">2.</span>y0 + q<span class="number">2.</span>m) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((q.m % <span class="number">2</span> == <span class="number">1</span>) &amp;&amp; (q.n % <span class="number">2</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.n &gt;= q.m) &#123;</span><br><span class="line">            <span class="type">int</span> n_;</span><br><span class="line">            <span class="keyword">if</span> ((q.n / <span class="number">2</span>) % <span class="number">2</span>) &#123;</span><br><span class="line">                n_ = q.n / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> n_ = q.n / <span class="number">2</span>;</span><br><span class="line">            q<span class="number">1.</span>x0 = q.x0, q<span class="number">1.</span>y0 = q.y0, q<span class="number">1.</span>n = n_, q<span class="number">1.</span>m = q.m;</span><br><span class="line">            q<span class="number">1.</span>startx = (<span class="number">2</span> * q<span class="number">1.</span>x0 + q<span class="number">1.</span>n) / <span class="number">2</span>, q<span class="number">1.</span>starty = (<span class="number">2</span> * q<span class="number">1.</span>y0 + q<span class="number">1.</span>m) / <span class="number">2</span>;</span><br><span class="line">            q<span class="number">2.</span>x0 = q.x0 + n_, q<span class="number">2.</span>y0 = q.y0, q<span class="number">2.</span>n = q.n - n_, q<span class="number">2.</span>m = q.m;</span><br><span class="line">            q<span class="number">2.</span>startx = (<span class="number">2</span> * q<span class="number">2.</span>x0 + q<span class="number">2.</span>n) / <span class="number">2</span>, q<span class="number">2.</span>starty = (<span class="number">2</span> * q<span class="number">2.</span>y0 + q<span class="number">2.</span>m) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> m_;</span><br><span class="line">            <span class="keyword">if</span> ((q.m / <span class="number">2</span>) % <span class="number">2</span>) &#123;</span><br><span class="line">                m_ = q.m / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> m_ = q.m / <span class="number">2</span>;</span><br><span class="line">            q<span class="number">1.</span>x0 = q.x0, q<span class="number">1.</span>y0 = q.y0, q<span class="number">1.</span>n = q.n, q<span class="number">1.</span>m = m_;</span><br><span class="line">            q<span class="number">1.</span>startx = (<span class="number">2</span> * q<span class="number">1.</span>x0 + q<span class="number">1.</span>n) / <span class="number">2</span>, q<span class="number">1.</span>starty = (<span class="number">2</span> * q<span class="number">1.</span>y0 + q<span class="number">1.</span>m) / <span class="number">2</span>;</span><br><span class="line">            q<span class="number">2.</span>x0 = q.x0, q<span class="number">2.</span>y0 = q.y0 + m_, q<span class="number">2.</span>n = q.n, q<span class="number">2.</span>m = q.m - m_;</span><br><span class="line">            q<span class="number">2.</span>startx = (<span class="number">2</span> * q<span class="number">2.</span>x0 + q<span class="number">2.</span>n) / <span class="number">2</span>, q<span class="number">2.</span>starty = (<span class="number">2</span> * q<span class="number">2.</span>y0 + q<span class="number">2.</span>m) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((q.m % <span class="number">2</span> == <span class="number">0</span>) &amp;&amp; (q.n % <span class="number">2</span> == <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.n &gt;= q.m) &#123;</span><br><span class="line">            <span class="type">int</span> n_;</span><br><span class="line">            <span class="keyword">if</span> ((q.n / <span class="number">2</span>) % <span class="number">2</span>) &#123;</span><br><span class="line">                n_ = q.n / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> n_ = q.n / <span class="number">2</span>;</span><br><span class="line">            q<span class="number">1.</span>x0 = q.x0, q<span class="number">1.</span>y0 = q.y0, q<span class="number">1.</span>n = n_, q<span class="number">1.</span>m = q.m;</span><br><span class="line">            q<span class="number">1.</span>startx = (<span class="number">2</span> * q<span class="number">1.</span>x0 + q<span class="number">1.</span>n) / <span class="number">2</span>, q<span class="number">1.</span>starty = (<span class="number">2</span> * q<span class="number">1.</span>y0 + q<span class="number">1.</span>m) / <span class="number">2</span>;</span><br><span class="line">            q<span class="number">2.</span>x0 = q.x0 + n_, q<span class="number">2.</span>y0 = q.y0, q<span class="number">2.</span>n = q.n - n_, q<span class="number">2.</span>m = q.m;</span><br><span class="line">            q<span class="number">2.</span>startx = (<span class="number">2</span> * q<span class="number">2.</span>x0 + q<span class="number">2.</span>n) / <span class="number">2</span>, q<span class="number">2.</span>starty = (<span class="number">2</span> * q<span class="number">2.</span>y0 + q<span class="number">2.</span>m) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> m_;</span><br><span class="line">            <span class="keyword">if</span> ((q.m / <span class="number">2</span>) % <span class="number">2</span>) &#123;</span><br><span class="line">                m_ = q.m / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> m_ = q.m / <span class="number">2</span>;</span><br><span class="line">            q<span class="number">1.</span>x0 = q.x0, q<span class="number">1.</span>y0 = q.y0, q<span class="number">1.</span>n = q.n, q<span class="number">1.</span>m = m_;</span><br><span class="line">            q<span class="number">1.</span>startx = (<span class="number">2</span> * q<span class="number">1.</span>x0 + q<span class="number">1.</span>n) / <span class="number">2</span>, q<span class="number">1.</span>starty = (<span class="number">2</span> * q<span class="number">1.</span>y0 + q<span class="number">1.</span>m) / <span class="number">2</span>;</span><br><span class="line">            q<span class="number">2.</span>x0 = q.x0, q<span class="number">2.</span>y0 = q.y0 + m_, q<span class="number">2.</span>n = q.n, q<span class="number">2.</span>m = q.m - m_;</span><br><span class="line">            q<span class="number">2.</span>startx = (<span class="number">2</span> * q<span class="number">2.</span>x0 + q<span class="number">2.</span>n) / <span class="number">2</span>, q<span class="number">2.</span>starty = (<span class="number">2</span> * q<span class="number">2.</span>y0 + q<span class="number">2.</span>m) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Runtime Error. InValid divide! (%d %d)\n&quot;</span>, q.n, q.m);</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">div_conquer</span>(q1), <span class="built_in">div_conquer</span>(q2);</span><br><span class="line">    <span class="built_in">merge</span>(q1, q2);</span><br><span class="line">    <span class="built_in">travel</span>(q.x0, q.y0, q1, q2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;horse.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="built_in">memset</span>(book, <span class="number">0</span>, <span class="built_in">sizeof</span>(book));</span><br><span class="line">    <span class="built_in">memset</span>(note, <span class="number">0</span>, <span class="built_in">sizeof</span>(note));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    subq q = &#123;<span class="number">0</span>, <span class="number">0</span>, n, m, (q.x0 + q.x0 + q.n) / <span class="number">2</span> - <span class="number">1</span>, (q.y0 + q.y0 + q.m) / <span class="number">2</span> - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">clock_t</span> clk0 = <span class="built_in">clock</span>(); <span class="comment">// 测量运行时间</span></span><br><span class="line">    <span class="built_in">div_conquer</span>(q);</span><br><span class="line">    <span class="type">clock_t</span> clk1 = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">Print_Ans</span>(q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Solved in %.3f second(s)\n&quot;</span>,(<span class="type">double</span>) (clk1 - clk0) / CLOCKS_PER_SEC);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[^1]: Parberry I . An Efficient Algorithm for the Knight’s Tour Problem[J]. Discrete Applied Mathematics, 1997, 73(3):251-260.<a href="https://www.fq.math.ca/Scanned/16-3/cull.pdf">Link</a> </p>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 分治法 </tag>
            
            <tag> 回溯法 </tag>
            
            <tag> 启发式算法 </tag>
            
            <tag> 高性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求解多机调度问题</title>
      <link href="/2022/04/10/%E7%AE%97%E6%B3%95/%E6%B1%82%E8%A7%A3%E5%A4%9A%E6%9C%BA%E8%B0%83%E5%BA%A6/"/>
      <url>/2022/04/10/%E7%AE%97%E6%B3%95/%E6%B1%82%E8%A7%A3%E5%A4%9A%E6%9C%BA%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定$n$台相同的机器：$P_j, 1≤j≤n$,及$m$个作业：$J_i, 1≤i≤m, J_i$需时间$t_i$, 每台机器一次只能执行一个作业，如何分配任务才能尽快完成所有作业？</p><p>换一种说法，将一个作业集划分为不相交的子集${S_1, S_2,…, S_m}$，使得下面的式子成立：<br>$$<br>\underset{{S_1,S_2,\dots,S_m}}\min {\underset{1\leq j\leq m}\max\underset{k\in S_j}\sum t_k}<br>$$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>多机调度问题是典型的NP完全问题。如果$m$的值比较小，可以使用动态规划。但是$m$值太大，需要的空间就会成指数式的增长。例如下面的双机调度问题，就可以使用（伪）多项式复杂度求解。</p><h3 id="双机调度"><a href="#双机调度" class="headerlink" title="双机调度"></a>双机调度</h3><p>即本题中$m&#x3D;2$的情形。设$F[i][j][k]$为前$i$个任务已经调度完成，0号机的负载为$j$，1号机的负载为$k$时的最优调度时间，我们很容易得到：<br>$$<br>F[i][j][k]&#x3D;\min{F[i-1][j-t_i][k],F[i-1][j][k-t_i]}+t_i<br>$$<br>最终答案为$\underset{j,k}{\min}F[n][j][k]$。这个递推式是很差的，因为我们想要优化的指标就存在于我们递推时枚举的$j,k$中（$F[i-1][j-t_i][k]$不就等于$\max{j-t_i,k}$吗），递推式中出现了冗余。</p><p>于是我们将递推式的其中一维作为优化目标，定义新的状态$F[i][j]$表示前$i$个任务已经调度完成，0号机的负载为$j$时，1号机的负载。写出递推式：<br>$$<br>F[i][j]&#x3D;\min{F[i-1][j]+t_i,F[i-1][j-t_i]}<br>$$<br>寻找最终答案需要遍历$F[n][j]$，找到$\min{\max{j,F[n][j]}}$。复杂度$O(nT)$，其中$T&#x3D;\sum t_k$</p><h3 id="多机调度"><a href="#多机调度" class="headerlink" title="多机调度"></a>多机调度</h3><p>上面的优化只能优化一维。如果$m&#x3D;100$，那么要开一个100维的数组，计算$O(nT^m)$次。。。任何计算机都无法算出如此规模的问题。这样的问题，我们只能使用回溯法，减少信息的存储，用时间来换空间。</p><p>下面给出回溯法的程序实现，回溯法暴力枚举任务所在的机器编号和任务的排列顺序，将可能情况全部遍历，从而找到最优解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">task</span>&#123;</span><br><span class="line">    <span class="type">int</span> No, time;</span><br><span class="line">&#125;t[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> book[MAXN];</span><br><span class="line"><span class="type">int</span> tot[MAXN];</span><br><span class="line"><span class="type">int</span> ans = INF;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_max</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> anst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x; ++i) &#123;</span><br><span class="line">        anst = std::<span class="built_in">max</span>(anst, tot[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> anst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v[MAXN], ansv[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">find_max</span>(m);</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; t) &#123;</span><br><span class="line">            ans = t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">                ansv[i] = v[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find_max</span>(m) &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!book[j] &amp;&amp; tot[i] + t[j].time &lt; ans) &#123;</span><br><span class="line">                book[j] = <span class="number">1</span>;</span><br><span class="line">                tot[i] += t[j].time;</span><br><span class="line">                v[i].<span class="built_in">push_back</span>(t[j].No);</span><br><span class="line">                <span class="built_in">dfs</span>(n - <span class="number">1</span>, m);</span><br><span class="line">                book[j] = <span class="number">0</span>;</span><br><span class="line">                tot[i] -= t[j].time;</span><br><span class="line">                v[i].<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ans = INF;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        book[i] = tot[i] = <span class="number">0</span>;</span><br><span class="line">        v[i].<span class="built_in">clear</span>();ansv[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t[i].time);</span><br><span class="line">        t[i].No = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(n, m);</span><br><span class="line">    <span class="comment">// printf(&quot;%d\n&quot;, ans);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tot cost = %d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Machine %d:&quot;</span>, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ansv[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, ansv[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们考虑贪心法近似求解。</p><h2 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h2><p>贪心法不能保证一定能找到多机调度问题的全局最优解，但它的效率很高，经过优化后，误差相比全局最优解可以进一步降低。贪心策略比较符合我们的直觉，即让各个机器的任务负载均衡。</p><h3 id="贪心法1：负载均衡"><a href="#贪心法1：负载均衡" class="headerlink" title="贪心法1：负载均衡"></a>贪心法1：负载均衡</h3><ol><li><p>思想：一个任务到来，选择一个当前负载最小的机器接收此任务。我们使用二叉堆维护当前机器的负载，对于每一个任务，当为这个任务选择机器时，直接选择堆顶的机器即可。这样就可以实现对机器选择过程的优化，使得总时间复杂度是$O(n\log n)$的。</p></li><li><p>程序实现：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">machine</span>&#123;</span><br><span class="line">    <span class="type">int</span> no, load;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> <span class="keyword">struct</span> machine &amp;ma) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> load &gt; ma.load;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;mach[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Load_Balance</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    std::priority_queue&lt;machine&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">machine</span> mt;</span><br><span class="line">        mt.no = i, mt.load = <span class="number">0</span>;</span><br><span class="line">        pq.<span class="built_in">push</span>(mt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">machine</span> m = pq.<span class="built_in">top</span>();pq.<span class="built_in">pop</span>();</span><br><span class="line">        m.load += t[i];</span><br><span class="line">        pq.<span class="built_in">push</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ans = std::<span class="built_in">max</span>(ans, pq.<span class="built_in">top</span>().load);</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>正确率分析</p><p>本次算法分析，主要分析贪心值与实际值的误差$bias$。以回溯法求解的正确值为准，计算出相同测试集下每组数据的结果，求出误差值，误差每增大$10$，就统计$[x,x+10)$之间的样本数量。作出条形统计图和折线统计图。</p><p>其中横轴为求出的值与实际值的偏差，纵轴为偏差在$[x,x+10)$之间的测试样本数量。</p><p><img src="/assets/al/load_sim.png" alt="负载均衡"></p></li></ol><h3 id="贪心法2：递降贪心策略"><a href="#贪心法2：递降贪心策略" class="headerlink" title="贪心法2：递降贪心策略"></a>贪心法2：递降贪心策略</h3><ol><li><p>思想：首先按处理时长从大到小对作业重新排序，然后运用贪心策略分配任务。时间复杂度仍是$O(n\log n)$的。</p></li><li><p>代码实现：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Decrease_Method</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(t + <span class="number">1</span>, t + <span class="number">1</span> + n, std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Load_Balance</span>(n, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>正确率分析</p><p>相比于上面的算法，正确率明显提高，平均误差相比负载均衡策略也大幅减小。</p><p><img src="/assets/al/dec_sim.png" alt="递降贪心"></p></li></ol><h3 id="正确率"><a href="#正确率" class="headerlink" title="正确率"></a>正确率</h3><p>固定$m$，对于变化的$n$，贪心法求解误差变化图（我们使用正确率更高的贪心法2）如下，我们使用偏差率$\frac{bias}{ 准确值(prec)}$作为纵轴，$n$作为横轴：</p><ol><li><p>当$m&#x3D;2$时</p><p><img src="/assets/al/d_sim_n2.png" alt="m&#x3D;2"></p></li><li><p>当$m&#x3D;4$时</p><p><img src="/assets/al/d_sim_n4.png" alt="m&#x3D;4"></p></li></ol><p>由于$m$过大，暴力算法不能求解，所以只能给出最多$m&#x3D;4, n&#x3D;12$的情况。</p><p>经过上面的实验，我们发现，$m&#x3D;2$的情况相比于$m&#x3D;4$的情况，在$n$增大时，偏差率接近0的倾向更明显。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 回溯法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数划分问题</title>
      <link href="/2022/02/28/%E7%AE%97%E6%B3%95/%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98/"/>
      <url>/2022/02/28/%E7%AE%97%E6%B3%95/%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><h3 id="两种描述"><a href="#两种描述" class="headerlink" title="两种描述"></a>两种描述</h3><ol><li><p>给定$n\in\mathbb{Z}^+$，整数$n$可以分解为$\stackrel{K}{\underset{k&#x3D;1}\sum}n_k$的形式，求不同的分解有多少种。（例如6&#x3D;3+2+1与6&#x3D;2+3+1与6&#x3D;1+2+3是同一种分解）</p></li><li><p>给定$n\in\mathbb{Z}^+$，整数$n$可以分解为$\stackrel{K}{\underset{k&#x3D;1}\sum}n_k$（其中$n_1\geq n_2\geq \cdots \geq n_K$）的形式，求这样的分解有多少种。</p></li></ol><p>例如6的分解有11种，分别如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">5+1</span><br><span class="line">4+2,4+1+1</span><br><span class="line">3+3,3+2+1,3+1+1+1</span><br><span class="line">2+2+2, 2+2+1+1, 2+1+1+1+1</span><br><span class="line">1+1+1+1+1+1</span><br></pre></td></tr></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>因为加数的排列不影响结果，所以问题一和问题二是等价的，其中问题二确定了分解出的加数的大小关系，这会降低问题的难度。所以围绕问题二求解。</p><p>引入辅助变量$m$，意义是分解结果中最大的加数，引入目的是用来限定分解后加数的排列顺序。定义$f(n,m)$表示将$n$进行分解，满足分解结果的最大加数为$m$的分解的数目。</p><p>显然，分解结果的最大加数不会比$n$大。如果比$n$大，就相当于分解结果的加数最大为$n$，所以，若$m\geq n$，则$f(n,m)&#x3D;f(n,n)$。</p><p>若$m&lt;n$，分两种情况：</p><ol><li><p>分解结果包含$m$，则问题转化为$f(n-m, m)$。</p></li><li><p>分解结果不包含$m$，则问题转化为$f(n,m-1)$。</p></li></ol><p>两种情况，均构成了$n$的分解，所以得到递推式$f(n,n)&#x3D;f(n-m,m)+f(n,m-1)$。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题使用了<strong>数学归纳法</strong>的逆向方法，<strong>引入辅助变量</strong>的方法，和<strong>分类讨论</strong>的基本思想。是一个看似简单，实际上并不简单的一个基础递推问题。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子段和问题</title>
      <link href="/2022/02/28/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/"/>
      <url>/2022/02/28/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="一，无限制的最大子段和"><a href="#一，无限制的最大子段和" class="headerlink" title="一，无限制的最大子段和"></a>一，无限制的最大子段和</h2><p>尝试用线性时间复杂度的方法，求解下面的问题：</p><p>给定一个长度为$n$的序列$a_1, a_2, \dots,a_n$，求$\underset{p,q}\max{\stackrel{q}{\underset{i&#x3D;p}\sum} a_i}(1\leq p\leq q\leq n)$。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>如果子段和是一个负数，那么它对于后面的影响只可能是把子段和变小。所以，当一个子段和为负数时，可以直接将其抛弃。</p><p>要解决这个问题，只需要对序列进行一次遍历。不断把新的数加入子段，如果当前子段和为负数，把当前的子段清空，扫描过程中出现的最大子段即为所求。</p><p>下面给出一道例题。</p><h3 id="例题实战"><a href="#例题实战" class="headerlink" title="例题实战"></a>例题实战</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定$n\times n$的矩阵$A_{n\times n}$，求<br>$$<br>\underset{x_0,y_0,x_1,y_1}\max\stackrel{x_1}{\underset{i&#x3D;x_0}\sum}\stackrel{y_1}{\underset{j&#x3D;y_0}\sum}a_{i,j}<br>$$<br>其中$1\leq x_0\leq x_1\leq n,1\leq y_0\leq y_1\leq n,n\leq 100$。</p><p><a href="http://poj.org/problem?id=1050">提交</a></p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>先求每一行的前缀和，接着枚举所有的$i,j(i\leq j)$列，然后将确定了$i,j$的子矩阵“压缩”成一维，转化为最大子段和问题。</p><p><code>maxSeg</code>对应了开头的最大子段和算法。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100 + 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 99999999</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> sum[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> temp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxSeg</span><span class="params">(<span class="type">int</span> *temp, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxx = temp[<span class="number">1</span>], s = temp[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s &lt; <span class="number">0</span>) s = temp[i];</span><br><span class="line">        <span class="keyword">else</span> s += temp[i];</span><br><span class="line">        maxx = max(maxx, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        sum[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i][j]);</span><br><span class="line">            sum[i][j] += sum[i][j - <span class="number">1</span>] + A[i][j]; <span class="comment">// 求第i行的前缀和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">                temp[k] = sum[k][j] - sum[k][i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, maxSeg(temp, n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二，长度不小于L的最大子段和"><a href="#二，长度不小于L的最大子段和" class="headerlink" title="二，长度不小于L的最大子段和"></a>二，长度不小于L的最大子段和</h2><p>尝试用线性时间复杂度的方法，求解下面的问题：</p><p>给定一个长度为$n$的序列$a_1, a_2, \dots,a_n$，求$\underset{p,q}\max{\stackrel{q}{\underset{i&#x3D;p}\sum} a_i}(q-p\geq L,1\leq p\leq q\leq n)$。</p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>本题可以转化为求前缀和的差的最大值问题，即：<br>$$<br>\underset{p,q}\max{ s_q-s_{p-1}}(q-p\geq L,1\leq p\leq q\leq n)<br>$$<br>我们发现，随着$q$的增长，$p$的取值范围每次只会增大1。所以，我们不必每次都扫描一遍$p$的全部可能取值，只需要将满足条件的最小的$s_{p-1}$记录下来即可。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans = -INF, min_val = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = L + <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    min_val = min(min_val, sum[i - L]);</span><br><span class="line">    ans = max(ans, sum[i] - min_val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三，长度不大于L的最大子段和"><a href="#三，长度不大于L的最大子段和" class="headerlink" title="三，长度不大于L的最大子段和"></a>三，长度不大于L的最大子段和</h2><p>和本题的想法二的想法类似，这个问题与问题二的区别就是我们记录的满足条件的最小值是根据当前$q$的值动态变化的，这就需要单调队列这个特殊的数据结构来优化，详情请见：</p><p><a href="/2022/03/29/Algorithm/Monotonic%20Stack%20and%20Queue/#%E4%BE%8B%E9%A2%98%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C">单调队列优化长度不大于L的最大子段和问题</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 算法优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空间坐标转换方法</title>
      <link href="/2021/12/05/%E7%AE%97%E6%B3%95/%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E6%96%B9%E6%B3%95/"/>
      <url>/2021/12/05/%E7%AE%97%E6%B3%95/%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一，变换操作"><a href="#一，变换操作" class="headerlink" title="一，变换操作"></a>一，变换操作</h2><ol><li><p>平移变换</p><p>变换矩阵</p>   $$   \begin{pmatrix}    x' \\    y' \\    1 \\   \end{pmatrix}   {=}   \begin{pmatrix}    1 & 0 & t_{x} \\    0 & 1 & t_{y} \\    0 & 0 & 1\\   \end{pmatrix}   \begin{pmatrix}    x \\    y \\    1 \\   \end{pmatrix}   $$   <p>变换关系</p><blockquote><p>$t_{x}$, $t_{y}$分别对应x轴，y轴的偏移量</p></blockquote></li><li><p>比例变换</p><p>变换矩阵</p>   $$   \begin{pmatrix}    x' \\    y' \\    1 \\   \end{pmatrix}   {=}   \begin{pmatrix}    s_{x} & 0 & 0\\    0 & s_{y} & 0\\    0 & 0 & 1\\   \end{pmatrix}   \begin{pmatrix}    x \\    y \\    1 \\   \end{pmatrix}   $$   <p>变换关系</p><blockquote><p>（1）当$S_{x} &#x3D; S_{y} &#x3D; 1$ 时，为恒等比例变换，就是图形不变</p><p>（2）当$S_{x} &#x3D; S_{y} &gt; 1$ 时，图形沿两个坐标轴方向等比例放大。</p><p>（3）当$S_{x} &#x3D; S_{y} &lt;1$ 时，图形沿两个坐标轴方向等比例缩小。</p><p>（4）当$S_{x} \neq S_{y}$  时，图形沿两个坐标轴方向做非均匀的比例变换。</p></blockquote></li><li><p>对称变换</p><p>变换矩阵</p>   $$   \begin{pmatrix}    x' \\    y' \\    1 \\   \end{pmatrix}   {=}   \begin{pmatrix}    a & b & 0\\    d & e & 0\\    0 & 0 & 1\\   \end{pmatrix}   \begin{pmatrix}    x \\    y \\    1 \\   \end{pmatrix}   $$   <p>变换关系：</p><blockquote><p>（1）当$b&#x3D;d&#x3D;0,a&#x3D;-1,e&#x3D;1$时，产生与y轴对称的反射图形</p><p>（2）当$b&#x3D;d&#x3D;0,a&#x3D;1,e&#x3D;-1$时，产生与x轴对称的反射图形</p><p>（3）当$b&#x3D;d&#x3D;0,a&#x3D;e&#x3D;-1$时，产生与原点对称的反射图形</p><p>（4）当$b&#x3D;d&#x3D;1,a&#x3D;e&#x3D;0$时，产生与直线y&#x3D;x对称的反射图形</p><p>（5）当$b&#x3D;d&#x3D;-1,a&#x3D;e&#x3D;0$时，产生与直线y&#x3D;-x对称的反射图形</p></blockquote></li><li><p>旋转变换</p><p>变换矩阵</p>   $$   \begin{pmatrix}    x' \\    y' \\    1 \\   \end{pmatrix}   {=}   \begin{pmatrix}    \text{cos}(\theta) & -\text{sin}(\theta) & 0\\    \text{sin}(\theta) & \text{cos}(\theta) & 0\\    0 & 0 & 1\\   \end{pmatrix}   \begin{pmatrix}    x \\    y \\    1 \\   \end{pmatrix}   $$   <p>变换关系</p>   $$\begin{cases}      x´=x \text{cos}\theta-y \text{sin}\theta \\      y´=x \text{sin}\theta+y \text{cos}\theta \\   \end{cases}   $$   </li><li><p>错切变换</p><p>变换矩阵</p>   $$   \begin{pmatrix}    x' \\    y' \\    1 \\   \end{pmatrix}   {=}   \begin{pmatrix}    1 & b & 0\\    d & 1 & 0\\    0 & 0 & 1\\   \end{pmatrix}   \begin{pmatrix}    x \\    y \\    1 \\   \end{pmatrix}   $$   <p>变换关系</p>   $$   \begin{cases}      x´=x + by \\      y´=dx + y \\   \end{cases}   $$   </li><li><p>复合变换</p><p>原理：复合变换是指图形做一次以上的几何变换，变换结果是每次变换矩阵相乘。</p><p>举例：如何做到将图形绕平面上的一点(x0,y0)旋转变换θ角度？</p><p>方法：将图形先平移到原点，然后进行缩放或者旋转的变化，最后再移回</p>   $$   \begin{pmatrix}    x' \\    y' \\    1 \\   \end{pmatrix}   {=}   \begin{pmatrix}    1 & 0 & x_{0}\\    0 & 1 & y_{0}\\    0 & 0 & 1\\   \end{pmatrix}   \begin{pmatrix}    \text{cos}(\theta) & -\text{sin}(\theta) & 0\\    \text{sin}(\theta) & \text{cos}(\theta) & 0\\    0 & 0 & 1\\   \end{pmatrix}   \begin{pmatrix}    1 & 0 & -x_{0}\\    0 & 1 & -y_{0}\\    0 & 0 & 1\\   \end{pmatrix}   \begin{pmatrix}    x \\    y \\    1 \\   \end{pmatrix}   $$   </li></ol><h2 id="二，数学坐标变换直接应用"><a href="#二，数学坐标变换直接应用" class="headerlink" title="二，数学坐标变换直接应用"></a>二，数学坐标变换直接应用</h2><p><strong><font size = 5>POJ 3889</font></strong><font size = 5 face = "Times new Roman"> Fractal Streets</font></p><p><a href="http://poj.org/problem?id=3889">POJ题目链接</a></p><p><img src="http://poj.org/images/3889_1.png" alt="3889"></p><p>这张图是典型的分形图。容易根据给定的房屋编号确定房屋在四个片区中的哪一个，所以，我们只需要从原始的，1号房屋对应的最小片区开始，按照扩展规律扩展即可。</p><p>有什么规律呢？以行号增大的方向为x轴正方向，列号增大的方向为y轴正方向，左上角片区相当于上一级城市以$y &#x3D; x$为对称轴做翻转。左下角片区相当于上一级城市以$y &#x3D; -x + sz - 1, (\text{其中}sz\text{表示上一级城市大小，即}2^{i - 1})$为对称轴做翻转。右上角片区相当于上一级城市平移$sz$，右下角片区相当于上一级城市在$x,y$方向分别平移$sz$。用变换矩阵很容易求出坐标的对应关系。以左下角为例。<br>      $$   \begin{pmatrix}    x' \\    y' \\    1 \\   \end{pmatrix}   {=}   \begin{pmatrix}    1 & 0 & 2^{i-1}\times 2 - 1\\    0 & 1 & 2^{i-1} - 1\\    0 & 0 & 1\\   \end{pmatrix}   \begin{pmatrix}    0 & -1 & 0\\    -1 & 0 & 0\\    0 & 0 & 1\\   \end{pmatrix}   \begin{pmatrix}    x \\    y \\    1 \\   \end{pmatrix}   $$   $$   \begin{pmatrix}    x' \\    y' \\    1 \\   \end{pmatrix}   {=}   \begin{pmatrix}    0 & -1 & 2^{i} - 1\\    -1 & 0 & 2^{i-1} - 1\\    0 & 0 & 1\\   \end{pmatrix}   \begin{pmatrix}    x \\    y \\    1 \\   \end{pmatrix}   $$   </p><p>   注意这道题的坐标是离散的而非连续的，得到变换关系<br>      $$   \begin{cases}   x' = 2^{i} - y - 1 \\    y' = 2^{i - 1} - x - 1    \end{cases}   $$   </p><h2 id="三，应用"><a href="#三，应用" class="headerlink" title="三，应用"></a>三，应用</h2><p>地理信息系统(GIS)，计算机图形学等。</p>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++语言实现速查</title>
      <link href="/2021/12/05/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++%E8%AF%AD%E8%A8%80%E9%80%9F%E6%9F%A5/"/>
      <url>/2021/12/05/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++%E8%AF%AD%E8%A8%80%E9%80%9F%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="1-C-引用"><a href="#1-C-引用" class="headerlink" title="1. C++ 引用"></a>1. C++ 引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;x = a;</span><br></pre></td></tr></table></figure><p>变量 x 被称为引用类型，其地址始终与被引用变量 a 保持相同。</p><h2 id="2-C-pair类型重载"><a href="#2-C-pair类型重载" class="headerlink" title="2. C++ pair类型重载"></a>2. C++ pair类型重载</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> pair&lt;T1, T2&gt; &amp;lhs, <span class="type">const</span> pair&lt;T1, T2&gt; &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.first &lt; rhs.first || (!(rhs.first &lt; lhs.first) &amp;&amp; lhs.second &lt; rhs.second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意义：如果lhs的第一个变量小于rhs的第一个变量，返回<strong>true</strong>，否则，如果rhs的第一个变量不小于lhs的第一个变量（即<code>lhs.first &lt;= rhs.first</code>，由于前面已经处理过<code>lhs.first &lt; rhs.first</code>的情况，所以相当于<code>lhs.first == rhs.first</code>），且lhs的第二个变量小于rhs的第二个变量，返回<strong>true</strong>。逻辑和下面的代码相同：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> pair&lt;T1, T2&gt; &amp;lhs, <span class="type">const</span> pair&lt;T1, T2&gt; &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lhs.first == rhs.first) <span class="keyword">return</span> lhs.second &lt; rhs.second;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> lhs.first &lt; rhs.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 实用功能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用网页小脚本</title>
      <link href="/2021/11/15/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/microWebScripts/"/>
      <url>/2021/11/15/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/microWebScripts/</url>
      
        <content type="html"><![CDATA[<h2 id="解决CSDN的复制粘贴限制"><a href="#解决CSDN的复制粘贴限制" class="headerlink" title="解决CSDN的复制粘贴限制"></a>解决CSDN的复制粘贴限制</h2><p>CSDN站曾经是一个非常好的计算机技术交流平台。但现在却开始商业化，为了用户数量不择手段，现在居然连复制代码都要限制（我现在已经不喜欢它了）。</p><p>为了复制一小段代码就注册个账号是很麻烦的，而且CSDN对用户数据安全也没那么上心。所以我总结了以下几个好用的方法。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>第一步：键入F12，打开浏览器开发者工具。选择要复制的代码块。在开发者工具显示的的源码中，会自动定位到如下位置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">code</span> <span class="attr">class</span>=<span class="string">&quot;prism language-cpp&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步：在开发者工具的控制台(console)中，输入如下JavaScript命令，替换getElementByClassName()方法中的字符串为上面html中code class字符串的内容，想要复制的代码会显示在控制台的输出中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;prism language-cpp&quot;</span>)].<span class="title function_">forEach</span>(<span class="function"><span class="params">i</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(i.<span class="property">innerText</span>))</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>在控制台输入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> code = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;code&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; code.<span class="property">length</span>; ++i)  &#123;</span><br><span class="line">        code[i].<span class="property">style</span>.<span class="property">userSelect</span>=<span class="string">&#x27;text&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这样就能编辑代码块中的内容了，也就能复制代码了。可以建一个收藏夹，每次点击收藏夹时就会运行这段代码。</p><h2 id="解除CSDN关注后查看文章的限制"><a href="#解除CSDN关注后查看文章的限制" class="headerlink" title="解除CSDN关注后查看文章的限制"></a>解除CSDN关注后查看文章的限制</h2><p>这种操作会导致粉丝不正常增长，非常的不好。我很不喜欢这种行为。</p><p>第一行代码为删除 <code>DIV</code> 高度，并取消 <code>overflow</code> 属性，第二行代码为去除关注博主按钮区域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Your code here...</span></span><br><span class="line">  <span class="comment">// 使用 Jquery 选择器，也可以直接使用原生的 JS</span></span><br><span class="line">  $(<span class="string">&quot;#article_content&quot;</span>).<span class="title function_">removeAttr</span>(<span class="string">&quot;style&quot;</span>);</span><br><span class="line">  $(<span class="string">&quot;.hide-article-box&quot;</span>).<span class="title function_">remove</span>();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>来源：<a href="https://blog.csdn.net/qq_45662588/article/details/118764577">https://blog.csdn.net/qq_45662588/article/details/118764577</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网页内容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educoder 实训平台评测程序代码的获取</title>
      <link href="/2021/11/11/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Educoder%20%E8%AF%84%E6%B5%8B%E7%A8%8B%E5%BA%8F/"/>
      <url>/2021/11/11/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Educoder%20%E8%AF%84%E6%B5%8B%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="实训地址"><a href="#实训地址" class="headerlink" title="实训地址"></a>实训地址</h1><p><a href="https://www.educoder.net/paths/2104">操作系统 (educoder.net)</a></p><h1 id="分析历程"><a href="#分析历程" class="headerlink" title="分析历程"></a>分析历程</h1><h2 id="一，实训机上偶然的发现"><a href="#一，实训机上偶然的发现" class="headerlink" title="一，实训机上偶然的发现"></a>一，实训机上偶然的发现</h2><p>在修改输入答案文件夹中的答案时，我误删了<code>/data/workspace/edu/step1/test1</code>文件。再点击评测时，发现评测界面输出一行红字<font color = red face = "宋体">“评测文件被修改”</font>。说明实训项目可能是依赖test1文件进行评测的。</p><p>尝试运行test1，发现权限不够。做实训时，用户是以<code>root</code>身份登录的。所以输入<code>ls -la</code>命令查看test的权限。果然没分给我。于是使用<code>chmod -R 777 test1</code>命令更改文件夹权限，接着输入<code>./test1</code>运行之。运行结果如下：</p><p><img src="/assets/shixun/shixunRE0.png" alt="运行结果"></p><p>果然，和平常做实训时的评测结果一样。由python的报错可知，实训使用python脚本进行评测。那么，test1文件应该是python封装的可执行文件。</p><h2 id="二，本机进行分析"><a href="#二，本机进行分析" class="headerlink" title="二，本机进行分析"></a>二，本机进行分析</h2><p>用某种方法，将test1文件导出到本机上。使用python的archive_viewer.py脚本，对test1文件进行分析。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python &lt;archive_viewer.py的路径&gt; &lt;待分析评测文件&gt;</span><br></pre></td></tr></table></figure><p>下图是部分结果。</p><p>archiev_viewer.py的位置（site-packages&#x2F;PyInstaller&#x2F;utils&#x2F;cliutils&#x2F;archive_viewer.py）</p><p><img src="/assets/shixun/shixunRE1.png" alt="archive_viewer.py运行结果"></p><p>观察发现图中(12469, 1669, 4892, 1 ,’s’, ‘test1’)这一组就是test1的python代码。</p><p>输入<code>x test1</code>命令将其提取出来。</p><p>使用wxmedit软件，发现其内容如下。</p><p><img src="/assets/shixun/shixunRE2.png" alt="test1的内容"></p><p>E3开头，说明是比较标准的python代码二进制文件。但是，如果我们直接用python的逆向器，是无法对这个文件进行反编译的。所以，要对这个文件进行一些补充。主要补充python解释器的版本号信息和代码的时间戳。在开头补充16B代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42</span> <span class="number">0</span>D <span class="number">0</span>D <span class="number">0</span>A <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">70</span> <span class="number">79</span> <span class="number">69</span> <span class="number">30</span> <span class="number">10</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure><p>即可。</p><p>补充后的代码如下：</p><p><img src="/assets/shixun/shixunRE3.png" alt="test1补充后的内容"></p><p>然后，将test1增加.pyc扩展名。重命名为test1.pyc。使用python的uncompyle库进行反编译。</p><p>如果没有安装ucompyle工具，那么需要在python cmd中输入如下命令下载：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install uncompyle</span><br></pre></td></tr></table></figure><p>然后使用uncompyle反编译，将输出文件保存到test1.py</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uncompyle6 test1.pyc &gt; test1.py</span><br></pre></td></tr></table></figure><p>使用打开test1.py文件，惊喜发生了，我们获得了评测程序的代码。该实训评测代码如下：</p><p>从代码中，可以知道评测机制，和所有问题的答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># uncompyle6 version 3.8.0</span></span><br><span class="line"><span class="comment"># Python bytecode 3.7.0 (3394)</span></span><br><span class="line"><span class="comment"># Decompiled from: Python 3.8.12 (default, Oct 12 2021, 03:01:40) [MSC v.1916 64 bit (AMD64)]</span></span><br><span class="line"><span class="comment"># Embedded file name: test1.py</span></span><br><span class="line"><span class="comment"># Compiled at: 1995-09-28 00:18:56</span></span><br><span class="line"><span class="comment"># Size of source mod 2**32: 272 bytes</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">&#x27;/root/gdb.log&#x27;</span>):</span><br><span class="line">    file = <span class="built_in">open</span>(<span class="string">&#x27;/root/gdb.log&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>).read()</span><br><span class="line">    file = file.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;\t&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;i_zone=&#123;112,0,0,0,0,0,0,0,0&#125;,i_wait=0x0&lt;startup_32&gt;,i_atime=0,i_ctime=0,i_dev=768,i_num=1&#x27;</span> <span class="keyword">in</span> file:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;函数find_entry第1次开始运行时，参数dir所对应的i节点正确&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;函数find_entry第1次开始运行时，参数dir所对应的i节点错误&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;bread(dev=768,block=112)atbuffer.c:271271&#123;1:current-&gt;pid=1&#x27;</span> <span class="keyword">in</span> file:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;函数bread第1次开始运行时，参数block的值正确&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;函数bread第1次开始运行时，参数block的值错误&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;inode=1,name=&quot;.&quot;,&#x27;</span> <span class="keyword">in</span> file:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;函数match第1次开始运行时，参数de指向的目录项的i节点号和名字正确&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;函数match第1次开始运行时，参数de指向的目录项的i节点号和名字错误&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;inode=48,name=&quot;usr&#x27;</span> <span class="keyword">in</span> file:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;函数match第8次开始运行时，参数de指向的目录项的i节点号和名字正确&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;函数match第8次开始运行时，参数de指向的目录项的i节点号和名字错误&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;iget(dev=768,nr=48)atinode.c:245245&#123;1:current-&gt;pid=1&#x27;</span> <span class="keyword">in</span> file:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;函数iget第1次开始运行时，参数nr的值正确&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;函数iget第1次开始运行时，参数nr的值错误&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;bread(dev=768,block=6)atbuffer.c:271271&#123;1:current-&gt;pid=1&#x27;</span> <span class="keyword">in</span> file:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;函数bread第2次开始运行时，参数block的值正确&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;函数bread第2次开始运行时，参数block的值错误&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;i_zone=&#123;987,0,0,0,0,0,0,0,0&#125;,i_wait=0x0&lt;startup_32&gt;,i_atime=0,i_ctime=0,i_dev=768,i_num=48,i_count=1,i_lock=0&#x27;</span> <span class="keyword">in</span> file:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;函数find_entry第2次开始运行时，参数dir所对应的i节点正确&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;函数find_entry第2次开始运行时，参数dir所对应的i节点错误&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;i_zone=&#123;4721,0,0,0,0,0,0,0,0&#125;,i_wait=0x0&lt;startup_32&gt;,i_atime=0,i_ctime=0,i_dev=768,i_num=131,i_count=1,i_lock=0&#x27;</span> <span class="keyword">in</span> file:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;函数find_entry第3次开始运行时，参数dir所对应的i节点正确&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;函数find_entry第3次开始运行时，参数dir所对应的i节点错误&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;inode=134,name=&quot;hello.c&#x27;</span> <span class="keyword">in</span> file:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;函数match匹配到/usr/root/hello.c的目录项时，参数de指向的目录项的i节点正确&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;函数match匹配到/usr/root/hello.c的目录项时，参数de指向的目录项的i节点错误&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;open_namei(pathname=0x18407&quot;/usr/root/hello.c&quot;,flag=0,mode=32768,res_inode=0xffffb4&#x27;</span> <span class="keyword">in</span> file:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;i_ctime=0,i_dev=768,i_num=134,i_count=1,i_lock=0&#x27;</span> <span class="keyword">in</span> file:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;函数open_namei结束时，变量res_inode指向的i节点正确&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;函数open_namei结束时，变量res_inode指向的i节点错误&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;未检测到gdb.log&#x27;</span>)</span><br><span class="line">    file = <span class="built_in">open</span>(<span class="string">&#x27;第一关.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    f = file.read().replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    file.close()</span><br><span class="line">    a = <span class="string">&#x27;1.&#x27;</span></span><br><span class="line">    b = <span class="string">&#x27;2.&#x27;</span></span><br><span class="line">    c = <span class="string">&#x27;3.&#x27;</span></span><br><span class="line">    d = <span class="string">&#x27;4.&#x27;</span></span><br><span class="line">    e = <span class="string">&#x27;5.&#x27;</span></span><br><span class="line">    g = <span class="string">&#x27;6.&#x27;</span></span><br><span class="line">    h = <span class="string">&#x27;7.&#x27;</span></span><br><span class="line">    i = <span class="string">&#x27;8.&#x27;</span></span><br><span class="line">    j = <span class="string">&#x27;9.&#x27;</span></span><br><span class="line">    one = f[f.index(a):f.index(b)]</span><br><span class="line">    two = f[f.index(b):f.index(c)]</span><br><span class="line">    three = f[f.index(c):f.index(d)]</span><br><span class="line">    four = f[f.index(d):f.index(e)]</span><br><span class="line">    five = f[f.index(e):f.index(g)]</span><br><span class="line">    six = f[f.index(g):f.index(h)]</span><br><span class="line">    seven = f[f.index(h):f.index(i)]</span><br><span class="line">    eight = f[f.index(i):f.index(j)]</span><br><span class="line">    nine = f[f.index(j):]</span><br><span class="line">    one_answer_1 = one.split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;)&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    one_answer_2 = one.split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">2</span>].split(<span class="string">&#x27;)&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> one_answer_1 == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> one_answer_2 == <span class="string">&#x27;112&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;第一题答案正确&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;第一题答案错误&#x27;</span>)</span><br><span class="line">        two_answer_1 = two.split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;)&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> two_answer_1 == <span class="string">&#x27;112&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;第二题答案正确&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;第二题答案错误&#x27;</span>)</span><br><span class="line">three_answer_1 = three.split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;)&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">three_answer_2 = three.split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">2</span>].split(<span class="string">&#x27;)&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> three_answer_1 == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> three_answer_2 == <span class="string">&#x27;&quot;.&quot;&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;第三题答案正确&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;第三题答案错误&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    four_answer_1 = four.split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;)&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    four_answer_2 = four.split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">2</span>].split(<span class="string">&#x27;)&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> four_answer_1 == <span class="string">&#x27;48&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> four_answer_2 == <span class="string">&#x27;&quot;usr&quot;&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;第四题答案正确&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;第四题答案错误&#x27;</span>)</span><br><span class="line">        five_answer_1 = five.split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;)&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> five_answer_1 == <span class="string">&#x27;48&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;第五题答案正确&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;第五题答案错误&#x27;</span>)</span><br><span class="line">six_answer_1 = six.split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;)&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">six_answer_2 = six.split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">2</span>].split(<span class="string">&#x27;)&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> six_answer_1 == <span class="string">&#x27;48&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> six_answer_2 == <span class="string">&#x27;987&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;第六题答案正确&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;第六题答案错误&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    seven_answer_1 = seven.split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;)&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    seven_answer_2 = seven.split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">2</span>].split(<span class="string">&#x27;)&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> seven_answer_1 == <span class="string">&#x27;131&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> seven_answer_2 == <span class="string">&#x27;4721&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;第七题答案正确&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;第七题答案错误&#x27;</span>)</span><br><span class="line">        eight_answer_1 = eight.split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;)&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> eight_answer_1 == <span class="string">&#x27;134&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;第八题答案正确&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;第八题答案错误&#x27;</span>)</span><br><span class="line">nine_answer_1 = nine.split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;)&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">nine_answer_2 = nine.split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">2</span>].split(<span class="string">&#x27;)&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> nine_answer_1 == <span class="string">&#x27;134&#x27;</span> <span class="keyword">and</span> nine_answer_2 == <span class="string">&#x27;4743&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第九题答案正确&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第九题答案错误&#x27;</span>)</span><br><span class="line"><span class="comment"># okay decompiling test1.pyc</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Educoder实训 </tag>
            
            <tag> 逆向分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决GitHub资源访问问题</title>
      <link href="/2021/11/02/Sharp%20Tools/GitHub%20resource/"/>
      <url>/2021/11/02/Sharp%20Tools/GitHub%20resource/</url>
      
        <content type="html"><![CDATA[<h2 id="问题一：访问GitHub速度很慢"><a href="#问题一：访问GitHub速度很慢" class="headerlink" title="问题一：访问GitHub速度很慢"></a>问题一：访问GitHub速度很慢</h2><p>平时，访问GitHub非常不稳定，访问速度忽快忽慢，有时还打不开。从GitHub上下载文件也很让人头痛。</p><h3 id="解决方法一：关闭计算机代理"><a href="#解决方法一：关闭计算机代理" class="headerlink" title="解决方法一：关闭计算机代理"></a>解决方法一：关闭计算机代理</h3><p>Windows10系统默认开启网页代理选项，这样会加快国内网站的访问速度。但是，这个代理会影响国外网站的解析。所以要提升访问GitHub的速度，就要关闭它。</p><p>关闭方法：Win10设置 -&gt; 网络和Internet -&gt; 代理，将自动设置代理选项的自动检测设置开关关闭。</p><h3 id="解决方法二：使用CDN加速"><a href="#解决方法二：使用CDN加速" class="headerlink" title="解决方法二：使用CDN加速"></a>解决方法二：使用CDN加速</h3><p>在网页按如下格式输入网址，可以使用CDN加速，这样访问仓库里的文件就会快一些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/&#123;你的github用户名&#125;/&#123;仓库名称&#125;/&#123;仓库具体路径&#125;</span><br></pre></td></tr></table></figure><p>这是我存在GitHub仓库里的一张图片，可以正常打开</p><p><img src="/assets/Source%20license.jpeg" alt="Source license"></p><p>以下是一个生成CDN加速链接的Python脚本：</p><p>使用时，新建一个名为CDN的目录，与.git放在同一目录，并添加到.gitignore中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">list_dir</span>(<span class="params">dirs</span>):</span><br><span class="line">    L = []</span><br><span class="line">    <span class="keyword">for</span> dirr <span class="keyword">in</span> os.listdir(dirs):</span><br><span class="line">        dirr = os.path.join(dirs, dirr)</span><br><span class="line">        <span class="keyword">if</span> (os.path.isfile(dirr)) :</span><br><span class="line">            L.append(dirr)</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            L += list_dir(dirr)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">list_all_file</span>(<span class="params">dirs</span>):</span><br><span class="line">    L = []</span><br><span class="line">    <span class="keyword">for</span> dirr <span class="keyword">in</span> os.listdir(dirs) :</span><br><span class="line">        dirr = os.path.join(dirs, dirr)</span><br><span class="line">        <span class="keyword">if</span> (os.path.isdir(dirr)) :</span><br><span class="line">            L += list_dir(dirr)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            L.append(dirr)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str_replace</span>(<span class="params">string, L</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(L)) :</span><br><span class="line">        L[i] = L[i].replace(string, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        L[i] = L[i].replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&quot;%20&quot;</span>)</span><br><span class="line">        L[i] = L[i].replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (L[i][<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>):</span><br><span class="line">            L[i] = L[i][<span class="number">1</span> : <span class="built_in">len</span>(L[i]) : <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transURL</span>(<span class="params">info</span>):</span><br><span class="line">    tmp = url[url.find(info[<span class="string">&#x27;repodir&#x27;</span>]) : ]</span><br><span class="line">    tmp = tmp.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    tmp = tmp.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&quot;%20&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> info[<span class="string">&#x27;cdn_url&#x27;</span>] + <span class="string">&#x27;/&#x27;</span> + info[<span class="string">&#x27;GitHubusr&#x27;</span>] + <span class="string">&#x27;/&#x27;</span> + info[<span class="string">&#x27;Repo&#x27;</span>] + <span class="string">&#x27;/&#x27;</span> + tmp</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">writefilelist</span>(<span class="params">info, imagefile</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;pic.log&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> image_name <span class="keyword">in</span> imagefile:</span><br><span class="line">            f.write(info[<span class="string">&#x27;cdn_url&#x27;</span>] + <span class="string">&#x27;/&#x27;</span> + info[<span class="string">&#x27;GitHubusr&#x27;</span>] + <span class="string">&#x27;/&#x27;</span> + info[<span class="string">&#x27;Repo&#x27;</span>] + <span class="string">&#x27;/&#x27;</span> + info[<span class="string">&#x27;repodir&#x27;</span>] + <span class="string">&#x27;/&#x27;</span> + image_name + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">writefilelistasHtml</span>(<span class="params">info, imagefile</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;pic.html&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> image_name <span class="keyword">in</span> imagefile:</span><br><span class="line">            f.write(<span class="string">&#x27;&lt;img src = \&quot;&#x27;</span> + \</span><br><span class="line">                info[<span class="string">&#x27;cdn_url&#x27;</span>] + <span class="string">&#x27;/&#x27;</span> + info[<span class="string">&#x27;GitHubusr&#x27;</span>] + <span class="string">&#x27;/&#x27;</span> + info[<span class="string">&#x27;Repo&#x27;</span>] + \</span><br><span class="line">                     <span class="string">&#x27;/&#x27;</span> + info[<span class="string">&#x27;repodir&#x27;</span>] + <span class="string">&#x27;/&#x27;</span> + image_name + <span class="string">&#x27;\&quot;&#x27;</span> + <span class="string">&#x27;width = 120 height = 120&#x27;</span> +<span class="string">&#x27;/&gt;&#x27;</span> + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_info</span>():</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;settings.json&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> s:</span><br><span class="line">        dict_json = json.loads(s.read())</span><br><span class="line">        s.close()</span><br><span class="line">        <span class="keyword">return</span> dict_json</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">helps</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----------------------------------------&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome to GitHub image CDN transformer:\nChoose:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;    1. transform GitHub url to CDN url then CONTINUE\n    2. tranform GitHub url in a dir then EXIT\n    3. tranform GitHub url in html\nOther. exit&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----------------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span> :</span><br><span class="line">    helps()</span><br><span class="line">    info = read_info()</span><br><span class="line">    pic_ = os.path.join(os.path.abspath(os.path.dirname(os.getcwd())), info[<span class="string">&#x27;imagefile&#x27;</span>])</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">True</span>) :</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            a = <span class="built_in">input</span>(<span class="string">&#x27;Please input command : &#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> a == <span class="string">&#x27;1&#x27;</span> :</span><br><span class="line">                url = <span class="built_in">input</span>(<span class="string">&#x27;input url : &#x27;</span>)</span><br><span class="line">                <span class="built_in">print</span>(transURL(info))</span><br><span class="line">            <span class="keyword">elif</span> a == <span class="string">&#x27;2&#x27;</span> :</span><br><span class="line">                writefilelist(info, str_replace(pic_, list_all_file(pic_)))</span><br><span class="line">            <span class="keyword">elif</span> a == <span class="string">&#x27;3&#x27;</span> :</span><br><span class="line">                writefilelistasHtml(info, str_replace(pic_, list_all_file(pic_)))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Finished!&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Finished!&#x27;</span>)</span><br><span class="line">            helps()</span><br><span class="line">        <span class="keyword">except</span> EOFError :</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Bye~&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="解决方法三：使用镜像站"><a href="#解决方法三：使用镜像站" class="headerlink" title="解决方法三：使用镜像站"></a>解决方法三：使用镜像站</h3><p>在此推荐一个镜像站</p><p><a href="https://kkgithub.com/">KKGitHub</a>：<a href="https://kkgithub.com/">https://kkgithub.com</a></p><h3 id="解决方法四：更改主机Host文件"><a href="#解决方法四：更改主机Host文件" class="headerlink" title="解决方法四：更改主机Host文件"></a>解决方法四：更改主机Host文件</h3><p>修改C:\Windows\System32\drivers\etc路径下的hosts文件，根据域名得到实时有效的ip地址，并改到hosts文件中，本方法现在作用不大，所以放在最后。</p><h2 id="问题二：如何下载子模块"><a href="#问题二：如何下载子模块" class="headerlink" title="问题二：如何下载子模块"></a>问题二：如何下载子模块</h2><p>下载完源代码库后，使用如下命令下载子模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>有时下载子模块时速度非常慢，尤其是自由软件库时（如sourceware.org）。此时应更换镜像源。<br>将<code>.gitmodules</code>文件中的模块url改为镜像源的url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[submodule &quot;binutils&quot;]</span><br><span class="line">path = binutils</span><br><span class="line">url = https://mirrors.tuna.tsinghua.edu.cn/git/binutils-gdb.git</span><br><span class="line">branch = binutils-2_43-branch</span><br><span class="line">shallow = true</span><br></pre></td></tr></table></figure><p>然后再执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule <span class="built_in">sync</span></span><br></pre></td></tr></table></figure><p>重新执行下载子模块的命令即可。</p><h2 id="问题二：如何申请GitHub-access-token"><a href="#问题二：如何申请GitHub-access-token" class="headerlink" title="问题二：如何申请GitHub access token"></a>问题二：如何申请GitHub access token</h2><h3 id="GitHub的安全性更新介绍"><a href="#GitHub的安全性更新介绍" class="headerlink" title="GitHub的安全性更新介绍"></a>GitHub的安全性更新介绍</h3><p>现在的GitHub已经不支持使用用户密码同步Git仓库了。为了提高安全性，GitHub现在使用SSH密钥和用户token两种方式同步Git仓库。SSH密钥方式与之前相同，而现在的token模式操作起来也很简单，所谓token，就是GitHub上生成的具有一定时效性的动态密钥。下面将介绍其生成方法。</p><h3 id="生成token的方法"><a href="#生成token的方法" class="headerlink" title="生成token的方法"></a>生成token的方法</h3><ol><li><p>登录账号，访问GitHub的<a href="https://github.com/settings/profile">个人设置页面</a>，也可点击菜单栏的<strong>settings</strong>选项。</p></li><li><p>访问GitHub的<a href="https://github.com/settings/apps">Developer settings选项页面</a>，也可点击网页左侧菜单栏的<strong>Developer settings</strong>选项。</p></li><li><p>（<strong>可不执行1，2，而直接进行此步骤</strong>）访问Github的<a href="https://github.com/settings/tokens">token设置页面</a>，或（<strong>在执行1，2的基础上</strong>）点击网页左侧菜单栏的<strong>Personal access tokens</strong>选项。</p></li><li><p>点击右边的Generate new token按钮，或直接访问<a href="https://github.com/settings/tokens/new">token生成界面</a>，输入密码。</p></li><li><p>然后进入生成页面，如果不了解token的权限，建议勾选全部选项。</p></li><li><p>记下生成的token，它不会再出现第二次了！</p></li><li><p>大功告成，这样就可以像使用密码一样使用token了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Verilog的常用操作速查</title>
      <link href="/2021/10/25/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Verilog%E9%80%9F%E6%9F%A5/"/>
      <url>/2021/10/25/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Verilog%E9%80%9F%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="位拼接运算符"><a href="#位拼接运算符" class="headerlink" title="位拼接运算符"></a>位拼接运算符</h2><h3 id="位截取"><a href="#位截取" class="headerlink" title="位截取"></a>位截取</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs2 = ins[<span class="number">24</span> : <span class="number">20</span>]</span><br></pre></td></tr></table></figure><h3 id="拼接方法"><a href="#拼接方法" class="headerlink" title="拼接方法"></a>拼接方法</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;ins[<span class="number">14</span> : <span class="number">12</span>], ins[<span class="number">31</span> : <span class="number">25</span>]&#125;</span><br><span class="line">&#123;<span class="number">3&#x27;b000</span>, <span class="number">7&#x27;b0000000</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="一个bit位的重复"><a href="#一个bit位的重复" class="headerlink" title="一个bit位的重复"></a>一个bit位的重复</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Imm = &#123;&#123;<span class="number">20</span>&#123;rImm[<span class="number">11</span> : <span class="number">11</span>]&#125;&#125;, rImm[<span class="number">11</span> : <span class="number">0</span>]&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Verilog语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Debian Linux的使用技巧</title>
      <link href="/2021/10/12/Linux/Debian%20Linux%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2021/10/12/Linux/Debian%20Linux%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-Debian"><a href="#Linux-Debian" class="headerlink" title="Linux(Debian)"></a>Linux(Debian)</h2><h3 id="镜像站，代理站"><a href="#镜像站，代理站" class="headerlink" title="镜像站，代理站"></a>镜像站，代理站</h3><ol><li>VSCode : <a href="https://vscode.cdn.azure.cn/">https://vscode.cdn.azure.cn/</a></li></ol><h3 id="开机时识别双系统Win10"><a href="#开机时识别双系统Win10" class="headerlink" title="开机时识别双系统Win10"></a>开机时识别双系统Win10</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/default</span><br><span class="line"><span class="built_in">sudo</span> update-grub</span><br></pre></td></tr></table></figure><p>此时会报警告<code>Warning: os-prober will not be executed to detect other bootable partitions.</code>，根据此警告，我们进入配置文件<code>/etc/default/grub</code>中，将其中<code>GRUB_DISABLE_OS_PROBER=false</code>一句取消注释，然后重新运行<code>sudo update-grub</code>命令，即可成功探测出Windows系统的引导程序。</p><h3 id="用于按磁盘块复制文件的dd命令"><a href="#用于按磁盘块复制文件的dd命令" class="headerlink" title="用于按磁盘块复制文件的dd命令"></a>用于按磁盘块复制文件的dd命令</h3><p>使用 dd 命令复制操作系统镜像到磁盘上。</p><p><code>if, of</code> 指定输入输出文件，<code>bs</code>指定输入输出块大小。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">dd</span> <span class="keyword">if</span>=system.img of=/dev/sda bs=1M status=progress</span><br></pre></td></tr></table></figure><p>注意<code>dd</code>命令的块大小不要设置的过大以至于超出介质的读写速度。<code>status</code>选项用来显示进度，只在GNU版本的<code>dd</code>上有效。</p><p>从磁盘拷出备份硬盘镜像时，要指定拷出块的数量，下面的例子表示从头备份4GB的硬盘文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sda of=system.backup.img bs=1M count=4096 status=progress</span><br></pre></td></tr></table></figure><p>彻底清除磁盘数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/dev/sda bs=4M status=progress</span><br></pre></td></tr></table></figure><p>如果需要改变拷出的起始位置，需要加入以下参数：</p><p><code>skip=blocks</code>：从输入文件开头跳过blocks个块后再开始复制。<br><code>seek=blocks</code>：从输出文件开头跳过blocks个块后再开始复制。 </p><p>这是几乎所有命令行软件都有的版本和帮助参数。</p><p>–help：显示帮助信息<br>–version：显示版本信息</p><p>此外，dd还有<code>conv=&lt;关键字&gt;</code>的特殊参数，但不常用。</p><blockquote><p>参考：<a href="https://www.runoob.com/linux/linux-comm-dd.html">Linux dd 命令 - 菜鸟教程</a></p></blockquote><h3 id="使得用户无需每次都输入-sudo-命令使用系统串口"><a href="#使得用户无需每次都输入-sudo-命令使用系统串口" class="headerlink" title="使得用户无需每次都输入 sudo 命令使用系统串口"></a>使得用户无需每次都输入 sudo 命令使用系统串口</h3><p>平时无论是调试网络设备，单片机烧录程序，都需要使用串口，但我当前这个用户没有使用串口的权限，所以要为他增加这个权限，不然一次次 sudo 实在是麻烦。</p><p>首先查看串口设备所属用户&#x2F;用户组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -lah /dev/ttyUSB0</span><br><span class="line">crw-rw---- 1 root dialout 188, 0 12月25日 18:04 /dev/ttyUSB0</span><br></pre></td></tr></table></figure><p>发现串口设备用户组为 dialout，那么我们只需要将当前用户加入 dialout 用户组即可。<br>查看 dialout 用户组成员</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /etc/group | grep dialout</span><br><span class="line">dialout:x:20:</span><br></pre></td></tr></table></figure><p>将当前用户加入用户组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> usermod -aG dialout $(<span class="built_in">whoami</span>)</span><br></pre></td></tr></table></figure><p>然后可以再次查看<code>/etc/group</code>验证一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /etc/group | grep dialout</span><br><span class="line">dialout:x:20:redleaves</span><br></pre></td></tr></table></figure><p>最后重启，配置生效。</p><blockquote><p>参考：<a href="https://blog.csdn.net/itas109/article/details/83027431">解决Linux非root用户读写串口权限问题</a></p></blockquote><h3 id="查询系统日志的方法"><a href="#查询系统日志的方法" class="headerlink" title="查询系统日志的方法"></a>查询系统日志的方法</h3><p>在 Debian 12 中，传统的 syslog 系统已被 systemd-journald 取代。这意味着旧的日志文件（如 syslog、messages、auth.log）不再使用。相反，所有系统日志现在都存储在集中式日志中，可以使用journalctl命令访问该日志。<br><a href="https://serverfault.com/questions/1148725/where-is-some-os-logs-in-debian-12">来源</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --since <span class="string">&quot;5 minutes ago&quot;</span></span><br></pre></td></tr></table></figure><p>通过上面的命令查日志，还发现debian的一个<a href="https://bugs.launchpad.net/ubuntu/+source/kwin/+bug/1983198">Bug</a>。</p><p>通过查这个Bug的相关信息，知道这个Bug和一个不同于Pulseaudio的音频解决方案<a href="https://blog.ryey.icu/zhs/replace-pulseaudio-with-pipewire.html">Pipewire</a>。debian12稳定版支持使用Pipewire代替Pulseaudio，准备尝试一下。（替代成功，功能暂时没有问题。）<a href="https://xfox.fun/archives/1656/">参照1</a>，<a href="https://wiki.debian.org/PipeWire">参照2</a></p><h3 id="find-命令排除一个目录"><a href="#find-命令排除一个目录" class="headerlink" title="find 命令排除一个目录"></a>find 命令排除一个目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find / -path &quot;/media&quot; -prune -o -path &quot;/home&quot; -prune -o -name &quot;*drawio*&quot; -print</span><br></pre></td></tr></table></figure><p>-path “&#x2F;home&#x2F;user&#x2F;Downloads”：指定要排除的目录路径。<br>-prune：告诉 find 不要进入 Downloads 目录。<br>-o (OR)：将 -prune 操作与下一个搜索条件连接起来。<br>-name “*.txt”：查找所有以 .txt 结尾的文件。<br>-print：输出找到的文件。</p><h3 id="关于read函数"><a href="#关于read函数" class="headerlink" title="关于read函数"></a>关于read函数</h3><p>使用read函数读取时，会出现一次读不完数据的情况，这时需要使用while循环，直到读取到特定的长度再停止。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 桌面环境 </tag>
            
            <tag> 命令行 </tag>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机运算原理</title>
      <link href="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97/"/>
      <url>/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="概念一：逻辑移位和算数移位"><a href="#概念一：逻辑移位和算数移位" class="headerlink" title="概念一：逻辑移位和算数移位"></a>概念一：逻辑移位和算数移位</h2><p>在左移的情况下，逻辑移位和算数移位概念不必区分。</p><p>在右移的情况下：</p><ol><li><p>逻辑移位：</p><p>在C语言中，无符号数使用逻辑移位，左面的位用0补齐，例子中的数为一个8位二进制数</p><p>举例 </p><p>$(01100011)_2  \stackrel{\text{逻辑右移一位}}{\rightarrow} (00110001)_2$</p><p>$(11100011)_2  \stackrel{\text{逻辑右移一位}}{\rightarrow} (01110001)_2$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a;</span><br></pre></td></tr></table></figure></li><li><p>算数移位：</p><p>在C语言中，有符号数使用算数移位，左面的位用高位补齐，例子中的数为一个8位二进制数</p><p>举例</p><p>$(01100011)_2  \stackrel{逻辑右移一位}{\rightarrow} (00110001)_2$</p><p>$(11100011)_2  \stackrel{逻辑右移一位}{\rightarrow} (11110001)_2$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br></pre></td></tr></table></figure></li><li><p>示例</p><p>试说明以下程序的输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> xx = <span class="number">0xffffffff</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="type">int</span>)(x &gt;&gt; <span class="number">1</span>));<span class="comment">//将结果强制以整形输出，-1，即0xffffffff</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="type">int</span>)(xx &gt;&gt; <span class="number">1</span>));<span class="comment">//输出2147483647，即0x7fffffff</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="概念二：补码"><a href="#概念二：补码" class="headerlink" title="概念二：补码"></a>概念二：补码</h2><p>正数补码就是其二进制原码本身，即$\sum a_n 2^n$，但负数补码的本质是什么？</p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>答：负数补码的本质是剩余系下的运算。</p><p>如果你了解模$n$剩余系，整数补码就是模$2^{32}$剩余系下的运算。下面的内容就不用看了。</p><p>补码的思想：一个钟表，当前指向7点，问5个小时前是几点？</p><p>看起来很容易，做一个减法，肯定是1点。</p><p>但是，如果我们现在不会减法，该怎么办？</p><p>5个小时前，在表盘上指针指向的位置，和7小时之后表盘上指针指向的位置相同。</p><p>下图是一个与钟表相近的例子，用4位二进制数表示[-8,7]的整数。</p><p><img src="/assets/bit_circle.png" alt="补码"></p><p>推广理解一下，在计算机中，对于有限的c个数位，一个数x减去一个值a与加上一个值b的结果相同。</p><p>此时a + b应该满足互补关系，即a + b的进位超出了c个数位表示的范围，在数值上，$a+b&#x3D;2^c$。在计算机运算中，进位被忽略，此时a + b的值刚好为0。</p><p>注意补码中一个特殊情况，上图中的<code>-8</code>，它不满足上面的规律，因为四位二进制数有16个，无法满足关于0对称的条件，但忽略这个数，或将其映射到0，会造成有符号数和无符号数的割裂和歧义。</p><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/362265365">什么是补码？这是地球上最通俗易懂的补码阐述</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python程序常用操作速查</title>
      <link href="/2021/09/29/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python%E9%80%9F%E6%9F%A5/"/>
      <url>/2021/09/29/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python%E9%80%9F%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="一，如何实现多组数据的输入输出"><a href="#一，如何实现多组数据的输入输出" class="headerlink" title="一，如何实现多组数据的输入输出"></a>一，如何实现多组数据的输入输出</h2><p>Python中使用异常来完成多组数据的输入输出</p><p>举例：计算a + b的多组输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">a, b</span>) :</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">True</span>) :</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            a = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">            b = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">            <span class="built_in">print</span>(calc(a, b))</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="二，Python文件操作"><a href="#二，Python文件操作" class="headerlink" title="二，Python文件操作"></a>二，Python文件操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.打开文件</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;work.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 读取文件内容</span></span><br><span class="line">text = file.read()</span><br><span class="line"><span class="built_in">print</span>(text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.关闭文件</span></span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.按格式输出时间</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_formated_times</span>(<span class="params">timestamp</span>):</span><br><span class="line">    <span class="keyword">return</span>  time.strftime(<span class="string">&quot;%Y-%m-%dT%H:%M:%SZ&quot;</span>, time.localtime(timestamp))</span><br></pre></td></tr></table></figure><h2 id="三、Python-语言实现随机数"><a href="#三、Python-语言实现随机数" class="headerlink" title="三、Python 语言实现随机数"></a>三、Python 语言实现随机数</h2><p>Python语言生成随机数十分便利，也不需要我们设置随机数种子之类的。下面就是生成0-9之间整数随机数的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(random.randint(<span class="number">0</span>,<span class="number">9</span>))</span><br></pre></td></tr></table></figure><p>random更详细的参考如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机整数：</span></span><br><span class="line"><span class="built_in">print</span> random.randint(<span class="number">1</span>,<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机选取0到100间的偶数：</span></span><br><span class="line"><span class="built_in">print</span> random.randrange(<span class="number">0</span>, <span class="number">101</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机浮点数：</span></span><br><span class="line"><span class="built_in">print</span> random.random()</span><br><span class="line"><span class="built_in">print</span> random.uniform(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机字符：</span></span><br><span class="line"><span class="built_in">print</span> random.choice(<span class="string">&#x27;abcdefghijklmnopqrstuvwxyz!@#$%^&amp;*()&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个字符中生成指定数量的随机字符：</span></span><br><span class="line"><span class="built_in">print</span> random.sample(<span class="string">&#x27;zyxwvutsrqponmlkjihgfedcba&#x27;</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从a-zA-Z0-9生成指定数量的随机字符：</span></span><br><span class="line">ran_str = <span class="string">&#x27;&#x27;</span>.join(random.sample(string.ascii_letters + string.digits, <span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span> ran_str</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个字符中选取指定数量的字符组成新字符串：</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(random.sample([<span class="string">&#x27;z&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>], <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机选取字符串：</span></span><br><span class="line"><span class="built_in">print</span> random.choice([<span class="string">&#x27;剪刀&#x27;</span>, <span class="string">&#x27;石头&#x27;</span>, <span class="string">&#x27;布&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打乱排序</span></span><br><span class="line">items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span> random.shuffle(items)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 实用功能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown与latex特殊符号，格式速查</title>
      <link href="/2021/09/22/Sharp%20Tools/Markdown%E4%B8%AA%E4%BA%BA%E9%80%9F%E6%9F%A5/"/>
      <url>/2021/09/22/Sharp%20Tools/Markdown%E4%B8%AA%E4%BA%BA%E9%80%9F%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="在mathjax与hexo引擎中正常显示公式的注意事项"><a href="#在mathjax与hexo引擎中正常显示公式的注意事项" class="headerlink" title="在mathjax与hexo引擎中正常显示公式的注意事项"></a>在mathjax与hexo引擎中正常显示公式的注意事项</h2><p><strong>注意</strong>：本博客使用mathjax解析，使用这个引擎解析公式时，<code>\\</code>会被转义，所以在 latex 中应输入<code>\\</code>的部分都应使用<code>\\\\</code>确保在mathjax下正常解析。当然，还有一个更好的方法，如果使用 hexo 搭建博客，可以牺牲一点美观度，在 markdown 文档中使用如下的符号确保公式正常显示：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">$$</span><br><span class="line">   \begin&#123;vmatrix&#125;</span><br><span class="line"><span class="code">    1 &amp; 0 &amp; 0\\</span></span><br><span class="line"><span class="code">    0 &amp; 1 &amp; 0\\</span></span><br><span class="line"><span class="code">    0 &amp; 0 &amp; 1\\</span></span><br><span class="line"><span class="code">   \end&#123;vmatrix&#125;</span></span><br><span class="line"><span class="code">   \&#123;\&#125;</span></span><br><span class="line"><span class="code">$$</span></span><br><span class="line"><span class="code">&#123;% endraw %&#125;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p>$$   \begin{vmatrix}    1 & 0 & 0\\    0 & 1 & 0\\    0 & 0 & 1\\   \end{vmatrix}   \{\}$$<h2 id="一，符号速查"><a href="#一，符号速查" class="headerlink" title="一，符号速查"></a>一，符号速查</h2><table><thead><tr><th align="center">符号</th><th align="center">语法</th></tr></thead><tbody><tr><td align="center">$\sim$</td><td align="center"><code>\sim</code></td></tr><tr><td align="center">$\rightarrow$</td><td align="center"><code>\rightarrow</code></td></tr><tr><td align="center">$\stackrel{\text{Up}}{\underset{Down}{&#x3D;&#x3D;}}$</td><td align="center"><code>\stackrel&#123;\text&#123;Up&#125;&#125;&#123;\underset&#123;Down&#125;&#123;==&#125;&#125;</code></td></tr><tr><td align="center">$\rightleftharpoons$</td><td align="center"><code>\rightleftharpoons</code></td></tr><tr><td align="center">$\parallel x \parallel$</td><td align="center"><code>\parallel x \parallel</code></td></tr><tr><td align="center">$\sum$，$\prod$</td><td align="center"><code>\sum \prod</code></td></tr><tr><td align="center">$\lfloor x \rfloor$，$\lceil x \rceil$</td><td align="center"><code>\lfloor x \rfloor , \lceil x \rceil</code></td></tr><tr><td align="center">$\cdot$，$\cdots$</td><td align="center"><code>\cdot, \cdots</code></td></tr><tr><td align="center">$\partial$</td><td align="center"><code>\partial</code></td></tr><tr><td align="center">$\bigg</td><td align="center">$</td></tr><tr><td align="center">$\approx$</td><td align="center"><code>\approx</code></td></tr><tr><td align="center">$\infty,\propto$</td><td align="center"><code>\infty,\propto</code></td></tr><tr><td align="center">$\overline{y},\hat{y},\tilde{D},\widetilde{D}$</td><td align="center"><code>\overline&#123;y&#125;, \hat&#123;y&#125;, \tilde&#123;D&#125;,\widetilde&#123;D&#125;</code></td></tr><tr><td align="center">$\triangle,\Delta,\nabla$</td><td align="center"><code>\triangle,\nabla</code></td></tr><tr><td align="center">$\int$</td><td align="center"><code>\int</code></td></tr></tbody></table><h2 id="二，输入箭头及上方字符"><a href="#二，输入箭头及上方字符" class="headerlink" title="二，输入箭头及上方字符"></a>二，输入箭头及上方字符</h2><p>大部分符号变成双向只需要将首字母大写，变成长符号只需要在前面加上一个long&#x2F;Long)</p><hr><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p>   效果1 : $2H_{2}O \stackrel{通电}{\rightarrow} 2H_{2} + O_{2}$</p><p>   效果2 : $2H_{2}O \stackrel{\text{通电}}{&#x3D;&#x3D;} 2H_{2} + O_{2}$</p><p>   效果3 : $4NH_3 + 5O_2 \stackrel{\text{催化剂}}{\underset{\Delta}{\rightleftharpoons}} 4NO + 6H_2O$</p><p>   效果4 : $\stackrel{-2}{^{16}_{8}O^{2-}_2}$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2H<span class="emphasis">_&#123;2&#125;O \stackrel&#123;通电&#125;&#123;\rightarrow&#125; 2H_</span>&#123;2&#125; + O<span class="emphasis">_&#123;2&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">2H_</span>&#123;2&#125;O \stackrel&#123;\text&#123;通电&#125;&#125;&#123;==&#125; 2H<span class="emphasis">_&#123;2&#125; + O_</span>&#123;2&#125;</span><br><span class="line"></span><br><span class="line">4NH<span class="emphasis">_3 + 5O_</span>2 \stackrel&#123;\text&#123;催化剂&#125;&#125;&#123;\underset&#123;\Delta&#125;&#123;\rightleftharpoons&#125;&#125; 4NO + 6H<span class="emphasis">_2O</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">\stackrel&#123;-2&#125;&#123;^&#123;16&#125;_</span>&#123;8&#125;O^&#123;2-&#125;<span class="emphasis">_2&#125;</span></span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在<code>\stackrel</code>中，不需要加花括号的时候不要加。</p><h3 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h3><p>   <a href="https://www.zhihu.com/question/356331842">如何用markdown写化学方程式？ - 知乎 (zhihu.com)</a></p><p>   <a href="https://www.bilibili.com/video/BV1mK4y147Lq?from=search&seid=4134217629237576756">化学方程式的Markdown打法_哔哩哔哩_bilibili</a></p><p>   <a href="https://blog.csdn.net/m0_37167788/article/details/78603307">MarkDown - Latex符号(箭头)的整理</a></p><h2 id="三，输入矩阵及数字对齐"><a href="#三，输入矩阵及数字对齐" class="headerlink" title="三，输入矩阵及数字对齐"></a>三，输入矩阵及数字对齐</h2><ol><li><p>小括号&#x2F;中括号矩阵，行列式，矩阵间等号</p><p>效果</p><p>$$<br>\begin{pmatrix}<br> 1 &amp; 0 &amp; 0\\<br> 0 &amp; 1 &amp; 0\\<br> 0 &amp; 0 &amp; 1\<br>\end{pmatrix}<br>{&#x3D;}<br>\begin{bmatrix}<br> 1 &amp; 0 &amp; 0\\<br> 0 &amp; 1 &amp; 0\\<br> 0 &amp; 0 &amp; 1\<br>\end{bmatrix}<br>\quad<br>\begin{vmatrix}<br> 1 &amp; 0 &amp; 0\\<br> 0 &amp; 1 &amp; 0\\<br> 0 &amp; 0 &amp; 1\<br>\end{vmatrix}<br>$$</p><p>代码</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;pmatrix&#125;</span><br><span class="line"> 1 <span class="built_in">&amp;</span> 0 <span class="built_in">&amp;</span> 0<span class="keyword">\\</span></span><br><span class="line"> 0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 0<span class="keyword">\\</span></span><br><span class="line"> 0 <span class="built_in">&amp;</span> 0 <span class="built_in">&amp;</span> 1<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br><span class="line">&#123;=&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line"> 1 <span class="built_in">&amp;</span> 0 <span class="built_in">&amp;</span> 0<span class="keyword">\\</span></span><br><span class="line"> 0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 0<span class="keyword">\\</span></span><br><span class="line"> 0 <span class="built_in">&amp;</span> 0 <span class="built_in">&amp;</span> 1<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="keyword">\quad</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;vmatrix&#125;</span><br><span class="line"> 1 <span class="built_in">&amp;</span> 0 <span class="built_in">&amp;</span> 0<span class="keyword">\\</span></span><br><span class="line"> 0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 0<span class="keyword">\\</span></span><br><span class="line"> 0 <span class="built_in">&amp;</span> 0 <span class="built_in">&amp;</span> 1<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;vmatrix&#125;</span><br></pre></td></tr></table></figure></li><li><p>输入带省略号的矩阵</p><p>效果<br>$$<br>\pmb{X}&#x3D;\begin{pmatrix}<br>x_{11} &amp; x_{12}&amp; \cdots &amp; x_{1d} &amp; 1 \\<br>x_{21} &amp; x_{22}&amp; \cdots &amp; x_{2d} &amp; 1 \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\<br>x_{m1} &amp; x_{m2}&amp; \cdots &amp; x_{md} &amp; 1 \\<br>\end{pmatrix}<br>$$</p><p>代码</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\pmb</span>&#123;X&#125;=<span class="keyword">\begin</span>&#123;pmatrix&#125;</span><br><span class="line">x<span class="built_in">_</span>&#123;11&#125; <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;12&#125;<span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;1d&#125; <span class="built_in">&amp;</span> 1 <span class="keyword">\\</span></span><br><span class="line">x<span class="built_in">_</span>&#123;21&#125; <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;22&#125;<span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;2d&#125; <span class="built_in">&amp;</span> 1 <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\ddots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="keyword">\\</span></span><br><span class="line">x<span class="built_in">_</span>&#123;m1&#125; <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;m2&#125;<span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;md&#125; <span class="built_in">&amp;</span> 1 <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现试卷中对齐的选项效果</p><p>效果</p><p>$$<br>\begin{array}{cc}<br> (A)\quad 4 &amp; \hspace{4cm}(B)\quad 3 \\<br> (C)\quad 2 &amp; \hspace{4cm}(D)\quad 1 \end{array}<br> $$</p><p>代码</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;array&#125;&#123;cc&#125;</span><br><span class="line">        (A)<span class="keyword">\quad</span> 4 <span class="built_in">&amp;</span> <span class="keyword">\hspace</span>&#123;4cm&#125;(B)<span class="keyword">\quad</span> 3 <span class="keyword">\\</span><span class="keyword">\\</span></span><br><span class="line">        (C)<span class="keyword">\quad</span> 2 <span class="built_in">&amp;</span> <span class="keyword">\hspace</span>&#123;4cm&#125;(D)<span class="keyword">\quad</span> 1</span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125;</span><br></pre></td></tr></table></figure></li><li><p>表格效果</p><p>效果</p><p>$$\begin{array}{|c|c|}<br> \hline 0 &amp; 1 \\\hline 1 &amp; 0 \\\hline<br>\end{array}$$</p><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;array&#125;&#123;|c|c|&#125;</span><br><span class="line">        \hline</span><br><span class="line">        0 &amp; 1 \\hline</span><br><span class="line">        1 &amp; 0 \\hline</span><br><span class="line">\end&#123;array&#125;</span><br></pre></td></tr></table></figure></li><li><p>大括号</p><p>效果</p><p>$\begin{cases}<br> x´&#x3D;x \text{cos}\theta-y \text{sin}\theta \\<br> y´&#x3D;x \text{sin}\theta+y \text{cos}\theta \\<br> \end{cases}$</p><p>代码</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">      x´=x <span class="keyword">\text</span>&#123;cos&#125;<span class="keyword">\theta</span>-y <span class="keyword">\text</span>&#123;sin&#125;<span class="keyword">\theta</span> <span class="keyword">\\</span></span><br><span class="line">      y´=x <span class="keyword">\text</span>&#123;sin&#125;<span class="keyword">\theta</span>+y <span class="keyword">\text</span>&#123;cos&#125;<span class="keyword">\theta</span> <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure></li></ol><p><a href="https://zhuanlan.zhihu.com/p/266267223">更多有关矩阵的写法</a></p><h2 id="四，字母的字体，加粗，下划线"><a href="#四，字母的字体，加粗，下划线" class="headerlink" title="四，字母的字体，加粗，下划线"></a>四，字母的字体，加粗，下划线</h2><table><thead><tr><th align="center">效果</th><th align="center">语法</th></tr></thead><tbody><tr><td align="center">$\pmb{Latex}$</td><td align="center"><code>\pmb&#123;Latex&#125;</code></td></tr><tr><td align="center">$\underline{Latex}$</td><td align="center"><code>\underline&#123;Latex&#125;</code></td></tr><tr><td align="center">$\bf{Latex}$</td><td align="center"><code>\bf&#123;Latex&#125;</code></td></tr><tr><td align="center">$\mathbb{R}$</td><td align="center"><code>\mathbb&#123;R&#125;</code></td></tr><tr><td align="center">$\mathcal{R}$</td><td align="center"><code>\mathcal&#123;R&#125;</code></td></tr><tr><td align="center">$\mathscr{R}$</td><td align="center"><code>\mathscr&#123;R&#125;</code></td></tr><tr><td align="center">$\mathbf{R}$</td><td align="center"><code>\mathbf&#123;R&#125;</code></td></tr><tr><td align="center">$\mathit{R}$</td><td align="center"><code>\mathit&#123;R&#125;</code></td></tr><tr><td align="center">$\mathrm{R}$</td><td align="center"><code>\mathrm&#123;R&#125;</code></td></tr><tr><td align="center">$\mathsf{R}$</td><td align="center"><code>\mathsf&#123;R&#125;</code></td></tr><tr><td align="center">$\mathtt{R}$</td><td align="center"><code>\mathtt&#123;R&#125;</code></td></tr><tr><td align="center">$\mathfrak{R}$</td><td align="center"><code>\mathfrank&#123;R&#125;</code></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\mathfrak&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125;</span><br></pre></td></tr></table></figure><p>$\mathfrak{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\mathscr&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125;</span><br></pre></td></tr></table></figure><p>$\mathscr{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\mathcal&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125;</span><br></pre></td></tr></table></figure><p>$\mathcal{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\mathbb&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125;</span><br></pre></td></tr></table></figure><p>$\mathbb{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$</p><h2 id="五，为公式加编号"><a href="#五，为公式加编号" class="headerlink" title="五，为公式加编号"></a>五，为公式加编号</h2><p>效果<br>$$<br>\frac{\partial\pmb{A}^\text{T}\pmb{x}}{\partial \pmb{x}}&#x3D;\pmb{A}\tag{1.1}<br>$$</p><p>代码</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="keyword">\pmb</span>&#123;A&#125;<span class="built_in">^</span><span class="keyword">\text</span>&#123;T&#125;<span class="keyword">\pmb</span>&#123;x&#125;&#125;&#123;<span class="keyword">\partial</span> <span class="keyword">\pmb</span>&#123;x&#125;&#125;=<span class="keyword">\pmb</span>&#123;A&#125;<span class="keyword">\tag</span>&#123;1.1&#125;</span><br></pre></td></tr></table></figure><h2 id="六，markdown-特殊格式"><a href="#六，markdown-特殊格式" class="headerlink" title="六，markdown 特殊格式"></a>六，markdown 特殊格式</h2><h3 id="一，中文段首首行缩进"><a href="#一，中文段首首行缩进" class="headerlink" title="一，中文段首首行缩进"></a>一，中文段首首行缩进</h3><p><strong><font size = 5 face = "KAITI">markdown语法中，多个空格只会被翻译成一个空格</font></strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">半角的空白<span class="literal">&amp;ensp;</span>或<span class="literal">&amp;#8194;</span></span><br><span class="line">全角的空白<span class="literal">&amp;emsp;</span>或<span class="literal">&amp;#8195;</span></span><br><span class="line">不断行的空白格<span class="literal">&amp;nbsp;</span>或<span class="literal">&amp;#160;</span></span><br></pre></td></tr></table></figure><h2 id="二，Latex公式的对齐"><a href="#二，Latex公式的对齐" class="headerlink" title="二，Latex公式的对齐"></a>二，Latex公式的对齐</h2><ol><li><p>公式无序号，使用</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;align*&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">\end</span>&#123;align*&#125;</span><br></pre></td></tr></table></figure></li><li><p>公式有序号，使用</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">行1等号左 <span class="built_in">&amp;</span>= 行1等号右 <span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span>= 行2等号右 <span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span>= 行3等号右 <span class="keyword">\notag</span> <span class="keyword">\\</span> <span class="comment">%\notag取消标记%</span></span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br></pre></td></tr></table></figure></li><li><p>示例</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align*&#125; <span class="keyword">\text</span>&#123;sgn&#125;(H(<span class="keyword">\pmb</span>&#123;x&#125;))<span class="built_in">&amp;</span>=<span class="keyword">\text</span>&#123;sgn&#125;(<span class="keyword">\frac</span>&#123;1&#125;           &#123;2&#125;<span class="keyword">\ln</span><span class="keyword">\frac</span>&#123;P(f(<span class="keyword">\pmb</span>&#123;x&#125;)=1|<span class="keyword">\pmb</span>&#123;x&#125;)&#125;&#123;P(f(<span class="keyword">\pmb</span>&#123;x&#125;)=-1|<span class="keyword">\pmb</span>&#123;x&#125;)&#125;) <span class="keyword">\\</span><span class="keyword">\\</span> <span class="built_in">&amp;</span>=<span class="keyword">\begin</span>&#123;cases&#125;1, P(f(<span class="keyword">\pmb</span>&#123;x&#125;)=1|<span class="keyword">\pmb</span>&#123;x&#125;) &gt; P(f(<span class="keyword">\pmb</span>&#123;x&#125;)=-1|<span class="keyword">\pmb</span>&#123;x&#125;) <span class="keyword">\\</span><span class="keyword">\\</span> -1, P(f(<span class="keyword">\pmb</span>&#123;x&#125;)=1|<span class="keyword">\pmb</span>&#123;x&#125;) &lt; P(f(<span class="keyword">\pmb</span>&#123;x&#125;)=-1|<span class="keyword">\pmb</span>&#123;x&#125;)<span class="keyword">\end</span>&#123;cases&#125; <span class="keyword">\\</span><span class="keyword">\\</span> <span class="built_in">&amp;</span>=<span class="keyword">\underset</span>&#123;y <span class="keyword">\in</span> <span class="keyword">\&#123;</span>-1,1<span class="keyword">\&#125;</span>&#125;&#123;<span class="keyword">\arg</span><span class="keyword">\max</span>&#125;P(f(<span class="keyword">\pmb</span>&#123;x&#125;)=y | <span class="keyword">\pmb</span>&#123;x&#125;) <span class="keyword">\end</span>&#123;align*&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>   $$   \begin{align*} \text{sgn}(H(\pmb{x}))&=\text{sgn}(\frac{1}           {2}\ln\frac{P(f(\pmb{x})=1|\pmb{x})}{P(f(\pmb{x})=-1|\pmb{x})}) \\\\ &=\begin{cases}1, P(f(\pmb{x})=1|\pmb{x}) > P(f(\pmb{x})=-1|\pmb{x}) \\\\ -1, P(f(\pmb{x})=1|\pmb{x}) < P(f(\pmb{x})=-1|\pmb{x})\end{cases} \\\\ &=\underset{y \in \{-1,1\}}{\arg\max}P(f(\pmb{x})=y | \pmb{x}) \end{align*}   $$   </li></ol><h2 id="七，字体"><a href="#七，字体" class="headerlink" title="七，字体"></a>七，字体</h2><h3 id="1-效果实例"><a href="#1-效果实例" class="headerlink" title="1.效果实例"></a>1.效果实例</h3><p><font size = 4 face="HEI" color = "red">黑体</font></p><p><font size = 5 face="KAI" color = "(0,255,255)">楷体</font></p><p><font size = 6 face="GB18030 Bitmap" color = "#00FFFF">扩展字体</font></p><h3 id="2-markdown代码"><a href="#2-markdown代码" class="headerlink" title="2.markdown代码"></a>2.markdown代码</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#### 使用 <span class="language-xml"><span class="tag">&lt;<span class="name">font</span>&gt;</span></span> 标签的修改字体，字号，颜色</span></span><br><span class="line"></span><br><span class="line">这里是默认字体</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">4</span> <span class="attr">face</span>=<span class="string">&quot;HEI&quot;</span> <span class="attr">color</span> = <span class="string">&quot;red&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span> <span class="attr">face</span>=<span class="string">&quot;KAI&quot;</span> <span class="attr">color</span> = <span class="string">(0,255,255)</span>&gt;</span></span>楷体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">6</span> <span class="attr">face</span>=<span class="string">&quot;GB18030 Bitmap&quot;</span> <span class="attr">color</span> = <span class="string">&quot;#00FFFF&quot;</span>&gt;</span></span>扩展字体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span><br><span class="line">p &#123;font-size: 2rem;&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="3-常用字体集锦"><a href="#3-常用字体集锦" class="headerlink" title="3.常用字体集锦"></a>3.常用字体集锦</h3><table><thead><tr><th align="center">字体名称</th><th align="center">对应markdown表示</th></tr></thead><tbody><tr><td align="center">黑体</td><td align="center"><code>&lt;font face=&#39;SimHei&#39;&gt;</code></td></tr><tr><td align="center">宋体</td><td align="center"><code>&lt;font face=&#39;SimSun&#39;&gt;</code></td></tr><tr><td align="center">新宋体</td><td align="center"><code>&lt;font face=&#39;NSimSun&#39;&gt;</code></td></tr><tr><td align="center">仿宋</td><td align="center"><code>&lt;font face=&#39;FangSong&#39;&gt;</code></td></tr><tr><td align="center">楷体</td><td align="center"><code>&lt;font face=&#39;KaiTi&#39;&gt;</code></td></tr><tr><td align="center">仿宋_GB2312</td><td align="center"><code>&lt;font face=&#39;FangSong_GB2312&#39;&gt;</code></td></tr><tr><td align="center">楷体_GB2312</td><td align="center"><code>&lt;font face=&#39;KaiTi_GB2312&#39;&gt;</code></td></tr><tr><td align="center">微软雅黑</td><td align="center"><code>&lt;font face=&#39;Microsoft YaHei&#39;&gt;</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> 文档工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在本地部署LearnGitBranch</title>
      <link href="/2021/09/14/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%9C%A8%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2LearnGitBranch/"/>
      <url>/2021/09/14/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%9C%A8%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2LearnGitBranch/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是LearnGitBranch"><a href="#什么是LearnGitBranch" class="headerlink" title="什么是LearnGitBranch"></a>什么是LearnGitBranch</h2><p>LearnGitBranch是一款基于javascript开发的Git学习平台，平台以生动的图形化界面和闯关的方式，帮助我们学习Git的使用。大大降低了Git学习的门槛。</p><h2 id="为什么在本地部署？"><a href="#为什么在本地部署？" class="headerlink" title="为什么在本地部署？"></a>为什么在本地部署？</h2><p>网络版本在这里，方便快捷。</p><p>网络版：</p><p><a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching中文</a></p><p><a href="https://learngitbranching.js.org/?locale=en_US">Learn Git Branching英文</a></p><p>众所周知，有计算机的地方，不一定就有网络，有时候，网络信号不好，1KB&#x2F;s的网速，让人无法忍受。我们能不能在本地部署LearnGitBranch，随时随地方便的练习和复习呢？当然可以！</p><h2 id="如何在本地部署"><a href="#如何在本地部署" class="headerlink" title="如何在本地部署"></a>如何在本地部署</h2><p>在<a href="https://github.com/pcottle/learnGitBranching">这里</a>的README文件可以看到作者对于部署方法的建议，这里我只是把它实现了一遍，在<a href="https://redleaves699.github.io/2021/09/02/Programming%20Language/JavaScript%20and%20Web/%E4%BD%BF%E7%94%A8hexo%E5%92%8Cnode.js%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/">这篇博客</a>里，我配置了node.js环境，所以有些步骤可以省略。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下命令均在git bash内执行，执行前，先进入源代码所在目录</span></span><br><span class="line"><span class="comment"># 检查相关组件版本</span></span><br><span class="line">node --version</span><br><span class="line">npm --version</span><br><span class="line">npx --version</span><br><span class="line"><span class="comment"># 安装gulp相关组件</span></span><br><span class="line">npm <span class="built_in">rm</span> --global gulp</span><br><span class="line">npm install --global gulp-cli</span><br><span class="line"><span class="comment"># 查看gulp是否安装成功</span></span><br><span class="line">gulp --version</span><br><span class="line"><span class="comment"># 安装yarn</span></span><br><span class="line">npm i -g yarn</span><br><span class="line">yarn --version</span><br><span class="line"><span class="comment"># 运行gulp，安装依赖组件并生成相关文件</span></span><br><span class="line">gulp</span><br><span class="line"><span class="comment"># 最后，打开目录下的index.html即可</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百年未有之大变局</title>
      <link href="/2021/07/26/%E6%84%9F%E6%83%B3%E9%9A%8F%E7%AC%94/%E7%99%BE%E5%B9%B4/"/>
      <url>/2021/07/26/%E6%84%9F%E6%83%B3%E9%9A%8F%E7%AC%94/%E7%99%BE%E5%B9%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="百年未有之大变局"><a href="#百年未有之大变局" class="headerlink" title="百年未有之大变局"></a>百年未有之大变局</h2><p>百年未有之大变局，概括起来说，就是当前国际格局和国际体系正在发生深刻调整，全球治理体系正在发生深刻变革，<br>国际力量对比正在发生近代以来最具革命性的变化，世界范围内正在呈现出影响人类历史进程和趋向的重大态势。<br> 《习近平 新时代中国特色社会主义思想学习问答》第42页，第二段</p><h2 id="当代世界政治的基本特征"><a href="#当代世界政治的基本特征" class="headerlink" title="当代世界政治的基本特征"></a>当代世界政治的基本特征</h2><ol><li>国际局势总体稳定局部动荡</li><li>国际力量对比向均衡方向发展<ul><li>新兴市场国家和发展中国家群体性崛起</li><li>区域，次区域力量中心兴起</li></ul></li><li>大国关系深度调整<ul><li>磋商，协调，合作成为大国关系的主导方面</li><li>美国对外战略牵动着大国关系的调整</li><li>大国关系进入全方位角力阶段</li></ul></li><li>联合国等国际组织的作用不断增强<ul><li>联合国在维护世界和平，地区稳定，解决国际争端等方面作用明显</li><li>联合国在核军控，裁军方面做出积极贡献</li><li>联合国在促进世界经济和社会发展，面对重大全球问题方面成效显著</li><li>联合国在完善国际法和国际行为规范方面贡献突出</li></ul></li></ol><h2 id="世界主要国家军事战略调整与军事力量转型"><a href="#世界主要国家军事战略调整与军事力量转型" class="headerlink" title="世界主要国家军事战略调整与军事力量转型"></a>世界主要国家军事战略调整与军事力量转型</h2><ol><li>美国：“广泛威慑”，加快推进军事转型</li><li>俄罗斯：调整军兵种体制，建立战区联合作战指挥体制，推进新面貌改革，对新面貌改革进行修补完善</li><li>北约：集体防御。重新界定敌友，暂缓东扩。建立“快反”作战能力</li><li>日本：突破“专守防卫”，加强美日同盟，加强军事力量建设，提升作战能力</li><li>印度：走出印度洋，推进军事力量转型，增强核威慑力量建设</li></ol><h2 id="当代美国政治特征"><a href="#当代美国政治特征" class="headerlink" title="当代美国政治特征"></a>当代美国政治特征</h2><ol><li>美国政治制度：三权分立，两党制，联邦制</li><li>美国政治制度的文化渊源：基督教文化，近代欧洲资本主义政治思想，西方法律文化</li><li>美国政治深层次矛盾：两党政治极化现象愈发明显，利益集团影响日益扩大，种族矛盾和族群冲突持续</li></ol>]]></content>
      
      
      <categories>
          
          <category> 感想随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
